import type { Express, Request } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { parse as parseCookie } from "cookie";
import multer from "multer";
import path from "path";
import { storage, NotFoundError } from "./storage";
import { openAIService } from "./services/openai";
import { setupAuth, isAuthenticated, requireRole, getSession, initializeSession } from "./replitAuth";
import { requireResourceOwnership } from "./middleware/resourceOwnership";
import { createGoogleMeetEvent, deleteGoogleMeetEvent, checkGoogleCalendarConnection, listEvents, createCalendarEvent } from "./googleCalendar";
import { syncMaintenanceTicketToGoogleCalendar, deleteMaintenanceTicketFromGoogleCalendar } from "./googleCalendarService";
import { calculateRentalCommissions, calculateExternalCommission } from "./commissionCalculator";
import { sendVerificationEmail, sendLeadVerificationEmail, sendDuplicateLeadNotification, sendOwnerReferralVerificationEmail, sendOwnerReferralApprovedNotification, sendOfferLinkEmail } from "./gmail";
import { readUnitsFromSheet, getSpreadsheetInfo, readTRHUnitsFromSheet, parseTRHRow, getTRHSheetStats } from "./googleSheets";
import { imageProcessor } from "./imageProcessor";
import { getPropertyTitle } from "./propertyHelpers";
import { setupGoogleAuth } from "./googleAuth";
import { generateOfferPDF, generateRentalFormPDF, generateOwnerFormPDF, generateQuotationPDF } from "./pdfGenerator";
import { processChatbotMessage, generatePropertyRecommendations } from "./chatbot";
import { processExternalChatbotMessage } from "./externalChatbot";
import { authLimiter, registrationLimiter, emailVerificationLimiter, chatbotLimiter, propertySubmissionLimiter, publicLeadRegistrationLimiter, tokenRegenerationLimiter } from "./rateLimiters";
import { encrypt, decrypt } from "./encryption";
import { 
  sanitizeText, 
  sanitizeHtml, 
  sanitizeObject,
  isValidEmail,
  isValidURL,
  isValidPhoneNumber,
  sanitizePhoneNumber,
  isStrongPassword,
  normalizeEmail,
  containsSQLKeywords,
  containsScriptTags
} from "./sanitize";
import { handleGenericError, handleZodError } from "./errorHandling";
import { cache, CacheKeys, CacheTTL } from "./cache";
import { generateTemporaryPassword, validatePasswordStrength } from "./utils/password";
import bcrypt from "bcryptjs";
import crypto from "crypto";
import { z } from "zod";
import { format } from "date-fns";
import { es } from "date-fns/locale";
import {
  insertPropertySchema,
  insertAppointmentSchema,
  insertCalendarEventSchema,
  insertPresentationCardSchema,
  insertServiceProviderSchema,
  insertServiceSchema,
  insertServiceBookingSchema,
  insertOfferSchema,
  insertPermissionSchema,
  insertPropertyStaffSchema,
  insertBudgetSchema,
  insertTaskSchema,
  insertWorkReportSchema,
  insertAuditLogSchema,
  adminLoginSchema,
  updateAdminProfileSchema,
  updateAdminPasswordSchema,
  userRegistrationSchema,
  userLoginSchema,
  setTemporaryPasswordSchema,
  changePasswordSchema,
  forcePasswordChangeSchema,
  insertRoleRequestSchema,
  insertLeadSchema,
  leads,
  rentalOpportunityRequests,
  leadJourneys,
  appointments,
  offers,
  properties,
  users,
  presentationCards,
  propertyRecommendations,
  autoSuggestions,
  createPropertyChangeRequestSchema,
  updateOwnerSettingsSchema,
  insertRentalApplicationSchema,
  insertRentalContractSchema,
  createInspectionReportSchema,
  updateInspectionReportSchema,
  insertNotificationSchema,
  insertChatConversationSchema,
  insertChatMessageSchema,
  insertChatParticipantSchema,
  chatConversations,
  updateUserProfileSchema,
  updateBankInfoSchema,
  uploadSellerDocumentSchema,
  acceptCommissionTermsSchema,
  updateDocumentStatusSchema,
  insertAgreementTemplateSchema,
  insertPropertySubmissionDraftSchema,
  insertPropertyAgreementSchema,
  insertProviderApplicationSchema,
  insertFeedbackSchema,
  insertContractTenantInfoSchema,
  insertContractOwnerInfoSchema,
  insertContractLegalDocumentSchema,
  updateContractLegalDocumentSchema,
  insertContractTermDiscussionSchema,
  insertContractApprovalSchema,
  insertCheckInAppointmentSchema,
  updateCheckInAppointmentSchema,
  insertContractSignedDocumentSchema,
  updateFeedbackSchema,
  insertRentalCommissionConfigSchema,
  insertAccountantAssignmentSchema,
  insertPayoutBatchSchema,
  insertIncomeTransactionSchema,
  insertChangelogSchema,
  insertSlaConfigurationSchema,
  insertLeadScoringRuleSchema,
  insertLeadScoreSchema,
  insertContractChecklistTemplateSchema,
  insertContractChecklistTemplateItemSchema,
  insertContractChecklistItemSchema,
  insertRentalHealthScoreSchema,
  insertLeadResponseMetricSchema,
  insertContractCycleMetricSchema,
  insertWorkflowEventSchema,
  insertSystemAlertSchema,
  insertErrorLogSchema,
  requestPasswordResetSchema,
  resetPasswordSchema,
  suspendUserSchema,
  unsuspendUserSchema,
  createPropertyLimitRequestSchema,
  insertCondominiumUnitSchema,
  insertCondominiumFeeSchema,
  insertCondominiumFeePaymentSchema,
  insertCondominiumIssueSchema,
  insertHoaManagerAssignmentSchema,
  insertHoaAnnouncementSchema,
  insertHoaAnnouncementReadSchema,
  insertOfferTokenSchema,
  offerTokens,
  tenantRentalFormTokens,
  tenantRentalForms,
  ownerRentalFormData,
  insertOwnerRentalFormDataSchema,
  condominiums,
  condominiumUnits,
  colonies,
  insertExternalAgencySchema,
  insertExternalClientSchema,
  updateExternalClientSchema,
  externalClientDocuments,
  externalClientIncidents,
  insertExternalClientDocumentSchema,
  insertExternalClientIncidentSchema,
  updateExternalClientIncidentSchema,
  externalClients,
  externalLeads,
  externalLeadEmailSources,
  externalLeadEmailImportLogs,
  externalLeadShowings,
  externalLeadReminders,
  externalLeadActivities,
  insertExternalLeadSchema,
  updateExternalLeadSchema,
  insertExternalLeadRegistrationTokenSchema,
  insertExternalLeadActivitySchema,
  insertExternalLeadShowingSchema,
  updateExternalLeadShowingSchema,
  insertExternalLeadReminderSchema,
  updateExternalLeadReminderSchema,
  insertExternalClientActivitySchema,
  insertExternalClientPropertyHistorySchema,
  createLeadRegistrationLinkSchema,
  insertExternalPropertySchema,
  insertExternalRentalContractSchema,
  insertExternalRentalTenantSchema,
  insertExternalRentalNoteSchema,
  updateExternalRentalNoteSchema,
  createRentalContractWithServicesSchema,
  updateExternalRentalContractSchema,
  insertExternalPaymentScheduleSchema,
  insertExternalPaymentSchema,
  markPaymentAsPaidSchema,
  insertExternalMaintenanceTicketSchema,
  insertExternalMaintenanceUpdateSchema,
  insertExternalMaintenancePhotoSchema,
  insertExternalCondominiumSchema,
  updateExternalCondominiumSchema,
  createCondominiumWithUnitsSchema,
  addUnitsToCondominiumSchema,
  insertExternalUnitSchema,
  updateExternalUnitSchema,
  insertExternalUnitOwnerSchema,
  updateExternalUnitOwnerSchema,
  insertExternalUnitAccessControlSchema,
  updateExternalUnitAccessControlSchema,
  insertExternalOwnerChargeSchema,
  insertExternalOwnerNotificationSchema,
  insertExternalWorkerAssignmentSchema,
  insertExternalFinancialTransactionSchema,
  insertExternalQuotationSchema,
  updateExternalQuotationSchema,
  updateExternalFinancialTransactionSchema,
  insertExternalTermsAndConditionsSchema,
  insertExternalRolePermissionSchema,
  insertExternalUserPermissionSchema,
  EXTERNAL_PERMISSION_SECTIONS,
  EXTERNAL_PERMISSION_ACTIONS,
  DEFAULT_ROLE_PERMISSIONS,
  PERMISSION_SECTION_LABELS,
  PERMISSION_ACTION_LABELS,
  updateExternalTermsAndConditionsSchema,
  externalAgencies,
  externalCondominiums,
  externalUnits,
  externalUnitAccessControls,
  externalUnitOwners,
  externalOwnerCharges,
  externalOwnerNotifications,
  externalNotifications,
  insertExternalNotificationSchema,
  externalWorkerAssignments,
  externalRentalContracts,
  externalRentalTenants,
  externalPayments,
  externalPaymentSchedules,
  externalMaintenanceTickets,
  externalFinancialTransactions,
  externalAgencyZones,
  insertExternalAgencyZoneSchema,
  externalAgencyPropertyTypes,
  externalAgencyUnitCharacteristics,
  insertExternalAgencyUnitCharacteristicSchema,
  externalAgencyAmenities,
  insertExternalAgencyAmenitySchema,
  insertExternalAgencyPropertyTypeSchema,
  externalPublicationRequests,
  insertExternalPublicationRequestSchema,
  externalAppointments,
  externalAppointmentUnits,
  insertExternalAppointmentSchema,
  insertExternalAppointmentUnitSchema,
  sellerMessageTemplates,
  sellerFollowUpTasks,
  externalLeadPropertyOffers,
  insertSellerMessageTemplateSchema,
  insertSellerFollowUpTaskSchema,
  insertExternalLeadPropertyOfferSchema,
  sellerGoals,
  insertSellerGoalSchema,
  externalPropertyActivityHistory,
  insertExternalPropertyActivityHistorySchema,
  externalAgencyChatMessages,
  externalAgencyChatAttachments,
  externalAgencyActivityLogs,
  externalAgencyPointConfig,
  externalAgencySellerPoints,
  externalAgencyRewards,
  externalAgencyRewardRedemptions,
  insertExternalAgencyChatMessageSchema,
  insertExternalAgencyChatAttachmentSchema,
  insertExternalAgencyActivityLogSchema,
  insertExternalAgencyPointConfigSchema,
  insertExternalAgencySellerPointsSchema,
  insertExternalAgencyRewardSchema,
  insertExternalAgencyRewardRedemptionSchema,
  featuredProperties,
  insertFeaturedPropertySchema,
} from "@shared/schema";
import { db } from "./db";
import { registerPortalRoutes } from "./portal-routes";
import { logSellerActivity } from "./activityService";
import { eq, and, or, not, inArray, desc, asc, sql, ne, isNull, isNotNull, gte, lte, lt, ilike } from "drizzle-orm";

// Helper function to verify external agency ownership
async function verifyExternalAgencyOwnership(req: any, res: any, agencyId: string): Promise<boolean> {
  try {
    // Get user ID from authentication first
    const userId = req.user?.claims?.sub || req.user?.id;
    
    // Admin and master users can access all agencies
    let userRole = req.user?.role || req.session?.adminUser?.role;
    // Get role from database if not in session
    if (!userRole && userId) {
      const dbUser = await storage.getUser(userId);
      userRole = dbUser?.role;
    }
    if (userRole === "master" || userRole === "admin") {
      return true;
    }

    if (!userId) {
      res.status(401).json({ message: "Unauthorized: User ID not found" });
      return false;
    }

    // Get the user's external agency ID directly from user record
    const user = await storage.getUser(userId);
    if (!user) {
      res.status(401).json({ message: "Unauthorized: User not found" });
      return false;
    }

    if (!user.externalAgencyId) {
      res.status(403).json({ message: "Forbidden: User is not assigned to any agency" });
      return false;
    }

    // Verify the agency matches
    if (user.externalAgencyId !== agencyId) {
      res.status(403).json({ message: "Forbidden: Cannot access resources from another agency" });
      return false;
    }

    return true;
  } catch (error) {
    console.error("Error verifying agency ownership:", error);
    res.status(500).json({ message: "Failed to verify agency ownership" });
    return false;
  }
}

// Helper function to get user's agency ID
async function getUserAgencyId(req: any): Promise<string | null> {
  try {
    // Admin and master users dont have an agency
    const userRole = req.user?.cachedRole || req.user?.role || req.session?.adminUser?.role;
    if (userRole === "master" || userRole === "admin") {
      return null;
    }

    // Try to use cached agencyId from isAuthenticated middleware first
    if (req.user?.cachedAgencyId) {
      return req.user.cachedAgencyId;
    }

    // Check session cache (with TTL validation - 5 min)
    const CACHE_TTL_MS = 5 * 60 * 1000;
    const now = Date.now();
    const cacheValid = req.session?.cachedUser?.externalAgencyId && req.session.cachedUser.cachedAt && (now - req.session.cachedUser.cachedAt) < CACHE_TTL_MS;
    if (cacheValid) {
      return req.session.cachedUser.externalAgencyId;
    }

    // Get user ID from authentication
    const userId = req.user?.claims?.sub || req.user?.id;
    if (!userId) {
      return null;
    }

    // Fallback: Get the users external agency ID from DB (should rarely happen now)
    const user = await storage.getUser(userId);
    return user?.externalAgencyId || null;
  } catch (error) {
    console.error("Error getting user agency ID:", error);
    return null;
  }
}


// Helper function to create audit logs
async function createAuditLog(
  req: Request & { user?: any; session?: any },
  action: "create" | "update" | "delete" | "view" | "approve" | "reject" | "assign",
  entityType: string,
  entityId: string | null,
  details?: string,
  metadata?: { ipAddress?: string; userAgent?: string; [key: string]: any }
) {
  try {
    // Get userId from either admin session or regular auth
    let userId: string | null = null;
    
    if (req.session?.adminUser) {
      // Admin session - use admin user ID
      userId = req.session.adminUser.id;
    } else if (req.user?.claims?.sub) {
      // Regular Replit Auth - use claims sub
      userId = req.user.claims.sub;
    }
    
    if (!userId) return;

    // Use provided metadata or fallback to request data
    const ipAddress = metadata?.ipAddress || req.ip || req.socket.remoteAddress || null;
    const userAgent = metadata?.userAgent || req.get("user-agent") || null;

    // Only create audit log if userId exists in users table
    // For admin users, we skip audit logging since they're in admin_users table
    if (req.session?.adminUser) {
      // Skip audit logging for admin sessions as admin IDs don't exist in users table
      return;
    }
    
    // Combine details with additional metadata if provided
    let enrichedDetails = details;
    if (metadata && Object.keys(metadata).length > 0) {
      const extraData = Object.entries(metadata)
        .filter(([key]) => key !== 'ipAddress' && key !== 'userAgent')
        .map(([key, value]) => `${key}: ${value}`)
        .join(', ');
      if (extraData) {
        enrichedDetails = `${details || ''} ${extraData ? `[${extraData}]` : ''}`.trim();
      }
    }
    
    await storage.createAuditLog({
      userId,
      action,
      entityType,
      entityId,
      details: enrichedDetails,
      ipAddress,
      userAgent,
    });
  } catch (error) {
    console.error("Error creating audit log:", error);
  }
}

// Helper function to check if user has full admin privileges (admin and master only)
function hasFullAdminPrivileges(userRole: string): boolean {
  return ["master", "admin"].includes(userRole);
}

// Helper function to check if user has any admin privileges (including admin_jr)
function hasAdminPrivileges(userRole: string): boolean {
  return ["master", "admin", "admin_jr"].includes(userRole);
}

// Helper function to normalize lead data for presentation card creation
function normalizePresentationCardFromLead(lead: any, agencyId: string, createdBy: string) {
  // Normalize hasPets - handle both string and boolean values
  let hasPetsValue = false;
  let petsDescriptionValue: string | undefined = undefined;
  
  if (typeof lead.hasPets === 'boolean') {
    hasPetsValue = lead.hasPets;
  } else if (typeof lead.hasPets === 'string') {
    const trimmed = lead.hasPets.trim();
    if (trimmed !== '' && trimmed.toLowerCase() !== 'no' && trimmed.toLowerCase() !== 'false') {
      hasPetsValue = true;
      petsDescriptionValue = trimmed;
    }
  }

  // Helper to normalize optional string fields
  const normalizeString = (val: any): string | undefined => {
    if (val === null || val === undefined) return undefined;
    const str = String(val).trim();
    return str !== '' ? str : undefined;
  };

  return {
    agencyId,
    leadId: lead.id,
    title: (`${lead.firstName || ''} ${lead.lastName || ''} - Registro inicial`).trim() || 'Registro inicial',
    propertyType: normalizeString(lead.desiredUnitType),
    modality: "rent" as const,
    minBudget: normalizeString(lead.estimatedRentCost),
    maxBudget: normalizeString(lead.estimatedRentCost),
    budgetText: normalizeString(lead.estimatedRentCostText),
    bedrooms: normalizeString(lead.bedrooms),
    bedroomsText: normalizeString(lead.bedroomsText),
    preferredZone: normalizeString(lead.desiredNeighborhood),
    moveInDate: lead.checkInDate || undefined,
    moveInDateText: normalizeString(lead.checkInDateText),
    contractDuration: normalizeString(lead.contractDuration),
    hasPets: hasPetsValue,
    petsDescription: petsDescriptionValue,
    specificProperty: normalizeString(lead.desiredProperty),
    isDefault: true,
    status: "active" as const,
    createdBy,
  };
}

// Middleware to require full admin privileges
async function requireFullAdmin(req: any, res: any, next: any) {
  const user = req.user;
  if (!user) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  
  try {
    let userRole: string | null = null;
    
    // Check if it's an admin user (from admin_users table)
    if (user.adminAuth && req.session?.adminUser) {
      userRole = req.session.adminUser.role;
    } else {
      // Regular user from users table - ensure they exist
      const dbUser = await ensureUserExists(req);
      if (!dbUser) {
        return res.status(403).json({ 
          message: "Forbidden: This action requires full administrator privileges" 
        });
      }
      userRole = dbUser.role;
    }
    
    if (!userRole || !hasFullAdminPrivileges(userRole)) {
      return res.status(403).json({ 
        message: "Forbidden: This action requires full administrator privileges" 
      });
    }
    
    next();
  } catch (error) {
    console.error("Error checking admin privileges:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}

// Middleware to require accountant or admin role
function requireAccountantOrAdmin(req: any, res: any, next: any) {
  const user = req.user;
  if (!user) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  
  const userId = user.claims.sub;
  storage.getUser(userId).then(dbUser => {
    if (!dbUser || !["accountant", "master", "admin", "admin_jr"].includes(dbUser.role)) {
      return res.status(403).json({ 
        message: "Forbidden: This action requires accountant or administrator privileges" 
      });
    }
    req.dbUser = dbUser; // Attach user to request for later use
    next();
  }).catch(error => {
    console.error("Error checking accountant privileges:", error);
    res.status(500).json({ message: "Internal server error" });
  });
}

// WebSocket clients organized by conversation ID
const wsClients = new Map<string, Set<WebSocket>>();

// Import job tracking for progress reporting
interface ImportJob {
  id: string;
  section: string;
  status: 'processing' | 'completed' | 'failed';
  total: number;
  processed: number;
  imported: number;
  skipped: number;
  errors: string[];
  startedAt: Date;
  finishedAt?: Date;
  message?: string;
}
const importJobs = new Map<string, ImportJob>();

// Clean up old jobs after 1 hour
setInterval(() => {
  const oneHourAgo = Date.now() - 60 * 60 * 1000;
  for (const [jobId, job] of importJobs.entries()) {
    if (job.finishedAt && job.finishedAt.getTime() < oneHourAgo) {
      importJobs.delete(jobId);
    }
  }
}, 5 * 60 * 1000);

// Helper function to ensure user exists in database
async function ensureUserExists(req: any): Promise<any> {
  const userId = req.user.claims.sub;
  const claims = req.user.claims;
  
  let user = await storage.getUser(userId);
  
  // If user doesn't exist but we have valid claims, create them automatically
  if (!user && claims) {
    user = await storage.upsertUser({
      id: claims.sub,
      email: claims.email,
      firstName: claims.first_name || '',
      lastName: claims.last_name || '',
      profileImageUrl: claims.profile_image_url,
    });
  }
  
  return user;
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Health check endpoint - must be first for deployment health checks
  app.get("/api/health", (req, res) => {
    res.status(200).json({ 
      status: "ok",
      timestamp: new Date().toISOString(),
      service: "HomesApp API"
    });
  });

  // Initialize session store (warm up database connection)
  await initializeSession();
  
  // Auth middleware
  await setupAuth(app);
  
  // Setup Google OAuth direct login
  setupGoogleAuth(app);
  
  // Initialize business hours with default values if not exists
  await storage.initializeBusinessHours();

  // Auth routes
  app.get("/api/auth/user", isAuthenticated, async (req: any, res) => {
    try {
      // Check if admin session exists
      if (req.session && req.session.adminUser) {
        return res.json(req.session.adminUser);
      }

      // Otherwise, get regular user from Replit Auth
      const userId = req.user.claims.sub;
      const claims = req.user.claims;
      
      // Try to get user from database
      let user = await storage.getUser(userId);
      
      // If user doesn't exist but we have valid claims, create them automatically
      if (!user && claims) {
        user = await storage.upsertUser({
          id: claims.sub,
          email: claims.email,
          firstName: claims.first_name || '',
          lastName: claims.last_name || '',
          profileImageUrl: claims.profile_image_url,
        });
      }
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Test endpoint to update authenticated user's role (development only)
  if (process.env.NODE_ENV === "development") {
    app.post("/api/auth/test/set-role", isAuthenticated, async (req: any, res) => {
      try {
        const userId = req.user.claims.sub;
        const { role } = req.body;
        
        if (!role) {
          return res.status(400).json({ message: "Role is required" });
        }
        
        const validRoles = ["cliente", "owner", "seller", "concierge", "admin", "admin_jr", "master"];
        if (!validRoles.includes(role)) {
          return res.status(400).json({ message: "Invalid role" });
        }
        
        // Update user role
        const updatedUser = await storage.updateUserRole(userId, role);
        res.json(updatedUser);
      } catch (error) {
        console.error("Error updating user role:", error);
        res.status(500).json({ message: "Failed to update role" });
      }
    });
    
    // Test endpoint to bootstrap admin session without OIDC (development only, for e2e testing)
    app.post("/api/test-auth/admin-session", async (req: any, res) => {
      try {
        // Get or create a test admin user
        let testAdmin = await storage.getAdminByUsername("test-admin");
        
        if (!testAdmin) {
          // Create a test admin user
          testAdmin = await storage.createAdmin({
            username: "test-admin",
            email: "test-admin@test.com",
            firstName: "Test",
            lastName: "Admin",
            passwordHash: await bcrypt.hash("test-password", 10),
            role: "admin",
            isActive: true,
          });
        }
        
        // Upsert to users table for foreign key constraints
        await storage.upsertUser({
          id: testAdmin.id,
          email: testAdmin.email,
          firstName: testAdmin.firstName,
          lastName: testAdmin.lastName,
          role: testAdmin.role,
        });
        
        // Set admin session
        req.session.adminUser = {
          id: testAdmin.id,
          username: testAdmin.username,
          email: testAdmin.email,
          firstName: testAdmin.firstName,
          lastName: testAdmin.lastName,
          role: testAdmin.role,
        };
        
        // Save session explicitly
        await new Promise<void>((resolve, reject) => {
          req.session.save((err: any) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        res.json({ 
          success: true, 
          message: "Test admin session created",
          admin: {
            username: testAdmin.username,
            role: testAdmin.role,
          }
        });
      } catch (error) {
        console.error("Error creating test admin session:", error);
        res.status(500).json({ message: "Failed to create test session" });
      }
    });
  }

  // Admin login route (local authentication)
  app.post("/api/auth/admin/login", authLimiter, async (req: any, res) => {
    try {
      const validationResult = adminLoginSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid request data",
          errors: validationResult.error.errors 
        });
      }
      
      const { username, password } = validationResult.data;
      
      // Find admin by username
      const admin = await storage.getAdminByUsername(username);
      if (!admin) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      // Check if admin is active
      if (!admin.isActive) {
        return res.status(403).json({ message: "Account is inactive" });
      }
      
      // Verify password
      const isValidPassword = await bcrypt.compare(password, admin.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      // Ensure admin also exists in users table (for foreign key constraints)
      try {
        await storage.upsertUser({
          id: admin.id,
          email: admin.email,
          firstName: admin.firstName,
          lastName: admin.lastName,
          role: admin.role,
          profileImageUrl: admin.profileImageUrl,
        });
      } catch (upsertError) {
        console.error("Error upserting admin to users table:", upsertError);
        // Don't fail login if this fails, but log it
      }
      
      // Create session with admin info
      req.session.adminUser = {
        id: admin.id,
        username: admin.username,
        email: admin.email,
        firstName: admin.firstName,
        lastName: admin.lastName,
        role: admin.role,
      };
      
      // Save session explicitly
      await new Promise<void>((resolve, reject) => {
        req.session.save((err: any) => {
          if (err) reject(err);
          else resolve();
        });
      });
      
      // Return admin info (without password hash)
      const { passwordHash, ...adminWithoutPassword } = admin;
      res.json(adminWithoutPassword);
    } catch (error) {
      console.error("Error during admin login:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // Admin logout route
  app.post("/api/auth/admin/logout", async (req, res) => {
    try {
      req.session.destroy((err: any) => {
        if (err) {
          console.error("Error destroying session:", err);
          return res.status(500).json({ message: "Logout failed" });
        }
        res.json({ message: "Logged out successfully" });
      });
    } catch (error) {
      console.error("Error during admin logout:", error);
      res.status(500).json({ message: "Logout failed" });
    }
  });

  // Configure multer for property photo uploads
  const photoStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'attached_assets/stock_images/');
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = crypto.randomBytes(4).toString('hex');
      const ext = path.extname(file.originalname);
      const baseName = path.basename(file.originalname, ext).toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20);
      cb(null, `${baseName}_${uniqueSuffix}${ext}`);
    }
  });

  const upload = multer({
    storage: photoStorage,
    limits: {
      fileSize: 20 * 1024 * 1024 // 20MB limit (images are compressed on frontend)
    },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Tipo de archivo no permitido. Solo JPG, PNG y WEBP.'));
      }
    }
  });

  // Configure multer for payment proof uploads
  const paymentProofStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'attached_assets/payment_proofs/');
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = crypto.randomBytes(4).toString('hex');
      const ext = path.extname(file.originalname);
      const baseName = path.basename(file.originalname, ext).toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20);
      cb(null, `payment_${uniqueSuffix}${ext}`);
    }
  });

  const uploadPaymentProof = multer({
    storage: paymentProofStorage,
    limits: {
      fileSize: 5 * 1024 * 1024 // 5MB limit for payment proofs
    },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Tipo de archivo no permitido. Solo JPG, PNG y WEBP.'));
      }
    }
  });

  // Configure multer for maintenance photo uploads
  const maintenancePhotoStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'attached_assets/maintenance_photos/');
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = crypto.randomBytes(4).toString('hex');
      const ext = path.extname(file.originalname);
      const baseName = path.basename(file.originalname, ext).toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20);
      cb(null, `maint_${uniqueSuffix}${ext}`);
    }
  });

  const uploadMaintenancePhoto = multer({
    storage: maintenancePhotoStorage,
    limits: {
      fileSize: 10 * 1024 * 1024 // 10MB limit for maintenance photos
    },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Tipo de archivo no permitido. Solo JPG, PNG y WEBP.'));
      }
    }
  });

  // Upload property photo endpoint
  app.post("/api/upload/property-photo", isAuthenticated, requireRole(["owner", "admin", "master"]), upload.single('photo'), async (req: any, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No se proporcionó ninguna foto" });
      }

      const photoUrl = `/attached_assets/stock_images/${req.file.filename}`;
      res.json({ url: photoUrl });
    } catch (error: any) {
      console.error("Error uploading photo:", error);
      res.status(500).json({ message: error.message || "Error al subir la foto" });
    }
  });

  // Upload maintenance photo endpoint
  app.post("/api/upload/maintenance-photo", isAuthenticated, requireRole(["master", "admin", "external_agency_admin", "external_agency_maintenance"]), uploadMaintenancePhoto.single('photo'), async (req: any, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No se proporcionó ninguna foto" });
      }

      const photoUrl = `/attached_assets/maintenance_photos/${req.file.filename}`;
      res.json({ url: photoUrl });
    } catch (error: any) {
      console.error("Error uploading maintenance photo:", error);
      res.status(500).json({ message: error.message || "Error al subir la foto de mantenimiento" });
    }
  });

  // Get current admin user
  app.get("/api/auth/admin/user", async (req: any, res) => {
    try {
      if (!req.session.adminUser) {
        // Return 200 with null instead of 401 to avoid unnecessary error logs
        return res.status(200).json(null);
      }
      
      // Fetch full admin data from database to include onboarding fields
      const adminId = req.session.adminUser.id;
      const admin = await storage.getAdminById(adminId);
      
      if (!admin) {
        return res.status(200).json(null);
      }
      
      const { passwordHash, ...adminWithoutPassword } = admin;
      res.json(adminWithoutPassword);
    } catch (error) {
      console.error("Error fetching admin user:", error);
      res.status(500).json({ message: "Failed to fetch admin user" });
    }
  });

  // Update admin profile
  app.patch("/api/auth/admin/profile", async (req: any, res) => {
    try {
      if (!req.session.adminUser) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const validationResult = updateAdminProfileSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validationResult.error.errors,
        });
      }

      const adminId = req.session.adminUser.id;
      const updatedAdmin = await storage.updateAdminProfile(adminId, validationResult.data);

      // Update session with new data
      req.session.adminUser = {
        ...req.session.adminUser,
        firstName: updatedAdmin.firstName,
        lastName: updatedAdmin.lastName,
        email: updatedAdmin.email,
        profileImageUrl: updatedAdmin.profileImageUrl,
      };

      await new Promise<void>((resolve, reject) => {
        req.session.save((err: any) => {
          if (err) reject(err);
          else resolve();
        });
      });

      const { passwordHash, ...adminWithoutPassword } = updatedAdmin;
      res.json(adminWithoutPassword);
    } catch (error) {
      console.error("Error updating admin profile:", error);
      res.status(500).json({ message: "Failed to update admin profile" });
    }
  });

  // Update admin password
  app.patch("/api/auth/admin/password", async (req: any, res) => {
    try {
      if (!req.session.adminUser) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const validationResult = updateAdminPasswordSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validationResult.error.errors,
        });
      }

      const { currentPassword, newPassword } = validationResult.data;
      const adminId = req.session.adminUser.id;

      // Get current admin to verify password
      const admin = await storage.getAdminByUsername(req.session.adminUser.username);
      if (!admin) {
        return res.status(404).json({ message: "Admin not found" });
      }

      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, admin.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ message: "Current password is incorrect" });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);
      
      // Update password
      await storage.updateAdminPassword(adminId, newPasswordHash);

      res.json({ message: "Password updated successfully" });
    } catch (error) {
      console.error("Error updating admin password:", error);
      res.status(500).json({ message: "Failed to update admin password" });
    }
  });

  // Local user login route (for users who registered with email/password)
  app.post("/api/auth/login", authLimiter, async (req: any, res) => {
    try {
      const validationResult = userLoginSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validationResult.error.errors,
        });
      }

      const { email, password } = validationResult.data;

      // Find user by email
      const user = await storage.getUserByEmail(email);
      if (!user || !user.passwordHash) {
        return res.status(401).json({ message: "Credenciales inválidas" });
      }

      // Check if user is approved
      if (user.status !== "approved") {
        return res.status(403).json({ message: "Tu cuenta está pendiente de aprobación" });
      }

      // Check if email is verified
      if (!user.emailVerified) {
        return res.status(403).json({ message: "Por favor verifica tu email primero" });
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ message: "Credenciales inválidas" });
      }

      // Create session
      req.session.userId = user.id;

      // Save session explicitly
      await new Promise<void>((resolve, reject) => {
        req.session.save((err: any) => {
          if (err) reject(err);
          else resolve();
        });
      });

      // Return user info (without password hash)
      const { passwordHash, ...userWithoutPassword } = user;
      res.json({
        ...userWithoutPassword,
        requirePasswordChange: user.requirePasswordChange || false,
      });
    } catch (error) {
      console.error("Error during login:", error);
      res.status(500).json({ message: "Error al iniciar sesión" });
    }
  });

  // Local user logout route
  app.post("/api/auth/local/logout", async (req: any, res) => {
    try {
      if (req.session.userId) {
        req.session.destroy((err: any) => {
          if (err) {
            console.error("Error destroying session:", err);
            return res.status(500).json({ message: "Error al cerrar sesión" });
          }
          res.json({ message: "Sesión cerrada exitosamente" });
        });
      } else {
        res.status(400).json({ message: "No hay sesión activa" });
      }
    } catch (error) {
      console.error("Error during logout:", error);
      res.status(500).json({ message: "Error al cerrar sesión" });
    }
  });

  // Admin: Set temporary password for a user
  app.post("/api/admin/users/:userId/set-password", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      // Check if user exists
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Generate temporary password
      const temporaryPassword = generateTemporaryPassword();
      
      // Hash the password
      const passwordHash = await bcrypt.hash(temporaryPassword, 10);
      
      // Update user password and set requirePasswordChange flag
      await db
        .update(users)
        .set({
          passwordHash,
          requirePasswordChange: true,
          emailVerified: true,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
      
      await createAuditLog(req, "update", "user", userId, `Admin set temporary password for user ${user.email}`);
      
      // Return the temporary password (only shown once)
      res.json({ 
        message: "Temporary password set successfully",
        temporaryPassword,
        email: user.email 
      });
    } catch (error) {
      console.error("Error setting temporary password:", error);
      res.status(500).json({ message: "Failed to set temporary password" });
    }
  });

  // Admin: Reset password for a user (generate new temporary password)
  app.post("/api/admin/users/:userId/reset-password", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      // Check if user exists
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Generate new temporary password
      const temporaryPassword = generateTemporaryPassword();
      
      // Hash the password
      const passwordHash = await bcrypt.hash(temporaryPassword, 10);
      
      // Update user password and set requirePasswordChange flag
      await db
        .update(users)
        .set({
          passwordHash,
          requirePasswordChange: true,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
      
      await createAuditLog(req, "update", "user", userId, `Admin reset password for user ${user.email}`);
      
      // Return the new temporary password (only shown once)
      res.json({ 
        message: "Password reset successfully",
        temporaryPassword,
        email: user.email 
      });
    } catch (error) {
      console.error("Error resetting password:", error);
      res.status(500).json({ message: "Failed to reset password" });
    }
  });

  // User: Change own password
  app.post("/api/auth/change-password", isAuthenticated, async (req: any, res) => {
    try {
      const validationResult = changePasswordSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validationResult.error.errors,
        });
      }

      const { currentPassword, newPassword } = validationResult.data;
      const userId = req.user.claims.sub;
      
      // Get user
      const user = await storage.getUser(userId);
      if (!user || !user.passwordHash) {
        return res.status(400).json({ message: "User not found or no password set" });
      }

      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ message: "Current password is incorrect" });
      }

      // Validate new password strength
      const strengthValidation = validatePasswordStrength(newPassword);
      if (!strengthValidation.valid) {
        return res.status(400).json({ message: strengthValidation.message });
      }

      // Hash new password
      const passwordHash = await bcrypt.hash(newPassword, 10);
      
      // Update password and clear requirePasswordChange flag using direct DB update
      await db
        .update(users)
        .set({
          passwordHash,
          requirePasswordChange: false,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
      
      await createAuditLog(req, "update", "user", userId, `User changed their password`);
      
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  // User: Force password change (first time login)
  app.post("/api/auth/force-password-change", isAuthenticated, async (req: any, res) => {
    try {
      const validationResult = forcePasswordChangeSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validationResult.error.errors,
        });
      }

      const { newPassword } = validationResult.data;
      const userId = req.user.claims.sub;
      
      // Get user
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Check if user actually needs to change password
      if (!user.requirePasswordChange) {
        return res.status(400).json({ message: "Password change not required" });
      }

      // Validate new password strength
      const strengthValidation = validatePasswordStrength(newPassword);
      if (!strengthValidation.valid) {
        return res.status(400).json({ message: strengthValidation.message });
      }

      // Hash new password
      const passwordHash = await bcrypt.hash(newPassword, 10);
      
      // Update password and clear requirePasswordChange flag using direct DB update
      await db
        .update(users)
        .set({
          passwordHash,
          requirePasswordChange: false,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
      
      await createAuditLog(req, "update", "user", userId, `User completed forced password change`);
      
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error in force password change:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  // User management routes
  app.get("/api/users", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  app.get("/api/users/pending", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const users = await storage.getUsersByStatus("pending");
      res.json(users);
    } catch (error) {
      console.error("Error fetching pending users:", error);
      res.status(500).json({ message: "Failed to fetch pending users" });
    }
  });

  app.post("/api/users/:id/approve", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.updateUserStatus(id, "approved");
      
      // Log the approval action
      await createAuditLog(
        req,
        "approve",
        "user",
        id,
        `Usuario aprobado: ${user.firstName} ${user.lastName} (${user.email})`
      );
      
      res.json(user);
    } catch (error) {
      console.error("Error approving user:", error);
      res.status(500).json({ message: "Failed to approve user" });
    }
  });

  app.post("/api/users/:id/reject", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.updateUserStatus(id, "rejected");
      
      // Log the rejection action
      await createAuditLog(
        req,
        "reject",
        "user",
        id,
        `Usuario rechazado: ${user.firstName} ${user.lastName} (${user.email})`
      );
      
      res.json(user);
    } catch (error) {
      console.error("Error rejecting user:", error);
      res.status(500).json({ message: "Failed to reject user" });
    }
  });

  app.post("/api/users/approve-all", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const count = await storage.approveAllPendingUsers();
      
      // Log the bulk approval action
      await createAuditLog(
        req,
        "approve",
        "user",
        null,
        `Aprobados ${count} usuarios pendientes en masa`
      );
      
      res.json({ count });
    } catch (error) {
      console.error("Error approving all users:", error);
      res.status(500).json({ message: "Failed to approve all users" });
    }
  });

  app.patch("/api/users/:id/role", isAuthenticated, requireRole(["master"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Validate role with Zod
      const roleSchema = z.object({
        role: z.enum(["cliente", "owner", "seller", "admin", "admin_jr", "master", "accountant"], {
          errorMap: () => ({ message: "Rol inválido" })
        })
      });
      
      const validationResult = roleSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos",
          errors: validationResult.error.errors 
        });
      }
      
      const { role } = validationResult.data;
      const user = await storage.updateUserRole(id, role);
      
      // Log the role update action
      await createAuditLog(
        req,
        "update",
        "user",
        id,
        `Rol actualizado a: ${role} para ${user.firstName} ${user.lastName}`
      );
      
      res.json(user);
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ message: "Failed to update user role" });
    }
  });

  // Allow users to switch between owner and cliente roles (Airbnb-style)
  app.patch("/api/users/switch-role", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Validate role with Zod
      const switchRoleSchema = z.object({
        role: z.string().min(1, "El rol es requerido")
      });
      
      const validationResult = switchRoleSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos",
          errors: validationResult.error.errors 
        });
      }
      
      const { role } = validationResult.data;

      // SECURITY: Define admin-level roles that can NEVER be switched to via this endpoint
      // These roles require explicit assignment by master users only
      const ADMIN_ROLES = ["master", "admin", "admin_jr"];
      
      // SECURITY: Define roles that are safe for user-initiated switching
      const SWITCHABLE_ROLES = ["cliente", "owner", "seller", "accountant", "management", "concierge", "provider", "abogado", "contador", "agente_servicios_especiales"];

      // CRITICAL SECURITY CHECK: Prevent privilege escalation to admin roles
      if (ADMIN_ROLES.includes(role)) {
        return res.status(403).json({ 
          message: "Los roles administrativos solo pueden ser asignados por un administrador master" 
        });
      }

      // Validate role is in switchable set
      if (!SWITCHABLE_ROLES.includes(role)) {
        return res.status(400).json({ 
          message: "Rol inválido" 
        });
      }

      // Get current user data to check their approved roles
      const currentUser = await storage.getUser(userId);
      if (!currentUser) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }

      // User can always switch between owner and cliente (base roles)
      const isBaseRole = role === "owner" || role === "cliente";
      
      // User can switch to their approved additional role (only if it's switchable)
      const isApprovedAdditionalRole = 
        role === currentUser.additionalRole && 
        SWITCHABLE_ROLES.includes(role);

      if (!isBaseRole && !isApprovedAdditionalRole) {
        return res.status(400).json({ 
          message: "Solo puedes cambiar a roles que tienes aprobados" 
        });
      }

      const user = await storage.updateUserRole(userId, role);
      
      // Log the role switch action
      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        `Usuario cambió su rol a: ${role}`
      );
      
      res.json(user);
    } catch (error) {
      console.error("Error switching user role:", error);
      res.status(500).json({ message: "Failed to switch user role" });
    }
  });

  app.get("/api/users/role/:role", isAuthenticated, async (req, res) => {
    try {
      const { role } = req.params;
      const users = await storage.getUsersByRole(role);
      res.json(users);
    } catch (error) {
      console.error("Error fetching users by role:", error);
      res.status(500).json({ message: "Failed to fetch users by role" });
    }
  });

  // Profile management endpoints
  app.patch("/api/profile", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const validated = updateUserProfileSchema.parse(req.body);
      
      const user = await storage.updateUserProfile(userId, validated);
      
      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        "Perfil actualizado"
      );
      
      res.json(user);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  app.patch("/api/profile/bank-info", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const validated = updateBankInfoSchema.parse(req.body);
      
      // Encrypt sensitive bank data before storing
      const encryptedData: any = { ...validated };
      if (encryptedData.bankAccountNumber) {
        encryptedData.bankAccountNumber = encrypt(encryptedData.bankAccountNumber);
      }
      if (encryptedData.bankClabe) {
        encryptedData.bankClabe = encrypt(encryptedData.bankClabe);
      }
      
      const user = await storage.updateBankInfo(userId, encryptedData);
      
      // Decrypt for response
      const userResponse: any = { ...user };
      if (userResponse.bankAccountNumber) {
        try {
          userResponse.bankAccountNumber = decrypt(userResponse.bankAccountNumber);
        } catch (e) {
          console.error('Failed to decrypt bankAccountNumber for user:', userId);
          userResponse.bankAccountNumber = '';
        }
      }
      if (userResponse.bankClabe) {
        try {
          userResponse.bankClabe = decrypt(userResponse.bankClabe);
        } catch (e) {
          console.error('Failed to decrypt bankClabe for user:', userId);
          userResponse.bankClabe = '';
        }
      }
      
      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        "Información bancaria actualizada",
        {
          ipAddress: req.ip,
          userAgent: req.headers['user-agent']
        }
      );
      
      res.json(userResponse);
    } catch (error) {
      console.error("Error updating bank info:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Datos inválidos", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to update bank information" });
    }
  });

  app.delete("/api/profile", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      await createAuditLog(
        req,
        "delete",
        "user",
        userId,
        "Usuario eliminó su cuenta"
      );
      
      await storage.deleteUser(userId);
      
      req.logout((err: any) => {
        if (err) {
          console.error("Error logging out:", err);
        }
        res.json({ message: "Account deleted successfully" });
      });
    } catch (error) {
      console.error("Error deleting account:", error);
      res.status(500).json({ message: "Failed to delete account" });
    }
  });

  app.patch("/api/user/mark-welcome-seen", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { dontShowAgain } = req.body;
      
      const updates: any = {
        lastWelcomeShown: new Date(),
      };
      
      if (dontShowAgain === true) {
        updates.hasSeenWelcome = true;
      }
      
      await db
        .update(users)
        .set(updates)
        .where(eq(users.id, userId));
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking welcome as seen:", error);
      res.status(500).json({ message: "Failed to mark welcome as seen" });
    }
  });

  app.patch("/api/user/complete-onboarding", isAuthenticated, async (req: any, res) => {
    try {
      // Support both regular auth (req.user) and admin auth (req.session.adminUser)
      const isAdmin = !!req.session?.adminUser;
      let userId;
      
      if (isAdmin) {
        userId = req.session.adminUser.id;
        // Update admin_users table
        await db
          .update(adminUsers)
          .set({ 
            onboardingCompleted: true,
            onboardingSteps: { completed: true, completedAt: new Date().toISOString() }
          })
          .where(eq(adminUsers.id, userId));
      } else if (req.user?.claims?.sub) {
        userId = req.user.claims.sub;
        // Update users table
        await db
          .update(users)
          .set({ 
            onboardingCompleted: true,
            onboardingSteps: { completed: true, completedAt: new Date().toISOString() }
          })
          .where(eq(users.id, userId));
      } else {
        return res.status(401).json({ message: "Not authenticated" });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error completing onboarding:", error);
      res.status(500).json({ message: "Failed to complete onboarding" });
    }
  });

  app.patch("/api/user/skip-onboarding", isAuthenticated, async (req: any, res) => {
    try {
      // Support both regular auth (req.user) and admin auth (req.session.adminUser)
      const isAdmin = !!req.session?.adminUser;
      let userId;
      
      if (isAdmin) {
        userId = req.session.adminUser.id;
        // Update admin_users table
        await db
          .update(adminUsers)
          .set({ 
            onboardingCompleted: true,
            onboardingSteps: { skipped: true, skippedAt: new Date().toISOString() }
          })
          .where(eq(adminUsers.id, userId));
      } else if (req.user?.claims?.sub) {
        userId = req.user.claims.sub;
        // Update users table
        await db
          .update(users)
          .set({ 
            onboardingCompleted: true,
            onboardingSteps: { skipped: true, skippedAt: new Date().toISOString() }
          })
          .where(eq(users.id, userId));
      } else {
        return res.status(401).json({ message: "Not authenticated" });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error skipping onboarding:", error);
      res.status(500).json({ message: "Failed to skip onboarding" });
    }
  });

  // Password reset routes
  app.post("/api/password-reset/request", async (req, res) => {
    try {
      const validated = requestPasswordResetSchema.parse(req.body);
      const { email } = validated;
      
      const user = await storage.getUserByEmail(email);
      
      if (user && user.passwordHash) {
        const token = crypto.randomBytes(32).toString('hex');
        const expiresAt = new Date(Date.now() + 60 * 60 * 1000);
        
        await storage.createPasswordResetToken({
          userId: user.id,
          token,
          expiresAt,
          used: false,
        });
        
        // Determine the base URL for the reset link
        // In production: use REPLIT_DOMAINS (first domain) or WEB_REPL_DEPLOYMENT_URL
        // In development: use REPLIT_DEV_DOMAIN or localhost
        let baseUrl = 'http://localhost:5000';
        
        if (process.env.REPLIT_DOMAINS) {
          // Production deployment - use the first domain from REPLIT_DOMAINS
          const domains = process.env.REPLIT_DOMAINS.split(',');
          baseUrl = `https://${domains[0]}`;
        } else if (process.env.REPLIT_DEV_DOMAIN) {
          // Development environment
          baseUrl = `https://${process.env.REPLIT_DEV_DOMAIN}`;
        }
        
        const resetLink = `${baseUrl}/reset-password?token=${token}`;
        console.log(`Generated password reset link for ${user.email} using baseUrl: ${baseUrl}`);
        
        try {
          const { sendPasswordResetEmail } = await import("./gmail");
          await sendPasswordResetEmail(
            user.email,
            user.firstName || 'Usuario',
            resetLink
          );
          console.log(`Password reset email sent successfully to ${user.email}`);
        } catch (emailError) {
          console.error('Error sending password reset email:', emailError);
          console.error('Email error details:', {
            message: emailError instanceof Error ? emailError.message : 'Unknown error',
            stack: emailError instanceof Error ? emailError.stack : undefined
          });
          // Still return success to prevent user enumeration
        }
      }
      
      res.json({ message: "Si el email existe, recibirás un enlace de restablecimiento" });
    } catch (error) {
      console.error("Error requesting password reset:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Email inválido", errors: error.errors });
      }
      res.status(500).json({ message: "Error al procesar solicitud" });
    }
  });
  
  app.post("/api/password-reset/reset", async (req, res) => {
    try {
      const validated = resetPasswordSchema.parse(req.body);
      const { token, newPassword } = validated;
      
      const resetToken = await storage.getPasswordResetToken(token);
      
      if (!resetToken) {
        return res.status(400).json({ message: "Token inválido o expirado" });
      }
      
      if (resetToken.used) {
        return res.status(400).json({ message: "Este token ya fue usado" });
      }
      
      if (new Date() > resetToken.expiresAt) {
        return res.status(400).json({ message: "Este token ha expirado" });
      }
      
      const passwordHash = await bcrypt.hash(newPassword, 10);
      await storage.updateUserPassword(resetToken.userId, passwordHash);
      await storage.markPasswordResetTokenAsUsed(token);
      
      res.json({ message: "Contraseña actualizada exitosamente" });
    } catch (error) {
      console.error("Error resetting password:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Datos inválidos", errors: error.errors });
      }
      res.status(500).json({ message: "Error al restablecer contraseña" });
    }
  });
  
  // Admin send password reset link to user
  app.post("/api/admin/users/:userId/send-reset-link", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      
      if (!user.passwordHash) {
        return res.status(400).json({ message: "Esta cuenta usa autenticación de terceros. No se puede enviar enlace de restablecimiento." });
      }
      
      const token = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000);
      
      await storage.createPasswordResetToken({
        userId: user.id,
        token,
        expiresAt,
        used: false,
      });
      
      const baseUrl = process.env.REPLIT_DEV_DOMAIN 
        ? `https://${process.env.REPLIT_DEV_DOMAIN}` 
        : `http://localhost:5000`;
      const resetLink = `${baseUrl}/reset-password?token=${token}`;
      
      const { sendPasswordResetEmail } = await import("./gmail");
      await sendPasswordResetEmail(
        user.email,
        user.firstName || 'Usuario',
        resetLink
      );
      
      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        `Admin envió enlace de restablecimiento de contraseña a ${user.email}`
      );
      
      res.json({ message: "Enlace de restablecimiento enviado exitosamente" });
    } catch (error) {
      console.error("Error sending reset link:", error);
      res.status(500).json({ message: "Error al enviar enlace de restablecimiento" });
    }
  });
  
  // Admin delete user completely
  app.delete("/api/admin/users/:userId", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      // Prevent self-deletion
      if (req.user && req.user.id === userId) {
        return res.status(400).json({ message: "No puedes eliminar tu propia cuenta" });
      }
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      
      // Check for related data that would prevent deletion
      const hasRelatedData = await db.select({ count: sql<number>`count(*)::int` })
        .from(chatConversations)
        .where(eq(chatConversations.createdById, userId))
        .then(rows => rows[0]?.count > 0);
      
      if (hasRelatedData) {
        return res.status(400).json({ 
          message: "No se puede eliminar este usuario porque tiene conversaciones de chat asociadas. Considera suspender la cuenta en su lugar." 
        });
      }
      
      await createAuditLog(
        req,
        "delete",
        "user",
        userId,
        `Admin eliminó usuario: ${user.firstName} ${user.lastName} (${user.email})`
      );
      
      await storage.deleteUser(userId);
      
      res.json({ message: "Usuario eliminado exitosamente" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Error al eliminar usuario" });
    }
  });

  // Get user's presentation cards
  app.get("/api/users/:userId/presentation-cards", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      const cards = await db
        .select()
        .from(presentationCards)
        .where(eq(presentationCards.clientId, userId))
        .orderBy(desc(presentationCards.createdAt));
      
      res.json(cards);
    } catch (error) {
      console.error("Error fetching presentation cards:", error);
      res.status(500).json({ message: "Error al obtener tarjetas de presentación" });
    }
  });

  // Get user's properties
  app.get("/api/users/:userId/properties", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      const userProperties = await db
        .select()
        .from(properties)
        .where(eq(properties.ownerId, userId))
        .orderBy(desc(properties.createdAt));
      
      res.json(userProperties);
    } catch (error) {
      console.error("Error fetching user properties:", error);
      res.status(500).json({ message: "Error al obtener propiedades del usuario" });
    }
  });

  // Suspend user account
  app.post("/api/admin/users/:userId/suspend", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const validated = suspendUserSchema.parse({ ...req.body, userId });
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      
      const adminId = req.user?.claims?.sub || req.user?.id;
      if (userId === adminId) {
        return res.status(400).json({ message: "No puedes suspender tu propia cuenta" });
      }
      
      const suspendedAt = new Date();
      const suspensionEndDate = validated.suspensionType === "temporary" && validated.endDate
        ? new Date(validated.endDate)
        : null;
      
      await db
        .update(users)
        .set({
          isSuspended: true,
          suspensionType: validated.suspensionType,
          suspensionReason: validated.reason,
          suspensionEndDate,
          suspendedAt,
          suspendedById: adminId,
        })
        .where(eq(users.id, userId));
      
      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        `Admin suspendió cuenta de ${user.firstName} ${user.lastName}: ${validated.reason} (${validated.suspensionType})`
      );
      
      res.json({ message: "Usuario suspendido exitosamente" });
    } catch (error) {
      console.error("Error suspending user:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Datos inválidos", errors: error.errors });
      }
      res.status(500).json({ message: "Error al suspender usuario" });
    }
  });

  // Unsuspend user account
  app.post("/api/admin/users/:userId/unsuspend", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      
      await db
        .update(users)
        .set({
          isSuspended: false,
          suspensionType: null,
          suspensionReason: null,
          suspensionEndDate: null,
          suspendedAt: null,
          suspendedById: null,
        })
        .where(eq(users.id, userId));
      
      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        `Admin reactivó cuenta de ${user.firstName} ${user.lastName}`
      );
      
      res.json({ message: "Usuario reactivado exitosamente" });
    } catch (error) {
      console.error("Error unsuspending user:", error);
      res.status(500).json({ message: "Error al reactivar usuario" });
    }
  });

  // Update user role (admin can assign roles directly)
  app.patch("/api/admin/users/:userId/role", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { role, additionalRole } = req.body;

      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }

      // Validate role
      const validRoles = ["cliente", "seller", "owner", "concierge", "provider", "admin", "admin_jr", "master", "management"];
      if (role && !validRoles.includes(role)) {
        return res.status(400).json({ message: "Rol inválido" });
      }
      if (additionalRole && !validRoles.includes(additionalRole)) {
        return res.status(400).json({ message: "Rol adicional inválido" });
      }

      const updateData: any = {};
      if (role) updateData.role = role;
      if (additionalRole !== undefined) updateData.additionalRole = additionalRole;

      await db
        .update(users)
        .set(updateData)
        .where(eq(users.id, userId));

      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        `Admin actualizó rol de ${user.firstName} ${user.lastName} a: ${role}${additionalRole ? ` (adicional: ${additionalRole})` : ""}`
      );

      res.json({ message: "Rol actualizado exitosamente" });
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ message: "Error al actualizar rol" });
    }
  });

  // Seller document and commission terms routes
  app.patch("/api/seller/document", isAuthenticated, requireRole(["seller"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validated = uploadSellerDocumentSchema.parse(req.body);
      
      await db
        .update(users)
        .set({
          documentType: validated.documentType,
          documentUrl: validated.documentUrl,
          documentApprovalStatus: "pending",
          documentReviewedAt: null,
          documentRejectionReason: null,
        })
        .where(eq(users.id, userId));
      
      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        `Vendedor subió documento tipo ${validated.documentType}`
      );
      
      res.json({ message: "Documento subido exitosamente, pendiente de revisión" });
    } catch (error) {
      console.error("Error uploading seller document:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Datos inválidos", errors: error.errors });
      }
      res.status(500).json({ message: "Error al subir documento" });
    }
  });

  app.patch("/api/seller/commission-terms", isAuthenticated, requireRole(["seller"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validated = acceptCommissionTermsSchema.parse(req.body);
      
      if (validated.accepted) {
        await db
          .update(users)
          .set({
            commissionTermsAccepted: true,
            commissionTermsAcceptedAt: new Date(),
          })
          .where(eq(users.id, userId));
        
        await createAuditLog(
          req,
          "update",
          "user",
          userId,
          "Vendedor aceptó términos y condiciones de comisiones"
        );
        
        res.json({ message: "Términos y condiciones aceptados" });
      } else {
        res.status(400).json({ message: "Debes aceptar los términos y condiciones" });
      }
    } catch (error) {
      console.error("Error accepting commission terms:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Datos inválidos", errors: error.errors });
      }
      res.status(500).json({ message: "Error al aceptar términos" });
    }
  });

  app.patch("/api/admin/seller/:id/document-status", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const validated = updateDocumentStatusSchema.parse(req.body);
      
      const [seller] = await db.select().from(users).where(eq(users.id, id));
      if (!seller) {
        return res.status(404).json({ message: "Vendedor no encontrado" });
      }
      
      if (seller.role !== "seller") {
        return res.status(400).json({ message: "El usuario no es un vendedor" });
      }
      
      const updates: any = {
        documentApprovalStatus: validated.status,
        documentReviewedAt: new Date(),
      };
      
      if (validated.status === "rejected" && validated.rejectionReason) {
        updates.documentRejectionReason = validated.rejectionReason;
      } else if (validated.status === "approved") {
        updates.documentRejectionReason = null;
      }
      
      await db
        .update(users)
        .set(updates)
        .where(eq(users.id, id));
      
      await createAuditLog(
        req,
        "update",
        "user",
        id,
        `Admin actualizó estado de documento a: ${validated.status}`
      );
      
      res.json({ message: "Estado de documento actualizado" });
    } catch (error) {
      console.error("Error updating document status:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Datos inválidos", errors: error.errors });
      }
      res.status(500).json({ message: "Error al actualizar estado de documento" });
    }
  });

  // User registration routes
  app.post("/api/register", registrationLimiter, async (req, res) => {
    try {
      const validationResult = userRegistrationSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid registration data",
          errors: validationResult.error.errors,
        });
      }

      const { email, password, firstName, lastName, phone, preferredLanguage } = validationResult.data;

      // Additional security validations
      if (!isValidEmail(email)) {
        return res.status(400).json({ message: "Formato de email inválido" });
      }

      if (!isStrongPassword(password)) {
        return res.status(400).json({ 
          message: "La contraseña debe tener al menos 8 caracteres, una mayúscula, una minúscula y un número" 
        });
      }

      if (containsSQLKeywords(firstName) || containsSQLKeywords(lastName)) {
        return res.status(400).json({ message: "Nombre contiene caracteres no permitidos" });
      }

      if (phone && !isValidPhoneNumber(phone)) {
        return res.status(400).json({ message: "Formato de teléfono inválido" });
      }

      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(409).json({ message: "El email ya está registrado" });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);

      // Create user with "cliente" role by default
      const user = await storage.createUserWithPassword({
        email,
        passwordHash,
        firstName,
        lastName,
        phone,
        preferredLanguage: preferredLanguage || "es",
        role: "cliente",
        status: "approved",
        emailVerified: false,
      });

      // Generate 6-digit verification code using crypto for security
      const crypto = await import("crypto");
      const verificationCode = crypto.randomInt(100000, 1000000).toString();
      const expiresAt = new Date();
      expiresAt.setMinutes(expiresAt.getMinutes() + 15); // 15 minutes expiration

      await storage.createEmailVerificationToken({
        userId: user.id,
        code: verificationCode,
        expiresAt,
      });

      // Send verification email
      let emailSent = false;
      let emailError: string | null = null;
      
      try {
        console.log(`Attempting to send verification email to ${user.email} with code ${verificationCode}`);
        const emailResult = await sendVerificationEmail(user.email, verificationCode);
        console.log("Verification email sent successfully:", JSON.stringify(emailResult, null, 2));
        emailSent = true;
      } catch (error) {
        console.error("Error sending verification email:", error);
        emailError = error instanceof Error ? error.message : String(error);
        console.error("Email error details:", emailError);
        // Don't fail registration if email fails
      }

      res.status(201).json({
        message: emailSent 
          ? "Cuenta creada exitosamente. Por favor verifica tu email." 
          : "Cuenta creada exitosamente. El correo de verificación será enviado pronto.",
        userId: user.id,
        email: user.email,
        emailSent,
        ...(emailError && { emailError })
      });
    } catch (error) {
      console.error("Error during registration:", error);
      res.status(500).json({ message: "Error al crear la cuenta" });
    }
  });

  app.post("/api/verify-email", emailVerificationLimiter, async (req: any, res) => {
    try {
      const { email, code } = req.body;

      if (!email || !code) {
        return res.status(400).json({ message: "Email y código son requeridos" });
      }

      // Validate code format (6 digits)
      if (!/^\d{6}$/.test(code)) {
        return res.status(400).json({ message: "Código inválido" });
      }

      // Get user by email
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(400).json({ message: "Código de verificación inválido" });
      }

      // Check if already verified
      if (user.emailVerified) {
        return res.status(400).json({ message: "El email ya está verificado" });
      }

      // Get verification token for this specific user
      const verificationToken = await storage.getEmailVerificationTokenByUserId(user.id);
      
      // Verify code matches and belongs to this user
      if (!verificationToken || verificationToken.code !== code) {
        return res.status(400).json({ message: "Código de verificación inválido" });
      }

      // Check if code is expired
      if (new Date() > verificationToken.expiresAt) {
        await storage.deleteEmailVerificationToken(verificationToken.id);
        return res.status(400).json({ message: "El código ha expirado" });
      }

      // Verify user email
      await storage.verifyUserEmail(user.id);

      // Delete used token
      await storage.deleteEmailVerificationToken(verificationToken.id);

      // Auto-login: Create session for the user
      req.session.userId = user.id;

      // Save session explicitly
      await new Promise<void>((resolve, reject) => {
        req.session.save((err: any) => {
          if (err) reject(err);
          else resolve();
        });
      });

      res.json({ 
        message: "Email verificado exitosamente",
        autoLogin: true,
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
        }
      });
    } catch (error) {
      console.error("Error verifying email:", error);
      res.status(500).json({ message: "Error al verificar el código" });
    }
  });

  // Resend verification code
  app.post("/api/resend-verification", emailVerificationLimiter, async (req, res) => {
    try {
      const { email } = req.body;

      if (!email) {
        return res.status(400).json({ message: "Email es requerido" });
      }

      // Get user
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }

      // Check if already verified
      if (user.emailVerified) {
        return res.status(400).json({ message: "El email ya está verificado" });
      }

      // Delete old verification code if exists
      await storage.deleteEmailVerificationTokenByUserId(user.id);

      // Generate new 6-digit verification code using crypto for security
      const crypto = await import("crypto");
      const verificationCode = crypto.randomInt(100000, 1000000).toString();
      const expiresAt = new Date();
      expiresAt.setMinutes(expiresAt.getMinutes() + 15);

      await storage.createEmailVerificationToken({
        userId: user.id,
        code: verificationCode,
        expiresAt,
      });

      // Send verification email
      try {
        await sendVerificationEmail(user.email, verificationCode);
        res.json({ message: "Código de verificación enviado" });
      } catch (emailError) {
        console.error("Error sending verification email:", emailError);
        res.status(500).json({ message: "Error al enviar el código" });
      }
    } catch (error) {
      console.error("Error resending verification code:", error);
      res.status(500).json({ message: "Error al reenviar el código" });
    }
  });

  app.get("/api/verify-email", emailVerificationLimiter, async (req: any, res) => {
    try {
      const { token } = req.query;

      if (!token || typeof token !== "string") {
        return res.status(400).json({ message: "Token inválido" });
      }

      // Legacy support - redirect to verification page
      res.redirect(`/verify-email?token=${token}`);
    } catch (error) {
      console.error("Error with legacy verification:", error);
      res.status(500).json({ message: "Error al verificar" });
    }
  });

  app.get("/api/verify-email-old", emailVerificationLimiter, async (req: any, res) => {
    try {
      const { token } = req.query;

      if (!token || typeof token !== "string") {
        return res.status(400).json({ message: "Token inválido" });
      }

      // This is for old-style verification - not used anymore but kept for backward compatibility
      res.json({ 
        message: "Este método de verificación ya no está disponible. Por favor solicita un nuevo código.",
        autoLogin: false,
        requiresApproval: true
      });
    } catch (error) {
      console.error("Error during email verification:", error);
      res.status(500).json({ message: "Error al verificar el email" });
    }
  });

  // Admin: Create user with custom role
  const adminCreateUserSchema = z.object({
    email: z.string().email("Email inválido"),
    password: z.string().min(6, "La contraseña debe tener al menos 6 caracteres"),
    firstName: z.string().min(1, "El nombre es requerido"),
    lastName: z.string().min(1, "El apellido es requerido"),
    role: z.enum([
      "master",
      "admin",
      "admin_jr",
      "cliente",
      "seller",
      "owner",
      "management",
      "concierge",
      "provider",
      "abogado",
      "contador",
      "agente_servicios_especiales",
    ]),
    phone: z.string().optional(),
    sendEmail: z.boolean().optional(),
  });

  app.post("/api/admin/users", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const validationResult = adminCreateUserSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Datos de usuario inválidos",
          errors: validationResult.error.errors,
        });
      }

      const { email, password, firstName, lastName, role, phone, sendEmail } = validationResult.data;

      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(409).json({ message: "El email ya está registrado" });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);

      // Create user with specified role
      const user = await storage.createUserWithPassword({
        email,
        passwordHash,
        firstName,
        lastName,
        phone: phone || null,
        role,
        status: "approved",
        emailVerified: true, // Auto-verify admin-created accounts
        preferredLanguage: "es",
      });

      // Optionally send welcome email
      if (sendEmail) {
        try {
          // Generate verification token (even though auto-verified, for welcome email)
          const verificationToken = crypto.randomBytes(32).toString("hex");
          const expiresAt = new Date();
          expiresAt.setHours(expiresAt.getHours() + 24);

          await storage.createEmailVerificationToken({
            userId: user.id,
            token: verificationToken,
            expiresAt,
          });

          await sendVerificationEmail(user.email, verificationToken);
        } catch (emailError) {
          console.error("Error sending welcome email:", emailError);
          // Don't fail user creation if email fails
        }
      }

      // Create audit log
      await createAuditLog(
        req,
        "create",
        "user",
        user.id,
        `Admin created user with role ${role}`
      );

      res.status(201).json({
        message: "Usuario creado exitosamente",
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
        },
      });
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({ message: "Error al crear el usuario" });
    }
  });

  // Role request routes
  app.post("/api/role-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const validationResult = insertRoleRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Datos inválidos",
          errors: validationResult.error.errors,
        });
      }

      // Check if user already has an active request
      const existingRequest = await storage.getUserActiveRoleRequest(userId);
      if (existingRequest) {
        return res.status(409).json({
          message: "Ya tienes una solicitud pendiente",
        });
      }

      const roleRequest = await storage.createRoleRequest({
        ...validationResult.data,
        userId,
      });

      // Log the role request creation
      await createAuditLog(
        req,
        "create",
        "role_request",
        roleRequest.id,
        `Solicitud de rol: ${roleRequest.requestedRole}`
      );

      res.status(201).json(roleRequest);
    } catch (error) {
      console.error("Error creating role request:", error);
      res.status(500).json({ message: "Error al crear solicitud de rol" });
    }
  });

  app.get("/api/role-requests", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const { status, userId } = req.query;
      const filters: any = {};
      if (status) filters.status = status;
      if (userId) filters.userId = userId;

      const requests = await storage.getRoleRequests(filters);
      
      // Enrich requests with user data
      const requestsWithUsers = await Promise.all(
        requests.map(async (request) => {
          const user = await storage.getUser(request.userId);
          return {
            ...request,
            user: user ? {
              id: user.id,
              firstName: user.firstName,
              lastName: user.lastName,
              email: user.email,
              profilePictureUrl: user.profileImageUrl,
            } : undefined,
          };
        })
      );
      
      res.json(requestsWithUsers);
    } catch (error) {
      console.error("Error fetching role requests:", error);
      res.status(500).json({ message: "Error al obtener solicitudes" });
    }
  });

  app.get("/api/role-requests/my-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const requests = await storage.getRoleRequests({ userId });
      res.json(requests);
    } catch (error) {
      console.error("Error fetching user role requests:", error);
      res.status(500).json({ message: "Error al obtener tus solicitudes" });
    }
  });

  app.patch("/api/role-requests/:id/approve", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reviewNotes } = req.body;
      const reviewerId = req.user?.claims?.sub || req.session?.adminUser?.id;

      const roleRequest = await storage.getRoleRequest(id);
      if (!roleRequest) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      // Check if request is still pending
      if (roleRequest.status !== "pending") {
        return res.status(400).json({
          message: `Esta solicitud ya fue ${roleRequest.status === "approved" ? "aprobada" : "rechazada"}`,
        });
      }

      // Validate requested role is allowed
      const allowedRoles = ["owner", "seller", "management", "concierge", "provider", "hoa_manager"];
      if (!allowedRoles.includes(roleRequest.requestedRole)) {
        return res.status(400).json({ message: "Rol solicitado no es válido" });
      }

      // Check if user already has this role
      const user = await storage.getUser(roleRequest.userId);
      if (user?.additionalRole === roleRequest.requestedRole) {
        return res.status(400).json({ message: "El usuario ya tiene este rol" });
      }

      // Update role request status
      // Only pass reviewerId if it's an OIDC user (not admin or local auth)
      // Admin users are in admin_users table, not users table
      const reviewerIdToSave = (!req.user?.adminAuth && !req.user?.localAuth) ? req.user?.claims?.sub : null;
      const updatedRequest = await storage.updateRoleRequestStatus(
        id,
        "approved",
        reviewerIdToSave,
        reviewNotes
      );

      // Update user's additional role
      await storage.updateUserAdditionalRole(roleRequest.userId, roleRequest.requestedRole);

      // Log the approval
      await createAuditLog(
        req,
        "approve",
        "role_request",
        id,
        `Aprobada solicitud de rol: ${roleRequest.requestedRole}`
      );

      res.json(updatedRequest);
    } catch (error) {
      console.error("Error approving role request:", error);
      res.status(500).json({ message: "Error al aprobar solicitud" });
    }
  });

  app.patch("/api/role-requests/:id/reject", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reviewNotes } = req.body;
      const reviewerId = req.user?.claims?.sub || req.session?.adminUser?.id;

      const roleRequest = await storage.getRoleRequest(id);
      if (!roleRequest) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      // Check if request is still pending
      if (roleRequest.status !== "pending") {
        return res.status(400).json({
          message: `Esta solicitud ya fue ${roleRequest.status === "approved" ? "aprobada" : "rechazada"}`,
        });
      }

      // Update role request status
      // Only pass reviewerId if it's an OIDC user (not admin or local auth)
      // Admin users are in admin_users table, not users table
      const reviewerIdToSave = (!req.user?.adminAuth && !req.user?.localAuth) ? req.user?.claims?.sub : null;
      const updatedRequest = await storage.updateRoleRequestStatus(
        id,
        "rejected",
        reviewerIdToSave,
        reviewNotes
      );

      // Log the rejection
      await createAuditLog(
        req,
        "reject",
        "role_request",
        id,
        `Rechazada solicitud de rol: ${roleRequest.requestedRole}`
      );

      res.json(updatedRequest);
    } catch (error) {
      console.error("Error rejecting role request:", error);
      res.status(500).json({ message: "Error al rechazar solicitud" });
    }
  });

  // Property Limit Request routes
  app.post("/api/property-limit-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const user = await storage.getUser(userId);
      if (!user || user.role !== "owner") {
        return res.status(403).json({ message: "Solo los propietarios pueden solicitar aumento de límite" });
      }

      // Validate request data
      const validationResult = createPropertyLimitRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Datos inválidos",
          errors: validationResult.error.errors,
        });
      }

      // Check if user already has a pending request
      const existingRequest = await storage.getUserActivePropertyLimitRequest(userId);
      if (existingRequest) {
        return res.status(409).json({
          message: "Ya tienes una solicitud pendiente",
        });
      }

      const currentLimit = user.propertyLimit || 3;
      const requestedLimit = validationResult.data.requestedLimit;

      if (requestedLimit <= currentLimit) {
        return res.status(400).json({
          message: `El límite solicitado debe ser mayor que tu límite actual (${currentLimit})`,
        });
      }

      const request = await storage.createPropertyLimitRequest({
        ownerId: userId,
        currentLimit,
        requestedLimit,
        reason: validationResult.data.reason,
      });

      // Log the request creation
      await createAuditLog(
        req,
        "create",
        "property_limit_request",
        request.id,
        `Solicitud de aumento de límite de propiedades: ${currentLimit} → ${requestedLimit}`
      );

      res.status(201).json(request);
    } catch (error) {
      console.error("Error creating property limit request:", error);
      res.status(500).json({ message: "Error al crear solicitud de aumento de límite" });
    }
  });

  app.get("/api/property-limit-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const user = await storage.getUser(userId);
      const isAdmin = user && ["master", "admin", "admin_jr"].includes(user.role);

      const { status, ownerId } = req.query;
      const filters: any = {};
      
      if (isAdmin) {
        // Admins can see all requests or filter by ownerId/status
        if (status) filters.status = status;
        if (ownerId) filters.ownerId = ownerId;
      } else {
        // Regular users can only see their own requests
        filters.ownerId = userId;
        if (status) filters.status = status;
      }

      const requests = await storage.getPropertyLimitRequests(filters);
      
      // Enrich requests with user data
      const requestsWithUsers = await Promise.all(
        requests.map(async (request) => {
          const owner = await storage.getUser(request.ownerId);
          return {
            ...request,
            owner: owner ? {
              id: owner.id,
              firstName: owner.firstName,
              lastName: owner.lastName,
              email: owner.email,
              profileImageUrl: owner.profileImageUrl,
            } : undefined,
          };
        })
      );
      
      res.json(requestsWithUsers);
    } catch (error) {
      console.error("Error fetching property limit requests:", error);
      res.status(500).json({ message: "Error al obtener solicitudes" });
    }
  });

  app.patch("/api/property-limit-requests/:id/approve", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reviewNotes } = req.body;
      const reviewerId = req.user?.claims?.sub || req.session?.adminUser?.id;

      const request = await storage.getPropertyLimitRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      if (request.status !== "pending") {
        return res.status(400).json({
          message: `Esta solicitud ya fue ${request.status === "approved" ? "aprobada" : "rechazada"}`,
        });
      }

      // Update property limit request status
      const reviewerIdToSave = (!req.user?.adminAuth && !req.user?.localAuth) ? req.user?.claims?.sub : null;
      const updatedRequest = await storage.updatePropertyLimitRequestStatus(
        id,
        "approved",
        reviewerIdToSave,
        reviewNotes
      );

      // Update user's property limit
      await db
        .update(users)
        .set({ propertyLimit: request.requestedLimit })
        .where(eq(users.id, request.ownerId));

      // Log the approval
      await createAuditLog(
        req,
        "approve",
        "property_limit_request",
        id,
        `Aprobada solicitud de aumento de límite: ${request.currentLimit} → ${request.requestedLimit}`
      );

      res.json(updatedRequest);
    } catch (error) {
      console.error("Error approving property limit request:", error);
      res.status(500).json({ message: "Error al aprobar solicitud" });
    }
  });

  app.patch("/api/property-limit-requests/:id/reject", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reviewNotes } = req.body;
      const reviewerId = req.user?.claims?.sub || req.session?.adminUser?.id;

      const request = await storage.getPropertyLimitRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      if (request.status !== "pending") {
        return res.status(400).json({
          message: `Esta solicitud ya fue ${request.status === "approved" ? "aprobada" : "rechazada"}`,
        });
      }

      // Update property limit request status
      const reviewerIdToSave = (!req.user?.adminAuth && !req.user?.localAuth) ? req.user?.claims?.sub : null;
      const updatedRequest = await storage.updatePropertyLimitRequestStatus(
        id,
        "rejected",
        reviewerIdToSave,
        reviewNotes
      );

      // Log the rejection
      await createAuditLog(
        req,
        "reject",
        "property_limit_request",
        id,
        `Rechazada solicitud de aumento de límite: ${request.currentLimit} → ${request.requestedLimit}`
      );

      res.json(updatedRequest);
    } catch (error) {
      console.error("Error rejecting property limit request:", error);
      res.status(500).json({ message: "Error al rechazar solicitud" });
    }
  });

  // Colony routes
  app.get("/api/colonies", async (req, res) => {
    try {
      const { active, approvalStatus } = req.query;
      const filters: any = {};
      if (active !== undefined) filters.active = active === "true";
      if (approvalStatus) filters.approvalStatus = approvalStatus;
      
      const colonies = await storage.getColonies(filters);
      res.json(colonies);
    } catch (error) {
      console.error("Error fetching colonies:", error);
      res.status(500).json({ message: "Failed to fetch colonies" });
    }
  });

  app.get("/api/colonies/active", async (req, res) => {
    try {
      const colonies = await storage.getActiveColonies();
      res.json(colonies);
    } catch (error) {
      console.error("Error fetching active colonies:", error);
      res.status(500).json({ message: "Failed to fetch active colonies" });
    }
  });

  app.get("/api/colonies/approved", async (req, res) => {
    try {
      // Try to get from cache first
      const cacheKey = CacheKeys.coloniesApproved();
      const cached = await cache.get(cacheKey);
      
      if (cached) {
        return res.json(cached);
      }

      // Cache miss - fetch from database
      const colonies = await storage.getApprovedColonies();
      
      // Store in cache with 24h TTL
      await cache.set(cacheKey, colonies, CacheTTL.STATIC);
      
      res.json(colonies);
    } catch (error) {
      console.error("Error fetching approved colonies:", error);
      res.status(500).json({ message: "Failed to fetch approved colonies" });
    }
  });

  app.post("/api/colonies", isAuthenticated, async (req: any, res) => {
    try {
      let userId: string;
      let isAdmin: boolean;
      let userRole: string | null = null;

      // Check if it's an admin session (from admin_users table)
      if (req.session?.adminUser) {
        userId = req.session.adminUser.id;
        userRole = req.session.adminUser.role;
        isAdmin = ["master", "admin"].includes(userRole);
      } else {
        // Regular user from Replit Auth
        const user = await ensureUserExists(req);
        if (!user) {
          return res.status(401).json({ message: "Usuario no encontrado" });
        }
        userId = user.id;
        userRole = user.role;
        isAdmin = user.role === "master" || user.role === "admin" || user.additionalRole === "admin";
      }
      
      // Admins can create directly, owners need to suggest with limits
      if (!isAdmin && userRole !== "owner") {
        return res.status(403).json({ message: "Solo los propietarios y administradores pueden crear colonias" });
      }

      // Check suggestion limits only for non-admin owners
      if (!isAdmin && userRole === "owner") {
        const todaySuggestions = await storage.getUserSuggestionsCount(userId, 'today');
        const totalSuggestions = await storage.getUserSuggestionsCount(userId, 'total');

        if (todaySuggestions >= 3) {
          return res.status(429).json({ 
            message: "Has alcanzado el límite de 3 sugerencias por día" 
          });
        }

        if (totalSuggestions >= 15) {
          return res.status(429).json({ 
            message: "Has alcanzado el límite de 15 sugerencias totales" 
          });
        }
      }
      
      // Validate request body with Zod
      const colonySchema = z.object({
        name: z.string().min(1, "El nombre de la colonia es requerido"),
      });
      
      const validationResult = colonySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const { name } = validationResult.data;

      // Generate slug from name
      const slug = name.toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Remove accents
        .replace(/[^a-z0-9]+/g, "-") // Replace non-alphanumeric with hyphens
        .replace(/^-+|-+$/g, ""); // Remove leading/trailing hyphens

      // Admins create directly as approved, owners create as pending
      const approvalStatus = isAdmin ? "approved" : "pending_review";

      // Create colony
      const colony = await storage.createColony({
        name,
        slug,
        active: true,
        approvalStatus,
        requestedBy: userId,
      });

      await createAuditLog(
        req,
        "create",
        "colony",
        colony.id,
        isAdmin ? `Colonia creada: ${name}` : `Colonia solicitada: ${name}`
      );

      // Invalidate cache if admin created (auto-approved)
      if (isAdmin) {
        await cache.invalidate(CacheKeys.coloniesApproved());
      }

      res.json(colony);
    } catch (error) {
      console.error("Error creating colony:", error);
      res.status(500).json({ message: "Failed to create colony" });
    }
  });

  app.post("/api/colonies/ensure", isAuthenticated, async (req: any, res) => {
    try {
      let userId: string;
      let isAdmin: boolean;
      let userRole: string | null = null;

      // Check if it's an admin session
      if (req.session?.adminUser) {
        userId = req.session.adminUser.id;
        userRole = req.session.adminUser.role;
        isAdmin = ["master", "admin"].includes(userRole);
      } else {
        const user = await ensureUserExists(req);
        if (!user) {
          return res.status(401).json({ message: "Usuario no encontrado" });
        }
        userId = user.id;
        userRole = user.role;
        isAdmin = user.role === "master" || user.role === "admin" || user.additionalRole === "admin";
      }

      const { name } = req.body;
      if (!name || name.trim() === "") {
        return res.status(400).json({ message: "El nombre de la colonia es requerido" });
      }

      // Search for existing colony by exact name (case-insensitive)
      const existingColony = await db
        .select()
        .from(colonies)
        .where(sql`LOWER(${colonies.name}) = LOWER(${name.trim()})`)
        .limit(1);

      if (existingColony.length > 0) {
        return res.json(existingColony[0]);
      }

      // Generate slug from name
      const slug = name.trim().toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Remove accents
        .replace(/[^a-z0-9]+/g, "-") // Replace non-alphanumeric with hyphens
        .replace(/^-+|-+$/g, ""); // Remove leading/trailing hyphens

      // Create new colony
      const approvalStatus = isAdmin ? "approved" : "pending_review";
      const newColony = await storage.createColony({
        name: name.trim(),
        slug,
        approvalStatus,
        requestedBy: userId,
      });

      await createAuditLog(
        req,
        "create",
        "colony",
        newColony.id,
        isAdmin ? `Colonia creada: ${name}` : `Colonia solicitada: ${name}`
      );

      // Invalidate cache if admin created (auto-approved)
      if (isAdmin) {
        await cache.invalidate(CacheKeys.coloniesApproved());
      }

      res.json(newColony);
    } catch (error) {
      console.error("Error ensuring colony:", error);
      res.status(500).json({ message: "Failed to ensure colony exists" });
    }
  });

  app.post("/api/admin/colonies", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      // Validate request body with Zod
      const colonySchema = z.object({
        name: z.string().min(1, "El nombre de la colonia es requerido"),
        slug: z.string().min(1, "El slug es requerido"),
        active: z.boolean().optional().default(true),
      });
      
      const validationResult = colonySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const colony = await storage.createColony(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "colony",
        colony.id,
        `Colonia creada: ${colony.name}`
      );

      res.json(colony);
    } catch (error) {
      console.error("Error creating colony:", error);
      res.status(500).json({ message: "Failed to create colony" });
    }
  });

  app.patch("/api/admin/colonies/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;

      const colonySchema = z.object({
        name: z.string().optional(),
        slug: z.string().optional(),
        active: z.boolean().optional(),
      });
      
      const validationResult = colonySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const colony = await storage.updateColony(id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "colony",
        colony.id,
        `Colonia actualizada: ${colony.name}`
      );

      // Invalidate cache after updating colony
      await cache.invalidate(CacheKeys.coloniesApproved());

      res.json(colony);
    } catch (error) {
      console.error("Error updating colony:", error);
      res.status(500).json({ message: "Failed to update colony" });
    }
  });

  app.delete("/api/admin/colonies/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;

      await storage.deleteColony(id);

      await createAuditLog(
        req,
        "delete",
        "colony",
        id,
        `Colonia eliminada`
      );

      // Invalidate cache after deleting colony
      await cache.invalidate(CacheKeys.coloniesApproved());

      res.status(204).send();
    } catch (error) {
      console.error("Error deleting colony:", error);
      res.status(500).json({ message: "Failed to delete colony" });
    }
  });

  app.patch("/api/admin/colonies/:id/approve", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { name } = req.body;

      // Validate colony exists
      const existingColony = await storage.getColony(id);
      if (!existingColony) {
        return res.status(404).json({ message: "Colonia no encontrada" });
      }

      // Update name if provided
      if (name && name.trim() !== "" && name !== existingColony.name) {
        await storage.updateColony(id, { name: name.trim() });
      }

      const colony = await storage.updateColonyStatus(id, "approved");
      
      await createAuditLog(
        req,
        "approve",
        "colony",
        id,
        `Colonia aprobada: ${colony.name}`
      );

      // Invalidate cache after approving colony
      await cache.invalidate(CacheKeys.coloniesApproved());

      res.json(colony);
    } catch (error) {
      console.error("Error approving colony:", error);
      res.status(500).json({ message: "Failed to approve colony" });
    }
  });

  app.patch("/api/admin/colonies/:id/reject", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      // Validate colony exists
      const existingColony = await storage.getColony(id);
      if (!existingColony) {
        return res.status(404).json({ message: "Colonia no encontrada" });
      }

      const colony = await storage.updateColonyStatus(id, "rejected");
      
      await createAuditLog(
        req,
        "reject",
        "colony",
        id,
        `Colonia rechazada: ${colony.name}`
      );

      // Invalidate cache after rejecting colony (removes from approved list)
      await cache.invalidate(CacheKeys.coloniesApproved());

      res.json(colony);
    } catch (error) {
      console.error("Error rejecting colony:", error);
      res.status(500).json({ message: "Failed to reject colony" });
    }
  });

  // Condominium routes
  app.get("/api/condominiums", async (req, res) => {
    try {
      const { approvalStatus } = req.query;
      const filters: any = {};
      if (approvalStatus) filters.approvalStatus = approvalStatus;
      
      const condominiums = await storage.getCondominiums(filters);
      res.json(condominiums);
    } catch (error) {
      console.error("Error fetching condominiums:", error);
      res.status(500).json({ message: "Failed to fetch condominiums" });
    }
  });

  app.get("/api/condominiums/approved", async (req, res) => {
    try {
      // Try to get from cache first
      const cacheKey = CacheKeys.condominiumsApproved();
      const cached = await cache.get(cacheKey);
      
      if (cached) {
        return res.json(cached);
      }

      // Cache miss - fetch from database
      const condominiums = await storage.getApprovedCondominiums();
      
      // Store in cache with 24h TTL
      await cache.set(cacheKey, condominiums, CacheTTL.STATIC);
      
      res.json(condominiums);
    } catch (error) {
      console.error("Error fetching approved condominiums:", error);
      res.status(500).json({ message: "Failed to fetch approved condominiums" });
    }
  });

  app.post("/api/condominiums", isAuthenticated, async (req: any, res) => {
    try {
      let userId: string;
      let isAdmin: boolean;
      let userRole: string | null = null;

      // Check if it's an admin session (from admin_users table)
      if (req.session?.adminUser) {
        userId = req.session.adminUser.id;
        userRole = req.session.adminUser.role;
        isAdmin = ["master", "admin"].includes(userRole);
      } else {
        // Regular user from Replit Auth
        const user = await ensureUserExists(req);
        if (!user) {
          return res.status(401).json({ message: "Usuario no encontrado" });
        }
        userId = user.id;
        userRole = user.role;
        isAdmin = user.role === "master" || user.role === "admin" || user.additionalRole === "admin";
      }
      
      // Admins can create directly, owners need to suggest with limits
      if (!isAdmin && userRole !== "owner") {
        return res.status(403).json({ message: "Solo los propietarios y administradores pueden crear condominios" });
      }

      // Check suggestion limits only for non-admin owners
      if (!isAdmin && userRole === "owner") {
        const todaySuggestions = await storage.getUserSuggestionsCount(userId, 'today');
        const totalSuggestions = await storage.getUserSuggestionsCount(userId, 'total');

        if (todaySuggestions >= 3) {
          return res.status(429).json({ 
            message: "Has alcanzado el límite de 3 sugerencias por día" 
          });
        }

        if (totalSuggestions >= 15) {
          return res.status(429).json({ 
            message: "Has alcanzado el límite de 15 sugerencias totales" 
          });
        }
      }
      
      // Validate request body with Zod
      const condominiumSchema = z.object({
        name: z.string().min(1, "El nombre del condominio es requerido"),
        colonyId: z.string().optional(),
        zone: z.string().optional(),
        address: z.string().optional(),
      });
      
      const validationResult = condominiumSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const { name, colonyId, zone, address } = validationResult.data;

      // Admins create directly as approved, owners create as pending
      const approvalStatus = isAdmin ? "approved" : "pending_review";

      // Create condominium
      const condominium = await storage.createCondominium({
        name,
        colonyId,
        zone,
        address,
        approvalStatus,
        requestedBy: userId,
      });

      await createAuditLog(
        req,
        "create",
        "condominium",
        condominium.id,
        isAdmin ? `Condominio creado: ${name}` : `Condominio solicitado: ${name}`
      );

      // Invalidate cache if admin created (auto-approved)
      if (isAdmin) {
        await cache.invalidate(CacheKeys.condominiumsApproved());
      }

      res.json(condominium);
    } catch (error) {
      console.error("Error creating condominium:", error);
      res.status(500).json({ message: "Failed to create condominium" });
    }
  });

  // Simplified endpoint to ensure condominium exists (create if needed)
  app.post("/api/condominiums/ensure", isAuthenticated, async (req: any, res) => {
    try {
      let userId: string;
      let isAdmin: boolean;
      let userRole: string | null = null;

      // Check if it's an admin session
      if (req.session?.adminUser) {
        userId = req.session.adminUser.id;
        userRole = req.session.adminUser.role;
        isAdmin = ["master", "admin"].includes(userRole);
      } else {
        const user = await ensureUserExists(req);
        if (!user) {
          return res.status(401).json({ message: "Usuario no encontrado" });
        }
        userId = user.id;
        userRole = user.role;
        isAdmin = user.role === "master" || user.role === "admin" || user.additionalRole === "admin";
      }

      const { name } = req.body;
      if (!name || name.trim() === "") {
        return res.status(400).json({ message: "El nombre del condominio es requerido" });
      }

      // Search for existing condominium by exact name (case-insensitive)
      const existingCondo = await db
        .select()
        .from(condominiums)
        .where(sql`LOWER(${condominiums.name}) = LOWER(${name.trim()})`)
        .limit(1);

      if (existingCondo.length > 0) {
        return res.json(existingCondo[0]);
      }

      // Create new condominium
      const approvalStatus = isAdmin ? "approved" : "pending_review";
      const newCondo = await storage.createCondominium({
        name: name.trim(),
        approvalStatus,
        requestedBy: userId,
      });

      await createAuditLog(
        req,
        "create",
        "condominium",
        newCondo.id,
        isAdmin ? `Condominio creado: ${name}` : `Condominio solicitado: ${name}`
      );

      // Invalidate cache if admin created (auto-approved)
      if (isAdmin) {
        await cache.invalidate(CacheKeys.condominiumsApproved());
      }

      res.json(newCondo);
    } catch (error) {
      console.error("Error ensuring condominium:", error);
      res.status(500).json({ message: "Failed to ensure condominium exists" });
    }
  });

  app.patch("/api/admin/condominiums/:id/approve", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { name } = req.body;

      // Validate condominium exists
      const existingCondominium = await storage.getCondominium(id);
      if (!existingCondominium) {
        return res.status(404).json({ message: "Condominio no encontrado" });
      }

      // Update name if provided
      if (name && name.trim() !== "" && name !== existingCondominium.name) {
        await storage.updateCondominium(id, { name: name.trim() });
      }

      const condominium = await storage.updateCondominiumStatus(id, "approved");
      
      await createAuditLog(
        req,
        "approve",
        "condominium",
        id,
        `Condominio aprobado: ${condominium.name}`
      );

      // Invalidate cache after approval
      await cache.invalidate(CacheKeys.condominiumsApproved());

      res.json(condominium);
    } catch (error) {
      console.error("Error approving condominium:", error);
      res.status(500).json({ message: "Failed to approve condominium" });
    }
  });

  app.patch("/api/admin/condominiums/:id/reject", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      // Validate condominium exists
      const existingCondominium = await storage.getCondominium(id);
      if (!existingCondominium) {
        return res.status(404).json({ message: "Condominio no encontrado" });
      }

      const condominium = await storage.updateCondominiumStatus(id, "rejected");
      
      await createAuditLog(
        req,
        "reject",
        "condominium",
        id,
        `Condominio rechazado: ${condominium.name}`
      );

      res.json(condominium);
    } catch (error) {
      console.error("Error rejecting condominium:", error);
      res.status(500).json({ message: "Failed to reject condominium" });
    }
  });

  app.patch("/api/admin/condominiums/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      // Validate condominium exists
      const existingCondominium = await storage.getCondominium(id);
      if (!existingCondominium) {
        return res.status(404).json({ message: "Condominio no encontrado" });
      }

      // Validate request body with Zod
      const updateSchema = z.object({
        name: z.string().min(1, "El nombre del condominio es requerido").optional(),
        colonyId: z.string().optional(),
        zone: z.string().optional(),
        address: z.string().optional(),
      });
      
      const validationResult = updateSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const condominium = await storage.updateCondominium(id, validationResult.data);
      
      await createAuditLog(
        req,
        "update",
        "condominium",
        id,
        `Condominio actualizado: ${condominium.name}`
      );

      // Invalidate cache after update
      await cache.invalidate(CacheKeys.condominiumsApproved());

      res.json(condominium);
    } catch (error) {
      console.error("Error updating condominium:", error);
      res.status(500).json({ message: "Failed to update condominium" });
    }
  });

  app.patch("/api/admin/condominiums/:id/toggle-active", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { active } = req.body;

      // Validate condominium exists
      const existingCondominium = await storage.getCondominium(id);
      if (!existingCondominium) {
        return res.status(404).json({ message: "Condominio no encontrado" });
      }

      if (typeof active !== "boolean") {
        return res.status(400).json({ message: "El campo 'active' debe ser booleano" });
      }

      const condominium = await storage.toggleCondominiumActive(id, active);
      
      await createAuditLog(
        req,
        "update",
        "condominium",
        id,
        `Condominio ${active ? 'activado' : 'suspendido'}: ${condominium.name}`
      );

      // Invalidate cache after toggle
      await cache.invalidate(CacheKeys.condominiumsApproved());

      res.json(condominium);
    } catch (error) {
      console.error("Error toggling condominium active status:", error);
      res.status(500).json({ message: "Failed to toggle condominium active status" });
    }
  });

  app.delete("/api/admin/condominiums/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      // Validate condominium exists
      const existingCondominium = await storage.getCondominium(id);
      if (!existingCondominium) {
        return res.status(404).json({ message: "Condominio no encontrado" });
      }

      // Check if condominium has associated properties
      const propertiesCount = await storage.countPropertiesByCondominium(id);
      if (propertiesCount > 0) {
        return res.status(400).json({ 
          message: `No se puede eliminar el condominio porque tiene ${propertiesCount} propiedad${propertiesCount > 1 ? 'es' : ''} asociada${propertiesCount > 1 ? 's' : ''}. Por favor, elimina o reasigna las propiedades primero.` 
        });
      }

      await createAuditLog(
        req,
        "delete",
        "condominium",
        id,
        `Condominio eliminado: ${existingCondominium.name}`
      );

      await storage.deleteCondominium(id);
      
      // Invalidate cache after deletion
      await cache.invalidate(CacheKeys.condominiumsApproved());
      
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting condominium:", error);
      res.status(500).json({ message: "Failed to delete condominium" });
    }
  });

  // Get duplicate condominiums
  app.get("/api/admin/condominiums/duplicates/list", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const duplicates = await db.execute(sql`
        WITH duplicates AS (
          SELECT 
            id,
            name,
            zone,
            address,
            approval_status,
            created_at,
            LOWER(name) as name_lower,
            ROW_NUMBER() OVER (PARTITION BY LOWER(name) ORDER BY created_at ASC) as row_num,
            COUNT(*) OVER (PARTITION BY LOWER(name)) as duplicate_count
          FROM condominiums
        )
        SELECT 
          id,
          name,
          zone,
          address,
          approval_status,
          created_at,
          duplicate_count::int as duplicate_count,
          row_num::int as row_num
        FROM duplicates 
        WHERE duplicate_count > 1
        ORDER BY name_lower, created_at
      `);

      res.json(duplicates.rows);
    } catch (error) {
      console.error("Error fetching duplicate condominiums:", error);
      res.status(500).json({ message: "Error al obtener condominios duplicados" });
    }
  });

  // Delete duplicate condominiums (keeps the oldest one)
  app.delete("/api/admin/condominiums/duplicates/remove", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const result = await db.execute(sql`
        DELETE FROM condominiums
        WHERE id IN (
          SELECT id
          FROM (
            SELECT 
              id,
              ROW_NUMBER() OVER (PARTITION BY LOWER(name) ORDER BY created_at ASC) as row_num
            FROM condominiums
          ) as duplicates
          WHERE row_num > 1
        )
        RETURNING id, name
      `);

      await createAuditLog(
        req,
        "delete",
        "condominium",
        "bulk",
        `Eliminados ${result.rowCount || 0} condominios duplicados`
      );

      res.json({ 
        message: `Se eliminaron ${result.rowCount || 0} condominios duplicados`,
        deletedCount: result.rowCount || 0,
        deletedCondominiums: result.rows
      });
    } catch (error) {
      console.error("Error deleting duplicate condominiums:", error);
      res.status(500).json({ message: "Error al eliminar condominios duplicados" });
    }
  });

  // Get condominium with properties count
  app.get("/api/admin/condominiums/:id/details", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { id } = req.params;
      const condominium = await storage.getCondominium(id);
      
      if (!condominium) {
        return res.status(404).json({ message: "Condominio no encontrado" });
      }

      // Get properties in this condominium
      const allProperties = await storage.getProperties({});
      const properties = allProperties.filter(p => p.condominiumId === id);

      res.json({
        ...condominium,
        propertiesCount: properties.length,
        properties: properties.map(p => ({
          id: p.id,
          title: p.title,
          unitNumber: p.unitNumber,
          propertyType: p.propertyType,
          status: p.status,
          bedrooms: p.bedrooms,
          bathrooms: p.bathrooms,
          price: p.price,
          ownerId: p.ownerId,
          managementId: p.managementId,
        })),
      });
    } catch (error) {
      console.error("Error fetching condominium details:", error);
      res.status(500).json({ message: "Failed to fetch condominium details" });
    }
  });

  // Get statistics for all condominiums
  app.get("/api/admin/condominiums-stats", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const condominiums = await storage.getCondominiums({});
      const colonies = await storage.getColonies({});
      const allProperties = await storage.getProperties({});

      // Group properties by condominium
      const condominiumStats = condominiums.map(condo => {
        const properties = allProperties.filter(p => p.condominiumId === condo.id);
        return {
          ...condo,
          propertiesCount: properties.length,
        };
      });

      // Group properties by colony
      const colonyStats = colonies.map(colony => {
        const properties = allProperties.filter(p => p.colonyId === colony.id);
        return {
          ...colony,
          propertiesCount: properties.length,
        };
      });

      // Properties without condominium
      const propertiesWithoutCondominium = allProperties.filter(p => !p.condominiumId).length;

      res.json({
        condominiums: condominiumStats,
        colonies: colonyStats,
        totalProperties: allProperties.length,
        propertiesWithoutCondominium,
      });
    } catch (error) {
      console.error("Error fetching condominium stats:", error);
      res.status(500).json({ message: "Failed to fetch condominium stats" });
    }
  });

  // Public endpoint to get units for a condominium
  app.get("/api/condominiums/:condominiumId/units", async (req, res) => {
    try {
      const { condominiumId } = req.params;
      
      // Basic UUID validation to prevent injection
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(condominiumId)) {
        return res.json([]);
      }
      const units = await db
        .select()
        .from(condominiumUnits)
        .where(eq(condominiumUnits.condominiumId, condominiumId));

      res.json(units);
    } catch (error) {
      console.error("Error fetching units:", error);
      res.status(500).json({ message: "Failed to fetch units" });
    }
  });

  // Simplified endpoint to ensure unit exists (create if needed)
  app.post("/api/condominiums/:condominiumId/units/ensure", isAuthenticated, async (req: any, res) => {
    try {
      let userId: string;
      let isAdmin: boolean;
      let userRole: string | null = null;

      // Check if it's an admin session
      if (req.session?.adminUser) {
        userId = req.session.adminUser.id;
        userRole = req.session.adminUser.role;
        isAdmin = ["master", "admin"].includes(userRole);
      } else {
        const user = await ensureUserExists(req);
        if (!user) {
          return res.status(401).json({ message: "Usuario no encontrado" });
        }
        userId = user.id;
        userRole = user.role;
        isAdmin = user.role === "master" || user.role === "admin" || user.additionalRole === "admin";
      }

      const { condominiumId } = req.params;
      const { unitNumber } = req.body;
      // Basic UUID validation to prevent injection
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(condominiumId)) {
        return res.json([]);
      }

      if (!unitNumber || unitNumber.trim() === "") {
        return res.status(400).json({ message: "El número de unidad es requerido" });
      }

      // Search for existing unit in this condominium with exact unit number
      const existingUnit = await db
        .select()
        .from(condominiumUnits)
        .where(
          and(
            eq(condominiumUnits.condominiumId, condominiumId),
            sql`LOWER(${condominiumUnits.unitNumber}) = LOWER(${unitNumber.trim()})`
          )
        )
        .limit(1);

      if (existingUnit.length > 0) {
        return res.json(existingUnit[0]);
      }

      // Create new unit
      const newUnit = await storage.createCondominiumUnit({
        condominiumId,
        unitNumber: unitNumber.trim(),
      });

      await createAuditLog(
        req,
        "create",
        "condominium_unit",
        newUnit.id,
        `Unidad creada: ${unitNumber} en condominio ${condominiumId}`
      );

      res.json(newUnit);
    } catch (error) {
      console.error("Error ensuring unit:", error);
      res.status(500).json({ message: "Failed to ensure unit exists" });
    }
  });

  // System Configuration routes (master only)
  app.get("/api/system-config", isAuthenticated, requireRole(["master"]), async (req, res) => {
    try {
      const configs = await storage.getAllSystemConfigs();
      res.json(configs);
    } catch (error) {
      console.error("Error fetching system configurations:", error);
      res.status(500).json({ message: "Error al obtener configuraciones del sistema" });
    }
  });

  app.get("/api/system-config/:key", isAuthenticated, requireRole(["master"]), async (req, res) => {
    try {
      const { key } = req.params;
      const config = await storage.getSystemConfig(key);
      
      if (!config) {
        return res.status(404).json({ message: "Configuración no encontrada" });
      }
      
      res.json(config);
    } catch (error) {
      console.error("Error fetching system configuration:", error);
      res.status(500).json({ message: "Error al obtener configuración del sistema" });
    }
  });

  app.put("/api/system-config/:key", isAuthenticated, requireRole(["master"]), async (req: any, res) => {
    try {
      const { key } = req.params;
      const { value, description } = req.body;
      
      if (!value) {
        return res.status(400).json({ message: "Valor es requerido" });
      }
      
      const userId = req.user.claims.sub;
      const config = await storage.upsertSystemConfig({
        key,
        value,
        description: description || null,
        updatedBy: userId,
      });
      
      await createAuditLog(req, "update", "system_config", key, `Configuración actualizada: ${key} = ${value}`);
      
      res.json(config);
    } catch (error: any) {
      console.error("Error updating system configuration:", error);
      res.status(400).json({ message: error.message || "Error al actualizar configuración del sistema" });
    }
  });

  // Property Owner Terms routes
  app.get("/api/property-owner-terms", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const terms = await storage.getAllPropertyOwnerTerms();
      res.json(terms);
    } catch (error) {
      console.error("Error fetching property owner terms:", error);
      res.status(500).json({ message: "Error al obtener términos y condiciones" });
    }
  });

  app.get("/api/property-owner-terms/active", async (req, res) => {
    try {
      const terms = await storage.getActivePropertyOwnerTerms();
      res.json(terms);
    } catch (error) {
      console.error("Error fetching active property owner terms:", error);
      res.status(500).json({ message: "Error al obtener términos activos" });
    }
  });

  app.get("/api/property-owner-terms/:id", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const { id } = req.params;
      const term = await storage.getPropertyOwnerTerm(id);
      
      if (!term) {
        return res.status(404).json({ message: "Término no encontrado" });
      }
      
      res.json(term);
    } catch (error) {
      console.error("Error fetching property owner term:", error);
      res.status(500).json({ message: "Error al obtener término" });
    }
  });

  app.post("/api/property-owner-terms", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { title, titleEn, content, contentEn, orderIndex, isActive } = req.body;
      
      if (!title || !titleEn || !content || !contentEn) {
        return res.status(400).json({ message: "Todos los campos son requeridos" });
      }
      
      const userId = req.user.claims.sub;
      const term = await storage.createPropertyOwnerTerm({
        title,
        titleEn,
        content,
        contentEn,
        orderIndex: orderIndex || 0,
        isActive: isActive !== undefined ? isActive : true,
        updatedBy: userId,
      });
      
      await createAuditLog(req, "create", "property_owner_terms", term.id, `Término creado: ${title}`);
      
      res.status(201).json(term);
    } catch (error: any) {
      console.error("Error creating property owner term:", error);
      res.status(400).json({ message: error.message || "Error al crear término" });
    }
  });

  app.patch("/api/property-owner-terms/:id", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { title, titleEn, content, contentEn, orderIndex, isActive } = req.body;
      
      const userId = req.user.claims.sub;
      const updates: any = { updatedBy: userId };
      
      if (title !== undefined) updates.title = title;
      if (titleEn !== undefined) updates.titleEn = titleEn;
      if (content !== undefined) updates.content = content;
      if (contentEn !== undefined) updates.contentEn = contentEn;
      if (orderIndex !== undefined) updates.orderIndex = orderIndex;
      if (isActive !== undefined) updates.isActive = isActive;
      
      const term = await storage.updatePropertyOwnerTerm(id, updates);
      
      await createAuditLog(req, "update", "property_owner_terms", id, `Término actualizado: ${term.title}`);
      
      res.json(term);
    } catch (error: any) {
      console.error("Error updating property owner term:", error);
      res.status(400).json({ message: error.message || "Error al actualizar término" });
    }
  });

  app.delete("/api/property-owner-terms/:id", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      await storage.deletePropertyOwnerTerm(id);
      
      await createAuditLog(req, "delete", "property_owner_terms", id, `Término eliminado`);
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting property owner term:", error);
      res.status(400).json({ message: error.message || "Error al eliminar término" });
    }
  });

  // Amenity routes
  app.get("/api/amenities", async (req, res) => {
    try {
      const { category, approvalStatus } = req.query;
      const filters: any = {};
      if (category) filters.category = category;
      if (approvalStatus) filters.approvalStatus = approvalStatus;
      
      // Only cache if no filters (full amenities list)
      const shouldCache = !category && !approvalStatus;
      const cacheKey = CacheKeys.amenities();
      
      if (shouldCache) {
        const cached = await cache.get(cacheKey);
        if (cached) {
          return res.json(cached);
        }
      }
      
      const amenities = await storage.getAmenities(filters);
      
      // Store in cache only if no filters
      if (shouldCache) {
        await cache.set(cacheKey, amenities, CacheTTL.STATIC);
      }
      
      res.json(amenities);
    } catch (error) {
      console.error("Error fetching amenities:", error);
      res.status(500).json({ message: "Failed to fetch amenities" });
    }
  });

  app.get("/api/amenities/approved", async (req, res) => {
    try {
      const { category } = req.query;
      const amenities = await storage.getApprovedAmenities(category as string | undefined);
      res.json(amenities);
    } catch (error) {
      console.error("Error fetching approved amenities:", error);
      res.status(500).json({ message: "Failed to fetch approved amenities" });
    }
  });

  app.post("/api/amenities", isAuthenticated, async (req: any, res) => {
    try {
      let userId: string;
      let isAdmin: boolean;
      let userRole: string | null = null;

      // Check if it's an admin session (from admin_users table)
      if (req.session?.adminUser) {
        userId = req.session.adminUser.id;
        userRole = req.session.adminUser.role;
        isAdmin = ["master", "admin"].includes(userRole);
      } else {
        // Regular user from Replit Auth
        const user = await ensureUserExists(req);
        if (!user) {
          return res.status(401).json({ message: "Usuario no encontrado" });
        }
        userId = user.id;
        userRole = user.role;
        isAdmin = user.role === "master" || user.role === "admin" || user.additionalRole === "admin";
      }
      
      // Admins can create directly, owners need to suggest with limits
      if (!isAdmin && userRole !== "owner") {
        return res.status(403).json({ message: "Solo los propietarios y administradores pueden crear amenidades" });
      }

      // Check suggestion limits only for non-admin owners
      if (!isAdmin && userRole === "owner") {
        const todaySuggestions = await storage.getUserSuggestionsCount(userId, 'today');
        const totalSuggestions = await storage.getUserSuggestionsCount(userId, 'total');

        if (todaySuggestions >= 3) {
          return res.status(429).json({ 
            message: "Has alcanzado el límite de 3 sugerencias por día" 
          });
        }

        if (totalSuggestions >= 15) {
          return res.status(429).json({ 
            message: "Has alcanzado el límite de 15 sugerencias totales" 
          });
        }
      }
      
      // Validate request body with Zod
      const amenitySchema = z.object({
        name: z.string().min(1, "El nombre de la amenidad es requerido"),
        category: z.enum(["property", "condo"], { errorMap: () => ({ message: "La categoría debe ser 'property' o 'condo'" }) }),
      });
      
      const validationResult = amenitySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const { name, category } = validationResult.data;

      // Admins create directly as approved, owners create as pending
      const approvalStatus = isAdmin ? "approved" : "pending_review";

      // Create amenity
      const amenity = await storage.createAmenity({
        name,
        category,
        approvalStatus,
        requestedBy: userId,
      });

      await createAuditLog(
        req,
        "create",
        "amenity",
        amenity.id,
        isAdmin ? `Amenidad creada: ${name} (${category})` : `Amenidad solicitada: ${name} (${category})`
      );

      // Invalidate cache if admin created (auto-approved)
      if (isAdmin) {
        await cache.invalidate(CacheKeys.amenities());
      }

      res.json(amenity);
    } catch (error) {
      console.error("Error creating amenity:", error);
      res.status(500).json({ message: "Failed to create amenity" });
    }
  });

  app.patch("/api/admin/amenities/:id/approve", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { name } = req.body;

      const existingAmenity = await storage.getAmenity(id);
      if (!existingAmenity) {
        return res.status(404).json({ message: "Amenidad no encontrada" });
      }

      // Update name if provided
      if (name && name.trim() !== "" && name !== existingAmenity.name) {
        await storage.updateAmenity(id, { name: name.trim() });
      }

      const amenity = await storage.updateAmenityStatus(id, "approved");
      
      await createAuditLog(
        req,
        "approve",
        "amenity",
        id,
        `Amenidad aprobada: ${amenity.name}`
      );

      // Invalidate cache after approving amenity
      await cache.invalidate(CacheKeys.amenities());

      res.json(amenity);
    } catch (error) {
      console.error("Error approving amenity:", error);
      res.status(500).json({ message: "Failed to approve amenity" });
    }
  });

  app.patch("/api/admin/amenities/:id/reject", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      const existingAmenity = await storage.getAmenity(id);
      if (!existingAmenity) {
        return res.status(404).json({ message: "Amenidad no encontrada" });
      }

      const amenity = await storage.updateAmenityStatus(id, "rejected");
      
      await createAuditLog(
        req,
        "reject",
        "amenity",
        id,
        `Amenidad rechazada: ${amenity.name}`
      );

      // Invalidate cache after rejecting amenity (removes from approved list)
      await cache.invalidate(CacheKeys.amenities());

      res.json(amenity);
    } catch (error) {
      console.error("Error rejecting amenity:", error);
      res.status(500).json({ message: "Failed to reject amenity" });
    }
  });

  app.put("/api/admin/amenities/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Validate request body with Zod
      const amenitySchema = z.object({
        name: z.string().min(1, "El nombre de la amenidad es requerido"),
        category: z.enum(["property", "condo"]).optional(),
      });
      
      const validationResult = amenitySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const existingAmenity = await storage.getAmenity(id);
      if (!existingAmenity) {
        return res.status(404).json({ message: "Amenidad no encontrada" });
      }

      const amenity = await storage.updateAmenity(id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "amenity",
        amenity.id,
        `Amenidad actualizada: ${amenity.name}`
      );

      // Invalidate cache after updating amenity
      await cache.invalidate(CacheKeys.amenities());

      res.json(amenity);
    } catch (error) {
      console.error("Error updating amenity:", error);
      res.status(500).json({ message: "Failed to update amenity" });
    }
  });

  app.delete("/api/admin/amenities/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      const existingAmenity = await storage.getAmenity(id);
      if (!existingAmenity) {
        return res.status(404).json({ message: "Amenidad no encontrada" });
      }

      await createAuditLog(
        req,
        "delete",
        "amenity",
        id,
        `Amenidad eliminada: ${existingAmenity.name}`
      );

      await storage.deleteAmenity(id);
      
      // Invalidate cache after deleting amenity
      await cache.invalidate(CacheKeys.amenities());
      
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting amenity:", error);
      res.status(500).json({ message: "Failed to delete amenity" });
    }
  });

  // Property Features routes
  app.get("/api/property-features", async (req, res) => {
    try {
      const { active } = req.query;
      const filters: any = {};
      if (active !== undefined) filters.active = active === "true";
      
      // Only cache if no filters (all property features)
      const shouldCache = active === undefined;
      const cacheKey = CacheKeys.propertyFeatures();
      
      if (shouldCache) {
        const cached = await cache.get(cacheKey);
        if (cached) {
          return res.json(cached);
        }
      }
      
      const features = await storage.getPropertyFeatures(filters);
      
      // Store in cache only if no filters
      if (shouldCache) {
        await cache.set(cacheKey, features, CacheTTL.STATIC);
      }
      
      res.json(features);
    } catch (error) {
      console.error("Error fetching property features:", error);
      res.status(500).json({ message: "Failed to fetch property features" });
    }
  });

  app.post("/api/property-features", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      // Validate request body with Zod
      const featureSchema = z.object({
        name: z.string().min(1, "El nombre es requerido"),
        icon: z.string().optional(),
        active: z.boolean().optional().default(true),
      });
      
      const validationResult = featureSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const feature = await storage.createPropertyFeature(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "property_feature",
        feature.id,
        `Característica creada: ${feature.name}`
      );

      // Invalidate cache after creating property feature
      await cache.invalidate(CacheKeys.propertyFeatures());

      res.json(feature);
    } catch (error) {
      console.error("Error creating property feature:", error);
      res.status(500).json({ message: "Failed to create property feature" });
    }
  });

  app.put("/api/property-features/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Validate request body with Zod
      const featureSchema = z.object({
        name: z.string().min(1, "El nombre es requerido").optional(),
        icon: z.string().optional(),
        active: z.boolean().optional(),
      });
      
      const validationResult = featureSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const existingFeature = await storage.getPropertyFeature(id);
      if (!existingFeature) {
        return res.status(404).json({ message: "Característica no encontrada" });
      }

      const feature = await storage.updatePropertyFeature(id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "property_feature",
        feature.id,
        `Característica actualizada: ${feature.name}`
      );

      res.json(feature);
    } catch (error) {
      console.error("Error updating property feature:", error);
      res.status(500).json({ message: "Failed to update property feature" });
    }
  });

  app.delete("/api/property-features/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      const existingFeature = await storage.getPropertyFeature(id);
      if (!existingFeature) {
        return res.status(404).json({ message: "Característica no encontrada" });
      }

      await createAuditLog(
        req,
        "delete",
        "property_feature",
        id,
        `Característica eliminada: ${existingFeature.name}`
      );

      await storage.deletePropertyFeature(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting property feature:", error);
      res.status(500).json({ message: "Failed to delete property feature" });
    }
  });

  // Property routes
  app.get("/api/properties", async (req, res) => {
    try {
      const { status, ownerId, active } = req.query;
      const filters: any = {};
      if (status) filters.status = status;
      if (ownerId) filters.ownerId = ownerId;
      if (active !== undefined) filters.active = active === "true";
      
      const properties = await storage.getProperties(filters);
      res.json(properties);
    } catch (error) {
      console.error("Error fetching properties:", error);
      res.status(500).json({ message: "Failed to fetch properties" });
    }
  });

  app.get("/api/properties/search", async (req: any, res) => {
    try {
      const {
        q,
        minPrice,
        maxPrice,
        bedrooms,
        bathrooms,
        minArea,
        maxArea,
        location,
        amenities,
        status,
        minRating,
        featured,
        availableFrom,
        availableTo,
        propertyType,
        colonyName,
        condoName,
        unitType,
        allowsSubleasing,
        limit
      } = req.query;

      const filters: any = {};

      if (q && typeof q === "string") {
        filters.query = q;
      }
      if (minPrice) filters.minPrice = parseFloat(minPrice as string);
      if (maxPrice) filters.maxPrice = parseFloat(maxPrice as string);
      if (bedrooms) filters.bedrooms = parseInt(bedrooms as string);
      if (bathrooms) filters.bathrooms = parseFloat(bathrooms as string);
      if (minArea) filters.minArea = parseFloat(minArea as string);
      if (maxArea) filters.maxArea = parseFloat(maxArea as string);
      if (location && typeof location === "string") {
        filters.location = location;
      }
      if (amenities) {
        filters.amenities = typeof amenities === "string" ? amenities.split(",") : amenities;
      }
      if (status && typeof status === "string") {
        filters.status = status;
      }
      if (minRating) filters.minRating = parseFloat(minRating as string);
      if (featured !== undefined) {
        filters.featured = featured === "true";
      }
      if (availableFrom && typeof availableFrom === "string") {
        filters.availableFrom = new Date(availableFrom);
      }
      if (availableTo && typeof availableTo === "string") {
        filters.availableTo = new Date(availableTo);
      }
      if (propertyType && typeof propertyType === "string") {
        filters.propertyType = propertyType;
      }
      if (colonyName && typeof colonyName === "string") {
        filters.colonyName = colonyName;
      }
      if (condoName && typeof condoName === "string") {
        filters.condoName = condoName;
      }
      if (unitType && typeof unitType === "string") {
        filters.unitType = unitType;
      }
      if (allowsSubleasing !== undefined) {
        filters.allowsSubleasing = allowsSubleasing === "true";
      }
      if (limit) {
        filters.limit = parseInt(limit as string);
      }

      // Only show published properties in public search (home and search pages) for non-authenticated users
      // Authenticated users (especially admin) can see all properties
      const isUserAuthenticated = req.user || (req.session && (req.session.adminUser || req.session.userId));
      if (!isUserAuthenticated) {
        // Force published = true for non-authenticated users
        filters.published = true;
      }

      const properties = await storage.searchPropertiesAdvanced(filters);
      res.json(properties);
    } catch (error) {
      console.error("Error searching properties:", error);
      res.status(500).json({ message: "Failed to search properties" });
    }
  });

  app.get("/api/properties/:id", async (req: any, res) => {
    try {
      const { id } = req.params;
      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }
      
      // Only show approved or published properties to non-authenticated users
      const isUserAuthenticated = req.user || (req.session && (req.session.adminUser || req.session.userId));
      if (!isUserAuthenticated && !["approved", "published"].includes(property.approvalStatus)) {
        return res.status(404).json({ message: "Property not found" });
      }
      
      res.json(property);
    } catch (error) {
      console.error("Error fetching property:", error);
      res.status(500).json({ message: "Failed to fetch property" });
    }
  });

  app.get("/api/properties/by-slug/:slug", async (req: any, res) => {
    try {
      const { slug } = req.params;
      const property = await storage.getPropertyBySlug(slug);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }
      
      const isUserAuthenticated = req.user || (req.session && (req.session.adminUser || req.session.userId));
      if (!isUserAuthenticated && !["approved", "published"].includes(property.approvalStatus)) {
        return res.status(404).json({ message: "Property not found" });
      }
      
      res.json(property);
    } catch (error) {
      console.error("Error fetching property by slug:", error);
      res.status(500).json({ message: "Failed to fetch property" });
    }
  });

  app.post("/api/properties", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["master", "admin", "admin_jr", "seller", "owner"].includes(user.role)) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const sanitizedBody = {
        ...req.body,
        title: sanitizeText(req.body.title),
        description: sanitizeHtml(req.body.description),
        location: sanitizeText(req.body.location),
      };

      const propertyData = insertPropertySchema.parse({
        ...sanitizedBody,
        ownerId: sanitizedBody.ownerId || userId,
      });

      // Check property limit for owners (admins bypass this check)
      const isAdmin = ["master", "admin", "admin_jr"].includes(user.role);
      const targetOwnerId = propertyData.ownerId;
      const targetOwner = await storage.getUser(targetOwnerId);
      
      if (targetOwner && targetOwner.role === "owner" && !isAdmin) {
        const currentPropertyCount = await storage.getUserPropertyCount(targetOwnerId);
        const propertyLimit = targetOwner.propertyLimit || 3;
        
        if (currentPropertyCount >= propertyLimit) {
          return res.status(403).json({
            message: "Has alcanzado tu límite de propiedades",
            currentCount: currentPropertyCount,
            limit: propertyLimit,
            canRequestIncrease: true,
          });
        }
      }
      
      const property = await storage.createProperty(propertyData);
      
      // Log property creation
      await createAuditLog(
        req,
        "create",
        "property",
        property.id,
        `Propiedad creada: ${getPropertyTitle(property)} - ${property.location}`
      );
      
      res.status(201).json(property);
    } catch (error: any) {
      return handleGenericError(res, error, "al crear la propiedad");
    }
  });

  app.patch("/api/properties/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const property = await storage.getProperty(id);

      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      // Handle both admin and regular user sessions
      let isAuthorized = false;
      
      if (req.session?.adminUser) {
        // Admin user session - check admin privileges
        const adminRole = req.session.adminUser.role;
        isAuthorized = ["master", "admin", "admin_jr"].includes(adminRole);
      } else if (req.user?.claims?.sub) {
        // Regular user session
        const userId = req.user.claims.sub;
        const user = await storage.getUser(userId);
        
        if (user) {
          // User can edit if they own the property or have admin privileges
          isAuthorized = property.ownerId === userId || ["master", "admin", "admin_jr"].includes(user.role);
        }
      }

      if (!isAuthorized) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const sanitizedBody = {
        ...req.body,
        title: req.body.title ? sanitizeText(req.body.title) : undefined,
        description: req.body.description ? sanitizeHtml(req.body.description) : undefined,
        location: req.body.location ? sanitizeText(req.body.location) : undefined,
      };

      const updatedProperty = await storage.updateProperty(id, sanitizedBody);
      
      // Log property update
      await createAuditLog(
        req,
        "update",
        "property",
        id,
        `Propiedad actualizada: ${getPropertyTitle(updatedProperty)}`
      );
      
      res.json(updatedProperty);
    } catch (error: any) {
      return handleGenericError(res, error, "al actualizar la propiedad");
    }
  });

  app.delete("/api/properties/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Check if this is a draft ID (format: draft-{uuid})
      if (id.startsWith('draft-')) {
        const draftId = id.substring(6); // Remove 'draft-' prefix
        const draft = await storage.getPropertySubmissionDraft(draftId);

        if (!draft) {
          return res.status(404).json({ message: "Draft not found" });
        }

        // Check authorization for draft deletion
        let isAuthorized = false;
        
        if (req.session?.adminUser) {
          // Admin user session - check admin privileges (only master and admin can delete)
          const adminRole = req.session.adminUser.role;
          isAuthorized = ["master", "admin"].includes(adminRole);
        } else if (req.user?.claims?.sub) {
          // Regular user session
          const userId = req.user.claims.sub;
          const user = await storage.getUser(userId);
          
          if (user) {
            // User can delete if they own the draft or have admin privileges
            isAuthorized = draft.userId === userId || ["master", "admin"].includes(user.role);
          }
        }

        if (!isAuthorized) {
          return res.status(403).json({ message: "Forbidden" });
        }

        // Log draft deletion
        await createAuditLog(
          req,
          "delete",
          "property-draft",
          draftId,
          `Borrador de propiedad eliminado: ${draft.basicInfo?.name || 'Sin nombre'}`
        );

        await storage.deletePropertySubmissionDraft(draftId);
        res.status(204).send();
        return;
      }
      
      // Handle regular property deletion
      const property = await storage.getProperty(id);

      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      // Handle both admin and regular user sessions
      let isAuthorized = false;
      
      if (req.session?.adminUser) {
        // Admin user session - check admin privileges (only master and admin can delete)
        const adminRole = req.session.adminUser.role;
        isAuthorized = ["master", "admin"].includes(adminRole);
      } else if (req.user?.claims?.sub) {
        // Regular user session
        const userId = req.user.claims.sub;
        const user = await storage.getUser(userId);
        
        if (user) {
          // User can delete if they own the property or have admin privileges
          isAuthorized = property.ownerId === userId || ["master", "admin"].includes(user.role);
        }
      }

      if (!isAuthorized) {
        return res.status(403).json({ message: "Forbidden" });
      }

      // Log property deletion (before deletion to capture details)
      await createAuditLog(
        req,
        "delete",
        "property",
        id,
        `Propiedad eliminada: ${getPropertyTitle(property)} - ${property.location}`
      );

      await storage.deleteProperty(id);
      res.status(204).send();
    } catch (error: any) {
      return handleGenericError(res, error, "al eliminar la propiedad");
    }
  });

  // Property Documents endpoints
  
  // Get documents for a property
  app.get("/api/properties/:propertyId/documents", isAuthenticated, async (req: any, res) => {
    try {
      const { propertyId } = req.params;
      const { category } = req.query;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      // Only owner, assigned staff, or admin can view documents
      const isOwner = property.ownerId === userId;
      const isAdmin = user && ["master", "admin", "admin_jr"].includes(user.role);
      const isAssignedStaff = user && await storage.isStaffAssignedToProperty(propertyId, userId);
      
      if (!isOwner && !isAdmin && !isAssignedStaff) {
        return res.status(403).json({ message: "No autorizado" });
      }
      
      const documents = await storage.getPropertyDocuments(propertyId, category);
      res.json(documents);
    } catch (error: any) {
      console.error("Error fetching property documents:", error);
      res.status(500).json({ message: "Error al obtener documentos" });
    }
  });

  // Upload document for a property
  app.post("/api/properties/:propertyId/documents", isAuthenticated, async (req: any, res) => {
    try {
      const { propertyId } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      // Only owner or admin can upload documents
      if (property.ownerId !== userId && !["master", "admin", "admin_jr"].includes(user?.role || "")) {
        return res.status(403).json({ message: "No autorizado" });
      }

      const { documentType, category } = req.body;

      // Validate that documentType matches category
      const personaMoralOnlyTypes = ['acta_constitutiva'];
      const personaFisicaTypes = ['ife_ine_frente', 'ife_ine_reverso', 'pasaporte', 'legal_estancia', 'escrituras', 
                                    'contrato_compraventa', 'fideicomiso', 'recibo_agua', 'recibo_luz', 
                                    'recibo_internet', 'comprobante_no_adeudo'];
      const optionalTypes = ['reglas_internas', 'reglamento_condominio'];

      if (personaMoralOnlyTypes.includes(documentType) && category !== 'persona_moral') {
        return res.status(400).json({ 
          message: `El documento ${documentType} solo puede ser de categoría persona_moral` 
        });
      }

      if (optionalTypes.includes(documentType) && category !== 'optional') {
        return res.status(400).json({ 
          message: `El documento ${documentType} debe ser de categoría optional` 
        });
      }

      // If category is persona_moral but documentType is not acta_constitutiva, it's still valid
      // (persona_moral needs same docs as persona_fisica PLUS acta_constitutiva)

      const documentData = {
        ...req.body,
        propertyId,
      };

      const document = await storage.createPropertyDocument(documentData);
      
      await createAuditLog(
        req,
        "create",
        "property_document",
        document.id,
        `Documento subido: ${document.documentType} para propiedad ${propertyId}`
      );
      
      res.status(201).json(document);
    } catch (error: any) {
      console.error("Error uploading document:", error);
      res.status(500).json({ message: "Error al subir documento" });
    }
  });

  // Validate document (admin only)
  app.patch("/api/property-documents/:id/validate", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { validationNotes } = req.body;
      const userId = req.user.claims.sub;

      const document = await storage.validatePropertyDocument(id, userId, validationNotes);
      
      await createAuditLog(
        req,
        "update",
        "property_document",
        id,
        `Documento validado: ${document.documentType}`
      );
      
      res.json(document);
    } catch (error: any) {
      console.error("Error validating document:", error);
      res.status(500).json({ message: "Error al validar documento" });
    }
  });

  // Delete document
  app.delete("/api/property-documents/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      const document = await storage.getPropertyDocument(id);
      if (!document) {
        return res.status(404).json({ message: "Documento no encontrado" });
      }
      
      const property = await storage.getProperty(document.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      // Only owner or admin can delete documents
      if (property.ownerId !== userId && !["master", "admin", "admin_jr"].includes(user?.role || "")) {
        return res.status(403).json({ message: "No autorizado" });
      }

      await createAuditLog(
        req,
        "delete",
        "property_document",
        id,
        `Documento eliminado: ${document.documentType}`
      );

      await storage.deletePropertyDocument(id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting document:", error);
      res.status(500).json({ message: "Error al eliminar documento" });
    }
  });

  // Check if property documents are complete
  app.get("/api/properties/:propertyId/documents/check", isAuthenticated, async (req: any, res) => {
    try {
      const { propertyId } = req.params;
      
      const status = await storage.checkPropertyDocumentsComplete(propertyId);
      res.json(status);
    } catch (error: any) {
      console.error("Error checking documents:", error);
      res.status(500).json({ message: "Error al verificar documentos" });
    }
  });

  // Admin route to reassign property owner
  app.patch("/api/properties/:id/reassign-owner", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { newOwnerId } = req.body;

      if (!newOwnerId) {
        return res.status(400).json({ message: "newOwnerId is required" });
      }

      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      const newOwner = await storage.getUser(newOwnerId);
      if (!newOwner) {
        return res.status(404).json({ message: "New owner not found" });
      }

      if (!["owner", "seller"].includes(newOwner.role)) {
        return res.status(400).json({ message: "New owner must have 'owner' or 'seller' role" });
      }

      const previousOwnerId = property.ownerId;
      const updatedProperty = await storage.updateProperty(id, { ownerId: newOwnerId });

      // Log property owner reassignment
      await createAuditLog(
        req,
        "assign",
        "property",
        id,
        `Propietario reasignado de ${previousOwnerId} a ${newOwnerId} - ${updatedProperty.title}`
      );

      res.json(updatedProperty);
    } catch (error: any) {
      return handleGenericError(res, error, "al reasignar el propietario de la propiedad");
    }
  });

  // Owner route to change property status (suspend, rent, activate)
  app.patch("/api/properties/:id/owner-status", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { ownerStatus } = req.body;
      const userId = req.user.claims.sub;

      if (!ownerStatus || !["active", "suspended", "rented"].includes(ownerStatus)) {
        return res.status(400).json({ message: "Invalid ownerStatus. Must be: active, suspended, or rented" });
      }

      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      if (property.ownerId !== userId) {
        return res.status(403).json({ message: "Only the owner can change the property status" });
      }

      const updateData: any = { ownerStatus };

      // If changing from suspended/rented to active, ALWAYS require admin approval again
      // This ensures security and quality control when properties come back online
      if ((property.ownerStatus === "suspended" || property.ownerStatus === "rented") && 
          ownerStatus === "active") {
        // Always downgrade to pending_review when reactivating, EXCEPT for:
        // - draft: still being worked on by owner
        // - pending: waiting for first review
        // - rejected: permanently rejected
        // - changes_requested: owner needs to make changes first
        const statusesToDowngrade = ["published", "approved", "pending_review"];
        if (statusesToDowngrade.includes(property.approvalStatus || "")) {
          updateData.approvalStatus = "pending_review";
          updateData.published = false;
        }
      }

      const updatedProperty = await storage.updateProperty(id, updateData);

      // Log status change
      await createAuditLog(
        req,
        "update",
        "property",
        id,
        `Estado de propiedad cambiado a ${ownerStatus} - ${getPropertyTitle(property)}`
      );

      res.json(updatedProperty);
    } catch (error: any) {
      return handleGenericError(res, error, "al cambiar el estado de la propiedad");
    }
  });

  // Property staff routes
  app.post("/api/properties/:id/staff", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const property = await storage.getProperty(id);

      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      if (!user || (property.ownerId !== userId && !["master", "admin"].includes(user.role))) {
        return res.status(403).json({ message: "Forbidden" });
      }

      // If email is provided instead of staffId, look up the user by email
      let staffId = req.body.staffId;
      if (req.body.email && !staffId) {
        const staffMember = await storage.getUserByEmail(req.body.email);
        if (!staffMember) {
          return res.status(404).json({ message: "Usuario no encontrado con ese email" });
        }
        staffId = staffMember.id;
      }

      const staffData = insertPropertyStaffSchema.parse({
        propertyId: id,
        staffId,
        role: req.body.role,
        assignedById: userId,
      });

      const staff = await storage.assignStaff(staffData);
      res.status(201).json(staff);
    } catch (error: any) {
      console.error("Error assigning staff:", error);
      res.status(400).json({ message: error.message || "Failed to assign staff" });
    }
  });

  app.get("/api/properties/:id/staff", async (req, res) => {
    try {
      const { id } = req.params;
      const staff = await storage.getPropertyStaff(id);
      res.json(staff);
    } catch (error) {
      console.error("Error fetching property staff:", error);
      res.status(500).json({ message: "Failed to fetch property staff" });
    }
  });

  // Get property access information - only for authorized personnel with confirmed appointments
  app.get("/api/properties/:id/access-info", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }

      // Check if user has an authorized role
      const adminRoles = ["master", "admin", "admin_jr", "management"];
      const providerRoles = ["provider"]; // maintenance/service personnel - no appointment check needed
      const conciergeRole = "concierge";
      
      const isAdminRole = adminRoles.includes(user.role);
      const isProviderRole = providerRoles.includes(user.role);
      const isConcierge = user.role === conciergeRole;

      if (!isAdminRole && !isProviderRole && !isConcierge) {
        return res.status(403).json({ 
          message: "No tienes permisos para acceder a esta información" 
        });
      }

      // Only concierges need appointment verification
      if (isConcierge) {
        const appointments = await storage.getAppointments({
          propertyId: id,
        });

        const hasConfirmedAppointment = appointments.some(
          (apt: any) => 
            apt.conciergeId === userId && 
            apt.status === "confirmed"
        );

        if (!hasConfirmedAppointment) {
          return res.status(403).json({ 
            message: "Solo puedes acceder a la información de acceso si tienes una cita confirmada en esta propiedad" 
          });
        }
      }

      // Get property with access info
      const property = await storage.getProperty(id);

      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      if (!property.accessInfo) {
        return res.status(404).json({ 
          message: "Esta propiedad no tiene información de acceso configurada" 
        });
      }

      // Return only the access info
      res.json({ 
        propertyId: property.id,
        propertyTitle: property.title,
        accessInfo: property.accessInfo 
      });

    } catch (error) {
      console.error("Error fetching property access info:", error);
      res.status(500).json({ message: "Failed to fetch property access info" });
    }
  });

  // Property Notes Routes (Internal Annotations for Admins/Sellers)
  app.get("/api/properties/:propertyId/notes", isAuthenticated, async (req: any, res) => {
    try {
      const { propertyId } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Solo vendedores y administradores pueden ver anotaciones internas" });
      }

      const notes = await storage.getPropertyNotes(propertyId);
      res.json(notes);
    } catch (error) {
      console.error("Error fetching property notes:", error);
      res.status(500).json({ message: "Failed to fetch property notes" });
    }
  });

  app.post("/api/properties/:propertyId/notes", isAuthenticated, async (req: any, res) => {
    try {
      const { propertyId } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Solo vendedores y administradores pueden crear anotaciones internas" });
      }

      const { content } = req.body;
      
      if (!content || content.trim() === "") {
        return res.status(400).json({ message: "El contenido de la anotación es requerido" });
      }

      const note = await storage.createPropertyNote({
        propertyId,
        authorId: userId,
        content: content.trim(),
      });

      res.status(201).json(note);
    } catch (error) {
      console.error("Error creating property note:", error);
      res.status(500).json({ message: "Failed to create property note" });
    }
  });

  app.delete("/api/properties/:propertyId/notes/:noteId", isAuthenticated, async (req: any, res) => {
    try {
      const { propertyId, noteId } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }

      const note = await storage.getPropertyNote(noteId);
      
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }

      // Only the author or admin can delete
      if (note.authorId !== userId && !["admin", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Solo el autor o un administrador pueden eliminar esta anotación" });
      }

      await storage.deletePropertyNote(noteId);
      res.json({ message: "Note deleted successfully" });
    } catch (error) {
      console.error("Error deleting property note:", error);
      res.status(500).json({ message: "Failed to delete property note" });
    }
  });

  // Owner API routes - for property owners to manage their properties
  app.get("/api/owner/properties", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      // Get actual properties where user is owner
      const properties = await storage.getProperties({ ownerId: userId });
      
      // Also get submitted/approved drafts that haven't been converted to properties yet
      const drafts = await storage.getPropertySubmissionDrafts({ 
        userId, 
        status: "submitted" 
      });
      
      // Convert drafts to property-like objects with draft flag
      const draftProperties = drafts.map(draft => ({
        id: `draft-${draft.id}`,
        isDraft: true,
        draftId: draft.id,
        condoName: draft.basicInfo?.title || "Propiedad sin título",
        description: draft.basicInfo?.description || "",
        propertyType: draft.basicInfo?.propertyType || "house",
        price: draft.basicInfo?.price || draft.basicInfo?.rentPrice || draft.basicInfo?.salePrice || "0",
        currency: draft.basicInfo?.currency || "MXN",
        bedrooms: draft.details?.bedrooms || 0,
        bathrooms: draft.details?.bathrooms || 0,
        area: draft.details?.area || 0,
        location: draft.locationInfo?.address || draft.locationInfo?.city || "",
        images: draft.media?.images || [],
        primaryImages: draft.media?.primaryImages || [],
        coverImageIndex: draft.media?.coverImageIndex || 0,
        ownerId: draft.userId,
        approvalStatus: "pending_review", // Drafts submitted are pending approval
        ownerStatus: "active",
        published: false,
        active: false,
        status: draft.isForRent ? (draft.isForSale ? "both" : "rent") : "sale",
        createdAt: draft.createdAt,
        updatedAt: draft.updatedAt,
      }));
      
      // Combine real properties and draft properties
      const allProperties = [...properties, ...draftProperties];
      
      res.json(allProperties);
    } catch (error) {
      console.error("Error fetching owner properties:", error);
      res.status(500).json({ message: "Error al obtener propiedades" });
    }
  });

  // Get single property by ID (owner must be the owner of the property)
  app.get("/api/owner/properties/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const { id } = req.params;
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }
      
      const property = await storage.getProperty(id);
      
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      // Verify owner
      if (property.ownerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para ver esta propiedad" });
      }
      
      res.json(property);
    } catch (error) {
      console.error("Error fetching owner property:", error);
      res.status(500).json({ message: "Error al obtener propiedad" });
    }
  });

  app.get("/api/owner/change-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      // Get all change requests and filter by owner
      const allChangeRequests = await storage.getPropertyChangeRequests();
      const changeRequests = allChangeRequests.filter(cr => cr.requestedById === userId);
      res.json(changeRequests);
    } catch (error) {
      console.error("Error fetching change requests:", error);
      res.status(500).json({ message: "Error al obtener solicitudes de cambio" });
    }
  });

  app.post("/api/owner/change-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      // Validate request body with Zod
      const validationResult = createPropertyChangeRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const { propertyId, changedFields } = validationResult.data;

      // Verify user owns the property
      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      if (property.ownerId !== userId && !["admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "No tienes permisos para modificar esta propiedad" });
      }

      // Create change request and update property status in transaction
      await db.transaction(async (tx) => {
        const changeRequest = await storage.createPropertyChangeRequest({
          propertyId,
          requestedById: userId,
          changedFields: changedFields as any,
        });

        // Update property approval status to "changes_requested"
        await storage.updateProperty(propertyId, { 
          approvalStatus: "changes_requested" 
        });

        await createAuditLog(
          req,
          "create",
          "property_change_request",
          changeRequest.id,
          `Solicitud de cambio creada para propiedad: ${property.title}`
        );

        res.status(201).json(changeRequest);
      });
    } catch (error: any) {
      console.error("Error creating change request:", error);
      res.status(500).json({ message: error.message || "Error al crear solicitud de cambio" });
    }
  });

  app.get("/api/owner/settings", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      const settings = await storage.getOwnerSettings(userId);
      res.json(settings || { userId, autoApproveAppointments: false });
    } catch (error) {
      console.error("Error fetching owner settings:", error);
      res.status(500).json({ message: "Error al obtener configuración" });
    }
  });

  app.post("/api/owner/settings", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      // Validate request body with Zod
      const validationResult = updateOwnerSettingsSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const updates = validationResult.data;
      
      // Check if settings already exist
      const existing = await storage.getOwnerSettings(userId);
      
      let settings;
      if (existing) {
        settings = await storage.updateOwnerSettings(userId, updates);
      } else {
        settings = await storage.createOwnerSettings({ userId, ...updates });
      }

      await createAuditLog(
        req,
        "update",
        "owner_settings",
        settings.id,
        `Configuración actualizada`
      );

      res.json(settings);
    } catch (error: any) {
      console.error("Error updating owner settings:", error);
      res.status(500).json({ message: error.message || "Error al actualizar configuración" });
    }
  });

  app.get("/api/owner/appointments/pending", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      // Get properties owned by user
      const properties = await storage.getProperties({ ownerId: userId });
      const propertyIds = properties.map(p => p.id);

      if (propertyIds.length === 0) {
        return res.json([]);
      }

      // Get all appointments for these properties and filter by ownerApprovalStatus
      const allAppointments = await storage.getAppointments({});
      const pendingAppointments = allAppointments.filter(apt => 
        propertyIds.includes(apt.propertyId) && apt.ownerApprovalStatus === "pending"
      );
      res.json(pendingAppointments);
    } catch (error) {
      console.error("Error fetching pending appointments:", error);
      res.status(500).json({ message: "Error al obtener citas pendientes" });
    }
  });

  app.patch("/api/owner/appointments/:id/approve", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Verify user owns the property
      const property = await storage.getProperty(appointment.propertyId);
      
      console.log(`[APPROVE DEBUG] userId: ${userId}, property.ownerId: ${property?.ownerId}, user.role: ${user.role}`);
      
      if (!property || (property.ownerId !== userId && !["admin", "admin_jr", "master"].includes(user.role))) {
        console.log(`[APPROVE DEBUG] Permission denied - property exists: ${!!property}, userId matches: ${property?.ownerId === userId}, is admin: ${["admin", "admin_jr", "master"].includes(user.role)}`);
        return res.status(403).json({ message: "No tienes permisos para aprobar esta cita" });
      }

      // Update appointment approval status
      const updated = await storage.updateAppointment(id, {
        ownerApprovalStatus: "approved",
        ownerApprovedAt: new Date(),
        ownerApprovalNotes: req.body.notes,
      });

      await createAuditLog(
        req,
        "approve",
        "appointment",
        id,
        `Cita aprobada por propietario`
      );

      // Create notifications for concierge, client, and admin
      const notifications = [];
      
      // Notify concierge if assigned
      if (appointment.conciergeId) {
        notifications.push(
          storage.createNotification({
            userId: appointment.conciergeId,
            type: "appointment",
            title: "Cita Aprobada",
            message: `La cita para ${property.title} el ${new Date(appointment.date).toLocaleDateString()} ha sido aprobada por el propietario`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "medium",
          })
        );
      }
      
      // Notify client
      notifications.push(
        storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Cita Aprobada",
          message: `Tu cita para ${property.title} el ${new Date(appointment.date).toLocaleDateString()} ha sido aprobada`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );
      
      // Notify admins
      const admins = await storage.getUsersByRole("admin");
      for (const admin of admins) {
        notifications.push(
          storage.createNotification({
            userId: admin.id,
            type: "appointment",
            title: "Cita Aprobada",
            message: `Cita para ${property.title} aprobada por propietario el ${new Date(appointment.date).toLocaleDateString()}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "low",
          })
        );
      }
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error approving appointment:", error);
      res.status(500).json({ message: error.message || "Error al aprobar cita" });
    }
  });

  app.patch("/api/owner/appointments/:id/reject", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Verify user owns the property
      const property = await storage.getProperty(appointment.propertyId);
      if (!property || (property.ownerId !== userId && !["admin", "admin_jr", "master"].includes(user.role))) {
        return res.status(403).json({ message: "No tienes permisos para rechazar esta cita" });
      }

      // Update appointment approval status
      const updated = await storage.updateAppointment(id, {
        ownerApprovalStatus: "rejected",
        ownerApprovedAt: new Date(),
        ownerApprovalNotes: req.body.notes,
      });

      await createAuditLog(
        req,
        "reject",
        "appointment",
        id,
        `Cita rechazada por propietario`
      );

      // Create notifications
      const notifications = [];
      
      // Notify client
      notifications.push(
        storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Cita Rechazada",
          message: `Tu cita para ${property.title} el ${new Date(appointment.date).toLocaleDateString()} ha sido rechazada`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );
      
      // Notify admins
      const admins = await storage.getUsersByRole("admin");
      for (const admin of admins) {
        notifications.push(
          storage.createNotification({
            userId: admin.id,
            type: "appointment",
            title: "Cita Rechazada",
            message: `Cita para ${property.title} rechazada por propietario el ${new Date(appointment.date).toLocaleDateString()}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "low",
          })
        );
      }
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error rejecting appointment:", error);
      res.status(500).json({ message: error.message || "Error al rechazar cita" });
    }
  });

  // Request reschedule for appointment (owner requests new date)
  app.patch("/api/owner/appointments/:id/request-reschedule", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { rescheduleRequestedDate, rescheduleNotes } = req.body;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const property = await storage.getProperty(appointment.propertyId);
      
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Verify owner
      if (property.ownerId !== userId && !["admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "No eres el propietario de esta propiedad" });
      }

      // Update appointment with reschedule request
      const updated = await storage.updateAppointment(id, {
        rescheduleStatus: "requested",
        rescheduleRequestedDate: new Date(rescheduleRequestedDate),
        rescheduleNotes: rescheduleNotes || null,
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Solicitud de reprogramación enviada`
      );

      // Notify client about reschedule request
      const notifications: Promise<any>[] = [];
      
      notifications.push(
        storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Solicitud de Reprogramación",
          message: `El propietario solicita reprogramar la cita del ${new Date(appointment.date).toLocaleDateString()} al ${new Date(rescheduleRequestedDate).toLocaleDateString()}`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );

      // Notify concierge if assigned
      if (appointment.conciergeId) {
        notifications.push(
          storage.createNotification({
            userId: appointment.conciergeId,
            type: "appointment",
            title: "Cita - Solicitud de Reprogramación",
            message: `Solicitud de reprogramación para ${property.title} del ${new Date(appointment.date).toLocaleDateString()} al ${new Date(rescheduleRequestedDate).toLocaleDateString()}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "medium",
          })
        );
      }
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error requesting reschedule:", error);
      res.status(500).json({ message: error.message || "Error al solicitar reprogramación" });
    }
  });

  // Approve reschedule request (client approves)
  app.post("/api/client/appointments/:id/approve-reschedule", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Verify client
      if (appointment.clientId !== userId) {
        return res.status(403).json({ message: "No eres el cliente de esta cita" });
      }

      // Verify reschedule request exists
      if (appointment.rescheduleStatus !== "requested" || !appointment.rescheduleRequestedDate) {
        return res.status(400).json({ message: "No hay solicitud de reprogramación pendiente" });
      }

      const property = await storage.getProperty(appointment.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Update appointment: approve reschedule and change date
      const updated = await storage.updateAppointment(id, {
        rescheduleStatus: "approved",
        date: appointment.rescheduleRequestedDate,
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Reprogramación aprobada por cliente`
      );

      // Notify owner about approval
      const notifications: Promise<any>[] = [];
      
      notifications.push(
        storage.createNotification({
          userId: property.ownerId,
          type: "appointment",
          title: "Reprogramación Aprobada",
          message: `El cliente aprobó la reprogramación de la cita para ${property.title} al ${new Date(appointment.rescheduleRequestedDate).toLocaleDateString()}`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );

      // Notify concierge if assigned
      if (appointment.conciergeId) {
        notifications.push(
          storage.createNotification({
            userId: appointment.conciergeId,
            type: "appointment",
            title: "Cita Reprogramada",
            message: `Cita para ${property.title} reprogramada al ${new Date(appointment.rescheduleRequestedDate).toLocaleDateString()}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "medium",
          })
        );
      }
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error approving reschedule:", error);
      res.status(500).json({ message: error.message || "Error al aprobar reprogramación" });
    }
  });

  // Reject reschedule request (client rejects - appointment gets cancelled)
  app.post("/api/client/appointments/:id/reject-reschedule", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Verify client
      if (appointment.clientId !== userId) {
        return res.status(403).json({ message: "No eres el cliente de esta cita" });
      }

      // Verify reschedule request exists
      if (appointment.rescheduleStatus !== "requested") {
        return res.status(400).json({ message: "No hay solicitud de reprogramación pendiente" });
      }

      const property = await storage.getProperty(appointment.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Update appointment: reject reschedule and cancel appointment
      const updated = await storage.updateAppointment(id, {
        rescheduleStatus: "rejected",
        status: "cancelled",
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Reprogramación rechazada por cliente - cita cancelada`
      );

      // Notify owner about rejection and cancellation
      const notifications: Promise<any>[] = [];
      
      notifications.push(
        storage.createNotification({
          userId: property.ownerId,
          type: "appointment",
          title: "Reprogramación Rechazada",
          message: `El cliente rechazó la reprogramación para ${property.title}. La cita ha sido cancelada.`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );

      // Notify concierge if assigned
      if (appointment.conciergeId) {
        notifications.push(
          storage.createNotification({
            userId: appointment.conciergeId,
            type: "appointment",
            title: "Cita Cancelada",
            message: `Cita para ${property.title} cancelada debido a rechazo de reprogramación`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "medium",
          })
        );
      }
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error rejecting reschedule:", error);
      res.status(500).json({ message: error.message || "Error al rechazar reprogramación" });
    }
  });

  // Client requests reschedule for appointment (client requests new date)
  app.patch("/api/client/appointments/:id/request-reschedule", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { rescheduleRequestedDate, rescheduleNotes } = req.body;
      const userId = req.user.claims.sub;
      
      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Verify client
      if (appointment.clientId !== userId) {
        return res.status(403).json({ message: "No eres el cliente de esta cita" });
      }

      // Cannot reschedule cancelled or completed appointments
      if (appointment.status === "cancelled") {
        return res.status(400).json({ message: "No se puede reprogramar una cita cancelada" });
      }

      if (appointment.status === "completed") {
        return res.status(400).json({ message: "No se puede reprogramar una cita ya completada" });
      }

      // Cannot reschedule appointments that already passed
      const appointmentDate = new Date(appointment.date);
      if (appointmentDate < new Date()) {
        return res.status(400).json({ message: "No se puede reprogramar una cita que ya pasó" });
      }

      const property = await storage.getProperty(appointment.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Update appointment with reschedule request
      const updated = await storage.updateAppointment(id, {
        rescheduleStatus: "requested",
        rescheduleRequestedDate: new Date(rescheduleRequestedDate),
        rescheduleNotes: rescheduleNotes || null,
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Solicitud de reprogramación enviada por cliente`
      );

      // Notify owner about reschedule request
      const notifications: Promise<any>[] = [];
      
      notifications.push(
        storage.createNotification({
          userId: property.ownerId,
          type: "appointment",
          title: "Solicitud de Reprogramación",
          message: `El cliente solicita reprogramar la cita del ${new Date(appointment.date).toLocaleDateString()} al ${new Date(rescheduleRequestedDate).toLocaleDateString()}`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );

      // Notify concierge if assigned
      if (appointment.conciergeId) {
        notifications.push(
          storage.createNotification({
            userId: appointment.conciergeId,
            type: "appointment",
            title: "Cita - Solicitud de Reprogramación",
            message: `El cliente solicitó reprogramar la cita para ${property.title} del ${new Date(appointment.date).toLocaleDateString()} al ${new Date(rescheduleRequestedDate).toLocaleDateString()}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "medium",
          })
        );
      }
      
      // Notify admins
      const admins = await storage.getUsersByRole("admin");
      for (const admin of admins) {
        notifications.push(
          storage.createNotification({
            userId: admin.id,
            type: "appointment",
            title: "Cita - Solicitud de Reprogramación",
            message: `Cliente solicitó reprogramar cita para ${property.title} del ${new Date(appointment.date).toLocaleDateString()} al ${new Date(rescheduleRequestedDate).toLocaleDateString()}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "low",
          })
        );
      }
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error requesting reschedule:", error);
      res.status(500).json({ message: error.message || "Error al solicitar reprogramación" });
    }
  });

  // Owner approves client reschedule request
  app.post("/api/owner/appointments/:id/approve-reschedule", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const property = await storage.getProperty(appointment.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Verify owner
      if (property.ownerId !== userId && !["admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "No eres el propietario de esta propiedad" });
      }

      // Verify reschedule request exists
      if (appointment.rescheduleStatus !== "requested" || !appointment.rescheduleRequestedDate) {
        return res.status(400).json({ message: "No hay solicitud de reprogramación pendiente" });
      }

      // Update appointment: approve reschedule and change date
      const updated = await storage.updateAppointment(id, {
        rescheduleStatus: "approved",
        date: appointment.rescheduleRequestedDate,
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Reprogramación aprobada por propietario`
      );

      // Notify client about approval
      const notifications: Promise<any>[] = [];
      
      notifications.push(
        storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Reprogramación Aprobada",
          message: `El propietario aprobó la reprogramación de tu cita para ${property.title} al ${new Date(appointment.rescheduleRequestedDate).toLocaleDateString()}`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );

      // Notify concierge if assigned
      if (appointment.conciergeId) {
        notifications.push(
          storage.createNotification({
            userId: appointment.conciergeId,
            type: "appointment",
            title: "Cita Reprogramada",
            message: `Cita para ${property.title} reprogramada al ${new Date(appointment.rescheduleRequestedDate).toLocaleDateString()}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "medium",
          })
        );
      }
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error approving reschedule:", error);
      res.status(500).json({ message: error.message || "Error al aprobar reprogramación" });
    }
  });

  // Owner rejects client reschedule request
  app.post("/api/owner/appointments/:id/reject-reschedule", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      if (!user || !["owner", "seller", "admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const property = await storage.getProperty(appointment.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Verify owner
      if (property.ownerId !== userId && !["admin", "admin_jr", "master"].includes(user.role)) {
        return res.status(403).json({ message: "No eres el propietario de esta propiedad" });
      }

      // Verify reschedule request exists
      if (appointment.rescheduleStatus !== "requested") {
        return res.status(400).json({ message: "No hay solicitud de reprogramación pendiente" });
      }

      // Update appointment: reject reschedule (keep original date)
      const updated = await storage.updateAppointment(id, {
        rescheduleStatus: "rejected",
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Reprogramación rechazada por propietario`
      );

      // Notify client about rejection
      const notifications: Promise<any>[] = [];
      
      notifications.push(
        storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Reprogramación Rechazada",
          message: `El propietario rechazó tu solicitud de reprogramación para ${property.title}. La cita se mantiene en la fecha original.`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        })
      );
      
      // Create all notifications
      await Promise.all(notifications);

      res.json(updated);
    } catch (error: any) {
      console.error("Error rejecting reschedule:", error);
      res.status(500).json({ message: error.message || "Error al rechazar reprogramación" });
    }
  });

  // Admin auto-approve appointments (bypass owner approval)
  app.patch("/api/admin/appointments/:id/auto-approve", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const updated = await storage.updateAppointment(id, {
        ownerApprovalStatus: "approved",
        ownerApprovedAt: new Date(),
        status: "confirmed",
      });

      await createAuditLog(
        req,
        "approve",
        "appointment",
        id,
        `Cita auto-aprobada por administrador`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error auto-approving appointment:", error);
      res.status(500).json({ message: error.message || "Error al auto-aprobar cita" });
    }
  });

  // Get appointment with filtered information based on visit type and user role
  app.get("/api/appointments/:id/details", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Get property info
      const property = await storage.getProperty(appointment.propertyId);
      
      // Filter information based on visit type and user role
      let filteredAppointment: any = { ...appointment };
      
      if (appointment.visitType === "visita_cliente") {
        // For client visits, owner gets limited info
        if (user && ["owner", "seller"].includes(user.role)) {
          const client = await storage.getUser(appointment.clientId);
          const presentationCard = appointment.presentationCardId 
            ? await storage.getPresentationCard(appointment.presentationCardId)
            : null;

          filteredAppointment.client = {
            firstName: client?.firstName,
            lastName: client?.lastName,
            profileImageUrl: client?.profileImageUrl,
            presentationCard: presentationCard ? {
              name: presentationCard.name,
              jobTitle: presentationCard.jobTitle,
              company: presentationCard.company,
              bio: presentationCard.bio,
              profileImageUrl: presentationCard.profileImageUrl,
            } : null,
          };
          
          // Remove sensitive client info
          delete filteredAppointment.client?.email;
          delete filteredAppointment.client?.phone;
        }
      } else {
        // For other visit types (maintenance, cleaning, etc.), show full staff info
        if (appointment.staffMemberId) {
          const staffMember = await storage.getUser(appointment.staffMemberId);
          filteredAppointment.staffMember = {
            id: staffMember?.id,
            name: appointment.staffMemberName,
            position: appointment.staffMemberPosition,
            company: appointment.staffMemberCompany,
            whatsapp: appointment.staffMemberWhatsapp,
            email: staffMember?.email,
          };
        }
      }

      // Add property info with condominium and unit details
      if (property) {
        let condoInfo = null;
        if (property.condominiumId) {
          const condo = await storage.getCondominium(property.condominiumId);
          condoInfo = condo;
        }

        filteredAppointment.property = {
          ...property,
          condominium: condoInfo,
        };
      }

      // Add concierge info if available
      if (appointment.conciergeId) {
        const concierge = await storage.getUser(appointment.conciergeId);
        if (concierge) {
          filteredAppointment.concierge = {
            id: concierge.id,
            firstName: concierge.firstName,
            lastName: concierge.lastName,
            email: concierge.email,
            phone: concierge.phone,
            profileImageUrl: concierge.profileImageUrl,
          };
        }
      }

      res.json(filteredAppointment);
    } catch (error: any) {
      console.error("Error fetching appointment details:", error);
      res.status(500).json({ message: error.message || "Error al obtener detalles de cita" });
    }
  });

  // Submit feedback for appointment
  app.patch("/api/appointments/:id/feedback", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { feedbackType, feedback } = req.body;
      const userId = req.user.claims.sub;

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Validate feedback type
      if (!["client", "staff"].includes(feedbackType)) {
        return res.status(400).json({ message: "Tipo de feedback inválido" });
      }

      let updates: any = {};

      if (feedbackType === "client") {
        // Client feedback - must be the client for this appointment
        if (appointment.clientId !== userId) {
          return res.status(403).json({ message: "No tienes permisos para dejar feedback en esta cita" });
        }
        
        // Validate feedback structure for client (predefined options only)
        if (!feedback || typeof feedback !== "object") {
          return res.status(400).json({ message: "Feedback de cliente debe ser un objeto con opciones predefinidas" });
        }

        updates.clientFeedback = feedback;
      } else if (feedbackType === "staff") {
        // Staff feedback - must be the staff member or concierge
        if (appointment.staffMemberId !== userId && appointment.conciergeId !== userId) {
          return res.status(403).json({ message: "No tienes permisos para dejar feedback en esta cita" });
        }

        updates.staffFeedback = feedback;
      }

      const updated = await storage.updateAppointment(id, updates);

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Feedback ${feedbackType} agregado a la cita`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error submitting feedback:", error);
      res.status(500).json({ message: error.message || "Error al enviar feedback" });
    }
  });

  // Send access credentials for appointment
  app.patch("/api/appointments/:id/send-credentials", isAuthenticated, requireRole(["master", "admin", "admin_jr", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const updated = await storage.updateAppointment(id, {
        accessCredentialsSent: true,
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Credenciales de acceso enviadas para la cita`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error sending credentials:", error);
      res.status(500).json({ message: error.message || "Error al enviar credenciales" });
    }
  });

  // Admin API routes - for admins to manage property approvals and inspections
  app.get("/api/admin/change-requests", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { status, propertyId } = req.query;
      
      const allChangeRequests = await storage.getPropertyChangeRequests();
      let changeRequests = allChangeRequests;
      
      if (status) {
        changeRequests = changeRequests.filter(cr => cr.status === status);
      }
      if (propertyId) {
        changeRequests = changeRequests.filter(cr => cr.propertyId === propertyId);
      }
      
      res.json(changeRequests);
    } catch (error) {
      console.error("Error fetching change requests:", error);
      res.status(500).json({ message: "Error al obtener solicitudes de cambio" });
    }
  });

  app.patch("/api/admin/change-requests/:id/approve", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reviewNotes } = req.body;
      const reviewerId = req.user?.claims?.sub || req.session?.adminUser?.id;

      const changeRequest = await storage.getPropertyChangeRequest(id);
      if (!changeRequest) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      if (changeRequest.status !== "pending") {
        return res.status(400).json({ 
          message: "Esta solicitud ya fue procesada" 
        });
      }

      // Validate changed fields before applying
      const changedFields = changeRequest.changedFields as any;
      if (typeof changedFields !== 'object' || changedFields === null || Array.isArray(changedFields)) {
        return res.status(400).json({ 
          message: "Datos de cambio inválidos" 
        });
      }

      // Approve and apply changes in transaction
      await db.transaction(async (tx) => {
        // Approve change request and apply changes (cascade logic in storage)
        // Only pass reviewerId if it's an OIDC user (not admin or local auth)
        const reviewerIdToSave = (!req.user?.adminAuth && !req.user?.localAuth) ? req.user?.claims?.sub : null;
        const updated = await storage.updatePropertyChangeRequestStatus(
          id,
          "approved",
          reviewerIdToSave,
          reviewNotes
        );

        await createAuditLog(
          req,
          "approve",
          "property_change_request",
          id,
          `Cambios aprobados para propiedad ${changeRequest.propertyId}`
        );

        res.json(updated);
      });
    } catch (error: any) {
      console.error("Error approving change request:", error);
      res.status(500).json({ message: error.message || "Error al aprobar cambios" });
    }
  });

  app.patch("/api/admin/change-requests/:id/reject", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reviewNotes } = req.body;
      const reviewerId = req.user?.claims?.sub || req.session?.adminUser?.id;

      const changeRequest = await storage.getPropertyChangeRequest(id);
      if (!changeRequest) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      if (changeRequest.status !== "pending") {
        return res.status(400).json({ 
          message: "Esta solicitud ya fue procesada" 
        });
      }

      // Only pass reviewerId if it's an OIDC user (not admin or local auth)
      const reviewerIdToSave = (!req.user?.adminAuth && !req.user?.localAuth) ? req.user?.claims?.sub : null;
      const updated = await storage.updatePropertyChangeRequestStatus(
        id,
        "rejected",
        reviewerIdToSave,
        reviewNotes
      );

      await createAuditLog(
        req,
        "reject",
        "property_change_request",
        id,
        `Cambios rechazados para propiedad ${changeRequest.propertyId}`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error rejecting change request:", error);
      res.status(500).json({ message: error.message || "Error al rechazar cambios" });
    }
  });

  app.get("/api/admin/inspection-reports", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { status, propertyId } = req.query;
      
      const allReports = await storage.getInspectionReports();
      let reports = allReports;
      
      if (status) {
        reports = reports.filter(r => r.status === status);
      }
      if (propertyId) {
        reports = reports.filter(r => r.propertyId === propertyId);
      }
      
      res.json(reports);
    } catch (error) {
      console.error("Error fetching inspection reports:", error);
      res.status(500).json({ message: "Error al obtener reportes de inspección" });
    }
  });

  app.get("/api/admin/inspection-reports/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { id } = req.params;
      const report = await storage.getInspectionReport(id);
      
      if (!report) {
        return res.status(404).json({ message: "Reporte no encontrado" });
      }
      
      res.json(report);
    } catch (error) {
      console.error("Error fetching inspection report:", error);
      res.status(500).json({ message: "Error al obtener reporte" });
    }
  });

  // Admin Rental Opportunity Request routes
  app.get("/api/admin/rental-opportunity-requests", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { status } = req.query;
      
      const allRequests = await storage.getAllRentalOpportunityRequests();
      let requests = allRequests;
      
      if (status) {
        requests = requests.filter(r => r.status === status);
      }
      
      res.json(requests);
    } catch (error) {
      console.error("Error fetching rental opportunity requests:", error);
      res.status(500).json({ message: "Error al obtener solicitudes de oportunidad" });
    }
  });

  app.get("/api/admin/rental-opportunity-requests/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { id } = req.params;
      const request = await storage.getRentalOpportunityRequest(id);
      
      if (!request) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }
      
      res.json(request);
    } catch (error) {
      console.error("Error fetching rental opportunity request:", error);
      res.status(500).json({ message: "Error al obtener solicitud" });
    }
  });

  app.patch("/api/admin/rental-opportunity-requests/:id/approve", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const adminId = req.user?.claims?.sub || req.session?.adminUser?.id;
      
      const request = await storage.getRentalOpportunityRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      if (request.status !== "pending") {
        return res.status(400).json({ 
          message: "Esta solicitud ya fue procesada" 
        });
      }

      const updated = await storage.approveRentalOpportunityRequest(id, adminId);

      // Get property details for notification
      const property = await storage.getProperty(request.propertyId);
      
      // Notify client
      await storage.createNotification({
        userId: request.clientId,
        type: "opportunity",
        title: "Solicitud de Oportunidad Aprobada",
        message: `Tu solicitud para crear una oferta de renta para ${property?.title || 'la propiedad'} ha sido aprobada. Ahora puedes crear tu oferta.`,
        relatedEntityType: "rental_opportunity_request",
        relatedEntityId: request.id,
        priority: "high",
      });

      await createAuditLog(
        req,
        "approve",
        "rental_opportunity_request",
        id,
        `Solicitud de oportunidad de renta aprobada para propiedad ${request.propertyId}`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error approving rental opportunity request:", error);
      res.status(500).json({ message: error.message || "Error al aprobar solicitud" });
    }
  });

  app.patch("/api/admin/rental-opportunity-requests/:id/reject", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { rejectionReason } = req.body;
      const adminId = req.user?.claims?.sub || req.session?.adminUser?.id;

      if (!rejectionReason) {
        return res.status(400).json({ message: "La razón de rechazo es requerida" });
      }
      
      const request = await storage.getRentalOpportunityRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Solicitud no encontrada" });
      }

      if (request.status !== "pending") {
        return res.status(400).json({ 
          message: "Esta solicitud ya fue procesada" 
        });
      }

      const updated = await storage.rejectRentalOpportunityRequest(id, adminId, rejectionReason);

      // Get property details for notification
      const property = await storage.getProperty(request.propertyId);
      
      // Notify client
      await storage.createNotification({
        userId: request.clientId,
        type: "opportunity",
        title: "Solicitud de Oportunidad Rechazada",
        message: `Tu solicitud para crear una oferta de renta para ${property?.title || 'la propiedad'} ha sido rechazada. Razón: ${rejectionReason}`,
        relatedEntityType: "rental_opportunity_request",
        relatedEntityId: request.id,
        priority: "high",
      });

      await createAuditLog(
        req,
        "reject",
        "rental_opportunity_request",
        id,
        `Solicitud de oportunidad de renta rechazada para propiedad ${request.propertyId}: ${rejectionReason}`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error rejecting rental opportunity request:", error);
      res.status(500).json({ message: error.message || "Error al rechazar solicitud" });
    }
  });

  // Admin: Grant rental opportunity directly to a client (without appointment)
  app.post("/api/admin/rental-opportunity-requests/grant", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const adminId = req.user?.claims?.sub || req.session?.adminUser?.id;
      const { userId, propertyId, notes } = req.body;

      if (!userId || !propertyId) {
        return res.status(400).json({ message: "userId y propertyId son requeridos" });
      }

      // Verify user exists and is a client
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      if (user.role !== "cliente") {
        return res.status(400).json({ message: "Solo se puede otorgar oportunidades a clientes" });
      }

      // Verify property exists
      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Check if there's already an approved opportunity for this client-property combination
      const existingOpportunities = await db
        .select()
        .from(rentalOpportunityRequests)
        .where(
          and(
            eq(rentalOpportunityRequests.userId, userId),
            eq(rentalOpportunityRequests.propertyId, propertyId),
            eq(rentalOpportunityRequests.status, "approved" as any)
          )
        );

      if (existingOpportunities.length > 0) {
        return res.status(400).json({ 
          message: "Ya existe una oportunidad aprobada para este cliente en esta propiedad" 
        });
      }

      // Create the rental opportunity request directly as approved
      const [opportunityRequest] = await db
        .insert(rentalOpportunityRequests)
        .values({
          userId,
          propertyId,
          appointmentId: null, // No appointment required when admin grants directly
          status: "approved" as any,
          notes: notes || "Oportunidad otorgada directamente por administrador",
          approvedBy: adminId,
          approvedAt: new Date(),
        })
        .returning();

      // Notify client
      await storage.createNotification({
        userId,
        type: "opportunity",
        title: "Oportunidad de Renta Otorgada",
        message: `Se te ha otorgado una oportunidad para crear una oferta de renta para ${property.title}. Puedes proceder a crear tu oferta.`,
        relatedEntityType: "rental_opportunity_request",
        relatedEntityId: opportunityRequest.id,
        priority: "high",
      });

      await createAuditLog(
        req,
        "approve",
        "rental_opportunity_request",
        opportunityRequest.id,
        `Oportunidad de renta otorgada directamente a ${user.firstName} ${user.lastName} para propiedad ${property.title}`
      );

      res.json(opportunityRequest);
    } catch (error: any) {
      console.error("Error granting rental opportunity:", error);
      res.status(500).json({ message: error.message || "Error al otorgar oportunidad" });
    }
  });

  app.post("/api/admin/inspection-reports", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const inspectorId = req.user?.claims?.sub || req.session?.adminUser?.id;
      
      // Validate request body with Zod
      const validationResult = createInspectionReportSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const { propertyId, inspectionDate, observations } = validationResult.data;

      // Verify property exists
      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Create inspection report
      const report = await storage.createInspectionReport({
        propertyId,
        inspectorId,
        inspectionDate,
        status: "scheduled",
        observations,
      });

      await createAuditLog(
        req,
        "create",
        "inspection_report",
        report.id,
        `Inspección programada para propiedad ${property.title}`
      );

      res.status(201).json(report);
    } catch (error: any) {
      console.error("Error creating inspection report:", error);
      res.status(500).json({ message: error.message || "Error al crear reporte de inspección" });
    }
  });

  app.patch("/api/admin/inspection-reports/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Validate request body with Zod
      const validationResult = updateInspectionReportSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const updates = validationResult.data;

      const report = await storage.getInspectionReport(id);
      if (!report) {
        return res.status(404).json({ message: "Reporte no encontrado" });
      }

      // Update inspection report (cascade logic in storage handles property approval status)
      const updated = await storage.updateInspectionReport(id, updates as any);

      await createAuditLog(
        req,
        "update",
        "inspection_report",
        id,
        `Reporte de inspección actualizado`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating inspection report:", error);
      res.status(500).json({ message: error.message || "Error al actualizar reporte" });
    }
  });

  // Helper function to filter drafts with all applicable query params
  // Note: Drafts have these fields from basicInfo/locationInfo/media:
  // - title, description, propertyType, price (rentPrice), salePrice, currency
  // - bedrooms, bathrooms, area, location, images, ownerId, approvalStatus
  // Fields NOT in drafts: status (property status), featured, active, published, zones, specific condominium IDs
  const filterDrafts = (drafts: any[], queryParams: any) => {
    let filtered = drafts;
    
    // Text search (applies to: title, description, location)
    if (queryParams.q && typeof queryParams.q === "string") {
      const query = queryParams.q.toLowerCase();
      filtered = filtered.filter(p => 
        p.title?.toLowerCase().includes(query) || 
        p.description?.toLowerCase().includes(query) ||
        p.location?.toLowerCase().includes(query)
      );
    }
    
    // Property type filter
    if (queryParams.propertyType) {
      filtered = filtered.filter(p => p.propertyType === queryParams.propertyType);
    }
    
    // Owner ID filter
    if (queryParams.ownerId) {
      filtered = filtered.filter(p => p.ownerId === queryParams.ownerId);
    }
    
    // Price range filters (check both price and salePrice)
    if (queryParams.minPrice) {
      const minPrice = parseFloat(queryParams.minPrice as string);
      filtered = filtered.filter(p => {
        const rentPrice = parseFloat(p.price || "0");
        const salePrice = parseFloat(p.salePrice || "0");
        // Draft matches if either price meets the minimum
        return rentPrice >= minPrice || salePrice >= minPrice;
      });
    }
    if (queryParams.maxPrice) {
      const maxPrice = parseFloat(queryParams.maxPrice as string);
      filtered = filtered.filter(p => {
        const rentPrice = parseFloat(p.price || "0");
        const salePrice = parseFloat(p.salePrice || "0");
        // If both are 0, filter out. Otherwise check the active price
        if (rentPrice === 0 && salePrice === 0) return false;
        const activePrice = rentPrice > 0 ? rentPrice : salePrice;
        return activePrice <= maxPrice;
      });
    }
    
    // Bedroom/bathroom filters (drafts have these from basicInfo)
    if (queryParams.minBedrooms) {
      const minBed = parseInt(queryParams.minBedrooms as string);
      filtered = filtered.filter(p => (p.bedrooms || 0) >= minBed);
    }
    if (queryParams.maxBedrooms) {
      const maxBed = parseInt(queryParams.maxBedrooms as string);
      filtered = filtered.filter(p => (p.bedrooms || 0) <= maxBed);
    }
    if (queryParams.minBathrooms) {
      const minBath = parseInt(queryParams.minBathrooms as string);
      filtered = filtered.filter(p => (p.bathrooms || 0) >= minBath);
    }
    if (queryParams.maxBathrooms) {
      const maxBath = parseInt(queryParams.maxBathrooms as string);
      filtered = filtered.filter(p => (p.bathrooms || 0) <= maxBath);
    }
    
    // Status filter - drafts don't have property "status" field
    // If status filter is present, exclude ALL drafts (they can never match it)
    if (queryParams.status) {
      filtered = [];
    }
    
    // Virtual tour request filter
    if (queryParams.requestVirtualTour === "true") {
      filtered = filtered.filter(p => p.requestVirtualTour === true);
    }
    
    // Note: approvalStatus filtering is handled upstream (not in filterDrafts)
    // Drafts have approvalStatus "pending_review" when submitted
    
    return filtered;
  };

  // Admin Property Management routes
  app.get("/api/admin/properties", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { approvalStatus, propertyType, status, featured, q, ownerId, requestVirtualTour } = req.query;
      
      // Get all other query params to detect complex filters
      const allQueryKeys = Object.keys(req.query);
      
      const filters: any = {};
      
      if (approvalStatus) {
        filters.approvalStatus = approvalStatus;
      }
      if (propertyType) {
        filters.propertyType = propertyType;
      }
      if (status) {
        filters.status = status;
      }
      if (featured !== undefined) {
        filters.featured = featured === "true";
      }
      if (q && typeof q === "string") {
        filters.query = q;
      }
      if (requestVirtualTour === "true") {
        filters.requestVirtualTour = true;
      }
      
      // Get real properties
      const properties = await storage.searchPropertiesAdvanced(filters);
      
      // Only include drafts when appropriate based on filters
      let allProperties = [...properties];
      
      // Check if drafts should be included based on approvalStatus
      const shouldIncludeDraftsByApprovalStatus = (
        !approvalStatus ||              // No filter = show all
        approvalStatus === "pending_review" ||  // Pending review includes submitted drafts
        approvalStatus === "draft"       // Drafts
      );
      
      // Detect filters that drafts cannot satisfy
      // Drafts DON'T have: zones, specific condominium IDs, published/active states
      // Drafts DO have: price, bedrooms, bathrooms, propertyType, ownerId, location, etc.
      const hasUnsatisfiableFilters = (
        featured === "true" ||  // Drafts are never featured=true
        allQueryKeys.some(key => [
          'zone', 'zones', 'condominium', 'condominiumId',
          'published', 'active'
        ].includes(key))
      );
      
      // Only include drafts if:
      // 1. Approval status allows it AND
      // 2. No unsatisfiable filters AND
      // 3. Not explicitly filtering by status (unless looking for pending_review/draft approvals)
      const canIncludeDrafts = (
        shouldIncludeDraftsByApprovalStatus &&
        !hasUnsatisfiableFilters &&
        (!status || approvalStatus === "pending_review" || approvalStatus === "draft")
      );
      
      if (canIncludeDrafts) {
        // Get submitted drafts (pending approval) only if showing pending_review or all
        const submittedDrafts = (approvalStatus === "pending_review" || !approvalStatus)
          ? await storage.getPropertySubmissionDrafts({ status: "submitted" })
          : [];
        
        // Get draft status drafts only if showing drafts or all
        const draftStatusDrafts = (approvalStatus === "draft" || !approvalStatus)
          ? await storage.getPropertySubmissionDrafts({ status: "draft" })
          : [];
        
        // Collect all unique amenity IDs from all drafts to fetch their names
        const allDrafts = [...submittedDrafts, ...draftStatusDrafts];
        const allAmenityIds = new Set<string>();
        
        for (const draft of allDrafts) {
          const amenities = (draft.details as any)?.propertyAmenities || [];
          for (const amenityId of amenities) {
            if (amenityId) allAmenityIds.add(amenityId);
          }
        }
        
        // Fetch amenity names in batch
        const amenityMap = new Map<string, string>();
        if (allAmenityIds.size > 0) {
          const amenityRecords = await storage.getAmenitiesByIds(Array.from(allAmenityIds));
          for (const amenity of amenityRecords) {
            amenityMap.set(amenity.id, amenity.name);
          }
        }
        
        // Transform drafts to property-like objects
        const transformDraft = (draft: any) => {
          // Expand amenity IDs to names
          const amenityIds = draft.details?.propertyAmenities || [];
          const amenityNames = amenityIds.map((id: string) => amenityMap.get(id) || id).filter((name: string) => name);
          
          // Expand condominium amenity IDs to names
          const condoAmenityIds = draft.details?.condominiumAmenities || [];
          const condoAmenityNames = condoAmenityIds.map((id: string) => amenityMap.get(id) || id).filter((name: string) => name);
          
          // Transform services structure: servicesInfo.basicServices -> includedServices and notIncludedServices
          const basicServices = draft.servicesInfo?.basicServices || {};
          const includedServices: any = {};
          const notIncludedServices: any = {};
          
          // Map basicServices structure to includedServices and notIncludedServices
          const serviceKeys = ['water', 'electricity', 'internet', 'gas'];
          for (const key of serviceKeys) {
            if (basicServices[key]?.included) {
              includedServices[key] = true;
            } else if (basicServices[key]?.cost) {
              // Service is not included but has cost information
              notIncludedServices[key] = {
                cost: basicServices[key].cost,
                provider: basicServices[key].provider || null,
                billingCycle: basicServices[key].billingCycle || null,
              };
            }
          }
          
          return {
            id: `draft-${draft.id}`,
            isDraft: true,
            draftId: draft.id,
            title: draft.basicInfo?.title || draft.basicInfo?.customListingTitle || "Propiedad sin título",
            customListingTitle: draft.basicInfo?.customListingTitle || "",
            description: draft.basicInfo?.description || "",
            propertyType: draft.basicInfo?.propertyType || "house",
            price: draft.basicInfo?.price || "0",
            salePrice: draft.basicInfo?.salePrice || "0",
            currency: draft.basicInfo?.currency || "MXN",
            bedrooms: draft.details?.bedrooms || 0,
            bathrooms: draft.details?.bathrooms || 0,
            area: draft.details?.area || 0,
            location: draft.locationInfo?.address || "",
            colonyName: draft.locationInfo?.colonyName || "",
            condoName: draft.locationInfo?.condoName || "",
            unitNumber: draft.locationInfo?.unitNumber || "",
            googleMapsUrl: draft.locationInfo?.googleMapsUrl || "",
            amenities: amenityNames,
            condominiumAmenities: condoAmenityNames,
            images: draft.media?.images || [],
            primaryImages: draft.media?.primaryImages || [],
            coverImageIndex: draft.media?.coverImageIndex ?? 0,
            secondaryImages: draft.media?.secondaryImages || [],
            videos: draft.media?.videos || [],
            virtualTourUrl: draft.media?.virtualTourUrl || "",
            requestVirtualTour: draft.media?.requestVirtualTour || false,
            includedServices: includedServices,
            notIncludedServices: notIncludedServices,
            acceptedLeaseDurations: draft.servicesInfo?.acceptedLeaseDurations || [],
            accessInfo: draft.accessInfo || null,
            ownerId: draft.userId,
            ownerFirstName: draft.ownerData?.ownerFirstName || "",
            ownerLastName: draft.ownerData?.ownerLastName || "",
            ownerPhone: draft.ownerData?.ownerPhone || "",
            ownerEmail: draft.ownerData?.ownerEmail || "",
            approvalStatus: draft.status === "submitted" ? "pending_review" : "draft",
            ownerStatus: "active",
            published: false,
            active: false,
            featured: false,
            createdAt: draft.createdAt,
            updatedAt: draft.updatedAt,
          };
        };
        
        let submittedDraftProperties = submittedDrafts.map(transformDraft);
        let draftProperties = draftStatusDrafts.map(transformDraft);
        
        // Apply all filters to drafts using the helper
        submittedDraftProperties = filterDrafts(submittedDraftProperties, req.query);
        draftProperties = filterDrafts(draftProperties, req.query);
        
        // Add filtered drafts to the result
        allProperties = [...properties, ...submittedDraftProperties, ...draftProperties];
      }
      
      res.json(allProperties);
    } catch (error) {
      console.error("Error fetching admin properties:", error);
      res.status(500).json({ message: "Error al obtener propiedades" });
    }
  });

  app.get("/api/admin/properties/stats", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const allProperties = await storage.searchPropertiesAdvanced({});
      
      // Get submitted drafts (pending approval)
      const submittedDrafts = await storage.getPropertySubmissionDrafts({ status: "submitted" });
      
      // Get draft status drafts (work in progress)
      const draftStatusDrafts = await storage.getPropertySubmissionDrafts({ status: "draft" });
      
      const stats = {
        total: allProperties.length + submittedDrafts.length + draftStatusDrafts.length,
        pending: allProperties.filter(p => p.approvalStatus === "pending_review").length + submittedDrafts.length,
        approved: allProperties.filter(p => p.approvalStatus === "approved").length,
        rejected: allProperties.filter(p => p.approvalStatus === "rejected").length,
        draft: allProperties.filter(p => p.approvalStatus === "draft").length + draftStatusDrafts.length,
        inspectionScheduled: allProperties.filter(p => p.approvalStatus === "inspection_scheduled").length,
        inspectionCompleted: allProperties.filter(p => p.approvalStatus === "inspection_completed").length,
        published: allProperties.filter(p => p.published).length,
        featured: allProperties.filter(p => p.featured).length,
      };
      
      res.json(stats);
    } catch (error) {
      console.error("Error fetching property stats:", error);
      res.status(500).json({ message: "Error al obtener estadísticas" });
    }
  });

  app.patch("/api/admin/properties/:id/approve", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { notes, publish } = req.body;
      const adminId = req.user.claims.sub;
      
      // Check if this is a draft
      if (id.startsWith("draft-")) {
        const draftId = id.replace("draft-", "");
        const draft = await storage.getPropertySubmissionDraft(draftId);
        
        if (!draft) {
          return res.status(404).json({ message: "Draft no encontrado" });
        }
        
        // Approve draft (this creates the real property)
        const newProperty = await storage.approvePropertySubmissionDraft(draftId, adminId);
        
        // Update property if publish flag is provided
        if (publish !== undefined) {
          await storage.updateProperty(newProperty.id, { published: publish });
        }
        
        await createAuditLog(
          req,
          "approve",
          "property_draft",
          draftId,
          `Draft aprobado y convertido a propiedad: ${draft.basicInfo?.title || 'Sin título'}${notes ? ` - ${notes}` : ""}`
        );
        
        return res.json(newProperty);
      }
      
      // Handle regular property approval
      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      const updated = await storage.updateProperty(id, {
        approvalStatus: "approved",
        published: publish !== false,
      });
      
      await createAuditLog(
        req,
        "approve",
        "property",
        id,
        `Propiedad aprobada: ${getPropertyTitle(property)}${notes ? ` - ${notes}` : ""}`
      );
      
      res.json(updated);
    } catch (error: any) {
      console.error("Error approving property:", error);
      res.status(500).json({ message: error.message || "Error al aprobar propiedad" });
    }
  });

  // New endpoint to publish already approved properties
  app.patch("/api/admin/properties/:id/publish", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const adminId = req.user.claims.sub;
      
      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      // Update to published
      const updated = await storage.updateProperty(id, {
        published: true,
        approvalStatus: "approved", // Ensure it's approved too
      });
      
      await createAuditLog(
        req,
        "publish",
        "property",
        id,
        `Propiedad publicada: ${getPropertyTitle(property)}`
      );
      
      res.json(updated);
    } catch (error: any) {
      console.error("Error publishing property:", error);
      res.status(500).json({ message: error.message || "Error al publicar propiedad" });
    }
  });

  // Endpoint to toggle featured status
  app.patch("/api/admin/properties/:id/featured", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { featured } = req.body;
      const adminId = req.user.claims.sub;
      
      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      const updated = await storage.updateProperty(id, {
        featured: featured,
      });
      
      await createAuditLog(
        req,
        "update",
        "property",
        id,
        `Propiedad ${featured ? 'marcada como destacada' : 'desmarcada como destacada'}: ${property.title}`
      );
      
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating featured status:", error);
      res.status(500).json({ message: error.message || "Error al actualizar estado destacado" });
    }
  });

  app.patch("/api/admin/properties/:id/reject", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { notes } = req.body;
      const adminId = req.user.claims.sub;
      
      // Check if this is a draft
      if (id.startsWith("draft-")) {
        const draftId = id.replace("draft-", "");
        const draft = await storage.getPropertySubmissionDraft(draftId);
        
        if (!draft) {
          return res.status(404).json({ message: "Draft no encontrado" });
        }
        
        // Update draft status to rejected
        const updated = await storage.updatePropertySubmissionDraft(draftId, {
          status: "rejected",
          reviewedBy: adminId,
          reviewedAt: new Date(),
        });
        
        await createAuditLog(
          req,
          "reject",
          "property_draft",
          draftId,
          `Draft rechazado: ${draft.basicInfo?.title || 'Sin título'}${notes ? ` - ${notes}` : ""}`
        );
        
        return res.json(updated);
      }
      
      // Handle regular property rejection
      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      const updated = await storage.updateProperty(id, {
        approvalStatus: "rejected",
        published: false,
      });
      
      await createAuditLog(
        req,
        "reject",
        "property",
        id,
        `Propiedad rechazada: ${getPropertyTitle(property)}${notes ? ` - ${notes}` : ""}`
      );
      
      res.json(updated);
    } catch (error: any) {
      console.error("Error rejecting property:", error);
      res.status(500).json({ message: error.message || "Error al rechazar propiedad" });
    }
  });

  app.patch("/api/admin/properties/bulk-approve", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { propertyIds, publish } = req.body;
      
      if (!Array.isArray(propertyIds) || propertyIds.length === 0) {
        return res.status(400).json({ message: "IDs de propiedades requeridos" });
      }
      
      const results = await Promise.all(
        propertyIds.map(async (id: string) => {
          try {
            const property = await storage.getProperty(id);
            if (!property) return { id, success: false, error: "No encontrada" };
            
            await storage.updateProperty(id, {
              approvalStatus: "approved",
              published: publish !== false,
            });
            
            await createAuditLog(
              req,
              "approve",
              "property",
              id,
              `Propiedad aprobada en masa: ${getPropertyTitle(property)}`
            );
            
            return { id, success: true };
          } catch (error: any) {
            return { id, success: false, error: error.message };
          }
        })
      );
      
      res.json({ results });
    } catch (error: any) {
      console.error("Error in bulk approve:", error);
      res.status(500).json({ message: error.message || "Error al aprobar propiedades" });
    }
  });

  app.patch("/api/admin/properties/bulk-reject", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { propertyIds, notes } = req.body;
      
      if (!Array.isArray(propertyIds) || propertyIds.length === 0) {
        return res.status(400).json({ message: "IDs de propiedades requeridos" });
      }
      
      const results = await Promise.all(
        propertyIds.map(async (id: string) => {
          try {
            const property = await storage.getProperty(id);
            if (!property) return { id, success: false, error: "No encontrada" };
            
            await storage.updateProperty(id, {
              approvalStatus: "rejected",
              published: false,
            });
            
            await createAuditLog(
              req,
              "reject",
              "property",
              id,
              `Propiedad rechazada en masa: ${property.title}${notes ? ` - ${notes}` : ""}`
            );
            
            return { id, success: true };
          } catch (error: any) {
            return { id, success: false, error: error.message };
          }
        })
      );
      
      res.json({ results });
    } catch (error: any) {
      console.error("Error in bulk reject:", error);
      res.status(500).json({ message: error.message || "Error al rechazar propiedades" });
    }
  });

  // Agreement Templates routes (admin only)
  app.get("/api/admin/agreement-templates", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { active } = req.query;
      const filters = active !== undefined ? { active: active === "true" } : {};
      
      const templates = await storage.getAgreementTemplates(filters);
      
      await createAuditLog(
        req,
        "view",
        "agreement_template",
        null,
        `Consultó ${templates.length} plantilla(s) de acuerdo`
      );
      
      res.json(templates);
    } catch (error: any) {
      console.error("Error fetching agreement templates:", error);
      res.status(500).json({ message: error.message || "Error al obtener plantillas" });
    }
  });

  app.get("/api/admin/agreement-templates/:id", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const template = await storage.getAgreementTemplate(id);
      
      if (!template) {
        return res.status(404).json({ message: "Plantilla no encontrada" });
      }
      
      await createAuditLog(
        req,
        "view",
        "agreement_template",
        id,
        `Consultó plantilla de acuerdo "${template.name}"`
      );
      
      res.json(template);
    } catch (error: any) {
      console.error("Error fetching agreement template:", error);
      res.status(500).json({ message: error.message || "Error al obtener plantilla" });
    }
  });

  app.post("/api/admin/agreement-templates", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const validationResult = insertAgreementTemplateSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const template = await storage.createAgreementTemplate(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "agreement_template",
        template.id,
        `Plantilla de acuerdo "${template.name}" creada`
      );

      res.status(201).json(template);
    } catch (error: any) {
      console.error("Error creating agreement template:", error);
      res.status(500).json({ message: error.message || "Error al crear plantilla" });
    }
  });

  app.patch("/api/admin/agreement-templates/:id", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      const validationResult = insertAgreementTemplateSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const existing = await storage.getAgreementTemplate(id);
      if (!existing) {
        return res.status(404).json({ message: "Plantilla no encontrada" });
      }

      const updated = await storage.updateAgreementTemplate(id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "agreement_template",
        id,
        `Plantilla de acuerdo "${updated.name}" actualizada`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating agreement template:", error);
      res.status(500).json({ message: error.message || "Error al actualizar plantilla" });
    }
  });

  app.delete("/api/admin/agreement-templates/:id", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      const existing = await storage.getAgreementTemplate(id);
      if (!existing) {
        return res.status(404).json({ message: "Plantilla no encontrada" });
      }

      await storage.deleteAgreementTemplate(id);

      await createAuditLog(
        req,
        "delete",
        "agreement_template",
        id,
        `Plantilla de acuerdo "${existing.name}" eliminada`
      );

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting agreement template:", error);
      res.status(500).json({ message: error.message || "Error al eliminar plantilla" });
    }
  });

  // Property Submission Draft routes
  app.get("/api/property-submission-drafts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const drafts = await storage.getPropertySubmissionDrafts({ userId });
      res.json(drafts);
    } catch (error: any) {
      console.error("Error fetching property submission drafts:", error);
      res.status(500).json({ message: error.message || "Error al obtener borradores" });
    }
  });

  app.get("/api/property-submission-drafts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      const draft = await storage.getPropertySubmissionDraft(id);
      if (!draft) {
        return res.status(404).json({ message: "Borrador no encontrado" });
      }
      
      if (draft.userId !== userId) {
        return res.status(403).json({ message: "No autorizado" });
      }
      
      res.json(draft);
    } catch (error: any) {
      console.error("Error fetching property submission draft:", error);
      res.status(500).json({ message: error.message || "Error al obtener borrador" });
    }
  });

  // Public endpoint for creating property submission drafts via invitation token
  app.post("/api/public/property-submission-drafts", propertySubmissionLimiter, async (req: any, res) => {
    try {
      const { invitationToken, ...draftData } = req.body;
      
      if (!invitationToken) {
        return res.status(400).json({ message: "Token de invitación requerido" });
      }

      console.log("[DRAFT-CREATE-PUBLIC] Token:", invitationToken.substring(0, 10) + "...");

      // Validate token
      const token = await storage.getPropertySubmissionTokenByToken(invitationToken);
      if (!token) {
        return res.status(404).json({ message: "Token de invitación no encontrado" });
      }

      if (token.used) {
        return res.status(400).json({ message: "Este token ya fue utilizado" });
      }

      if (new Date() > new Date(token.expiresAt)) {
        return res.status(400).json({ message: "El token de invitación ha expirado" });
      }

      // Validate draft data
      const validationResult = insertPropertySubmissionDraftSchema.safeParse({
        ...draftData,
        userId: null, // Public submissions have no userId
        tokenId: token.id // Link draft to token
      });

      if (!validationResult.success) {
        console.error("[DRAFT-CREATE-PUBLIC] Validation failed:", validationResult.error.errors);
        return res.status(400).json({
          message: "Datos inválidos",
          errors: validationResult.error.errors,
          code: "VALIDATION_ERROR"
        });
      }

      // Create draft
      const draft = await storage.createPropertySubmissionDraft(validationResult.data);
      console.log("[DRAFT-CREATE-PUBLIC] Success, Draft ID:", draft.id);

      // SECURITY: Link draft to token but DON'T mark as used yet
      // Token will be marked used only when draft is submitted (status changes to submitted/pending_review)
      await storage.updatePropertySubmissionToken(token.id, {
        propertyDraftId: draft.id
      });

      console.log("[DRAFT-CREATE-PUBLIC] Draft linked to token (token not marked used yet)");

      return res.status(201).json(draft);
    } catch (error: any) {
      console.error("[DRAFT-CREATE-PUBLIC] Error:", error);
      return res.status(500).json({
        message: error.message || "Error al crear borrador",
        code: "INTERNAL_ERROR"
      });
    }
  });

  app.post("/api/property-submission-drafts", propertySubmissionLimiter, isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      console.log("[DRAFT-CREATE] User:", userId, "Step:", req.body.currentStep);
      
      // CRITICAL: Always inject authenticated userId, never trust client
      const validationResult = insertPropertySubmissionDraftSchema.safeParse({
        ...req.body,
        userId // Enforce server-side userId
      });
      
      if (!validationResult.success) {
        console.error("[DRAFT-CREATE] Validation failed:", validationResult.error.errors);
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors,
          code: "VALIDATION_ERROR"
        });
      }

      const draft = await storage.createPropertySubmissionDraft(validationResult.data);
      console.log("[DRAFT-CREATE] Success, ID:", draft.id);
      
      await createAuditLog(
        req,
        "create",
        "property_submission_draft",
        draft.id,
        "Borrador de propiedad creado"
      ).catch(err => console.error("[DRAFT-CREATE] Audit log failed:", err));

      return res.status(201).json(draft);
    } catch (error: any) {
      console.error("[DRAFT-CREATE] Error:", error);
      return res.status(500).json({ 
        message: error.message || "Error al crear borrador",
        code: "INTERNAL_ERROR"
      });
    }
  });

  // Public endpoint for updating property submission drafts via invitation token
  app.patch("/api/public/property-submission-drafts/:id", propertySubmissionLimiter, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { invitationToken, ...draftData } = req.body;

      if (!invitationToken) {
        return res.status(400).json({ message: "Token de invitación requerido" });
      }

      console.log("[DRAFT-UPDATE-PUBLIC] Draft:", id, "Step:", draftData.currentStep);

      // Validate token
      const token = await storage.getPropertySubmissionTokenByToken(invitationToken);
      if (!token) {
        return res.status(404).json({ message: "Token de invitación no encontrado" });
      }

      // SECURITY: Enforce single-use semantics - once token is marked used, no more updates
      if (token.used) {
        return res.status(403).json({ 
          message: "Este token ya fue utilizado y el borrador no puede ser modificado" 
        });
      }

      if (new Date() > new Date(token.expiresAt)) {
        return res.status(400).json({ message: "El token de invitación ha expirado" });
      }

      // SECURITY: Require token to have a linked draft before allowing updates
      // This prevents attackers from using a token to hijack arbitrary drafts
      if (!token.propertyDraftId) {
        return res.status(400).json({ 
          message: "Token no tiene un borrador asociado. Primero crea un borrador." 
        });
      }

      // SECURITY: Verify that the draft ID in the URL matches the token's linked draft
      if (token.propertyDraftId !== id) {
        return res.status(403).json({ 
          message: "No autorizado: este token no está vinculado a este borrador" 
        });
      }

      // Get existing draft
      const existingDraft = await storage.getPropertySubmissionDraft(id);
      if (!existingDraft) {
        return res.status(404).json({ message: "Borrador no encontrado" });
      }

      // Verify that the draft belongs to this token (double-check)
      if (existingDraft.tokenId !== token.id) {
        return res.status(403).json({ message: "No autorizado para modificar este borrador" });
      }

      // SECURITY: Only allow updates if draft is still in "draft" status
      if (existingDraft.status !== "draft") {
        return res.status(403).json({ 
          message: "Este borrador ya fue enviado y no puede ser modificado" 
        });
      }

      // SECURITY: Prevent updates to drafts created more than 48 hours ago
      const draftAge = Date.now() - new Date(existingDraft.createdAt).getTime();
      const MAX_DRAFT_AGE = 48 * 60 * 60 * 1000; // 48 hours
      if (draftAge > MAX_DRAFT_AGE) {
        return res.status(403).json({
          message: "Este borrador ha expirado y no puede ser modificado"
        });
      }

      // Validate input
      const validationResult = insertPropertySubmissionDraftSchema.partial().safeParse(draftData);
      if (!validationResult.success) {
        console.error("[DRAFT-UPDATE-PUBLIC] Validation failed:", validationResult.error.errors);
        return res.status(400).json({
          message: "Datos inválidos",
          errors: validationResult.error.errors,
          code: "VALIDATION_ERROR"
        });
      }

      // Remove server-controlled fields
      const sanitizedData = { ...validationResult.data };
      delete (sanitizedData as any).id;
      delete (sanitizedData as any).userId;
      delete (sanitizedData as any).tokenId;
      delete (sanitizedData as any).createdAt;
      delete (sanitizedData as any).updatedAt;
      delete (sanitizedData as any).propertyId;
      delete (sanitizedData as any).reviewedBy;
      delete (sanitizedData as any).reviewedAt;

      // Update draft
      const updated = await storage.updatePropertySubmissionDraft(id, sanitizedData);

      if (!updated) {
        console.error("[DRAFT-UPDATE-PUBLIC] Draft not found or storage returned null");
        return res.status(404).json({
          message: "Borrador no encontrado",
          code: "DRAFT_NOT_FOUND"
        });
      }

      console.log("[DRAFT-UPDATE-PUBLIC] Success, updated step:", updated.currentStep);

      // SECURITY: If draft status changed to "submitted", mark token as used
      if (updated.status === "submitted" && !token.used) {
        await storage.updatePropertySubmissionToken(token.id, {
          used: true,
          usedAt: new Date()
        });
        console.log("[DRAFT-UPDATE-PUBLIC] Token marked as used after submission");
      }

      return res.json(updated);
    } catch (error: any) {
      console.error("[DRAFT-UPDATE-PUBLIC] Error:", error);
      return res.status(500).json({
        message: error.message || "Error al actualizar borrador",
        code: "INTERNAL_ERROR"
      });
    }
  });

  app.patch("/api/property-submission-drafts/:id", propertySubmissionLimiter, isAuthenticated, requireResourceOwnership('property-draft', 'userId'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;

      console.log("[DRAFT-UPDATE] User:", userId, "Draft:", id, "Step:", req.body.currentStep);

      // Validate input but DO NOT include userId from request body
      const validationResult = insertPropertySubmissionDraftSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        console.error("[DRAFT-UPDATE] Validation failed:", validationResult.error.errors);
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors,
          code: "VALIDATION_ERROR"
        });
      }

      // Remove ALL server-controlled fields to prevent unauthorized mutation
      const sanitizedData = { ...validationResult.data };
      delete sanitizedData.userId; // Remove client-provided userId first
      delete (sanitizedData as any).id;
      delete (sanitizedData as any).createdAt;
      delete (sanitizedData as any).updatedAt;
      delete (sanitizedData as any).propertyId;
      delete (sanitizedData as any).reviewedBy;
      delete (sanitizedData as any).reviewedAt;

      // CRITICAL: Re-inject authenticated userId to ensure ownership validation succeeds
      sanitizedData.userId = userId;

      // Attempt update with authenticated userId
      const updated = await storage.updatePropertySubmissionDraft(id, sanitizedData);
      
      if (!updated) {
        console.error("[DRAFT-UPDATE] Draft not found or storage returned null");
        return res.status(404).json({ 
          message: "Borrador no encontrado",
          code: "DRAFT_NOT_FOUND"
        });
      }

      console.log("[DRAFT-UPDATE] Success, updated step:", updated.currentStep);
      
      await createAuditLog(
        req,
        "update",
        "property_submission_draft",
        id,
        `Borrador actualizado - Paso ${updated.currentStep}`
      ).catch(err => console.error("[DRAFT-UPDATE] Audit log failed:", err));

      return res.json(updated);
    } catch (error: any) {
      console.error("[DRAFT-UPDATE] Storage error:", error);
      // Provide structured error responses
      if (error.message?.includes("not found")) {
        return res.status(404).json({ 
          message: "Borrador no encontrado",
          code: "DRAFT_NOT_FOUND"
        });
      }
      if (error.message?.includes("permission")) {
        return res.status(403).json({ 
          message: "No tienes permiso para modificar este borrador",
          code: "PERMISSION_DENIED"
        });
      }
      return res.status(500).json({ 
        message: error.message || "Error al actualizar borrador",
        code: "INTERNAL_ERROR"
      });
    }
  });

  app.delete("/api/property-submission-drafts/:id", isAuthenticated, requireResourceOwnership('property-draft', 'userId'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;

      await storage.deletePropertySubmissionDraft(id);
      
      await createAuditLog(
        req,
        "delete",
        "property_submission_draft",
        id,
        "Borrador de propiedad eliminado"
      );

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting property submission draft:", error);
      res.status(500).json({ message: error.message || "Error al eliminar borrador" });
    }
  });

  // Admin-only: Approve property submission draft and create property
  app.post("/api/property-submission-drafts/:id/approve", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { skipDocumentCheck } = req.body; // Allow admin to force approve without documents
      let adminId: string;

      // Get adminId from session (admin_users) or from user claims (regular users with admin role)
      if (req.session?.adminUser) {
        adminId = req.session.adminUser.id;
      } else {
        adminId = req.user.claims.sub;
      }
      
      // Approve the draft and create property
      const property = await storage.approvePropertySubmissionDraft(id, adminId);
      
      // Check if documents are complete and validated (unless skipped)
      if (!skipDocumentCheck) {
        const documentStatus = await storage.checkPropertyDocumentsComplete(property.id);
        
        if (!documentStatus.complete) {
          await createAuditLog(
            req,
            "approve",
            "property_submission_draft",
            id,
            `Propiedad creada pero documentos incompletos. Faltantes: ${documentStatus.missing.join(', ')}`
          );
          
          return res.status(201).json({
            message: "Propiedad creada pero faltan documentos requeridos",
            property,
            warning: true,
            documentStatus,
          });
        }
        
        if (!documentStatus.validated) {
          await createAuditLog(
            req,
            "approve",
            "property_submission_draft",
            id,
            `Propiedad creada pero documentos sin validar. Sin validar: ${documentStatus.unvalidated.join(', ')}`
          );
          
          return res.status(201).json({
            message: "Propiedad creada pero documentos pendientes de validación",
            property,
            warning: true,
            documentStatus,
          });
        }
      }
      
      await createAuditLog(
        req,
        "approve",
        "property_submission_draft",
        id,
        `Borrador aprobado, propiedad creada: ${property.id}`
      );

      res.status(201).json({
        message: "Propiedad aprobada y creada exitosamente",
        property,
      });
    } catch (error: any) {
      console.error("Error approving property submission draft:", error);
      res.status(500).json({ message: error.message || "Error al aprobar borrador" });
    }
  });

  // Property Submission Token routes (for inviting owners without account)
  
  // Generate a cryptographically secure random token
  function generateSecureToken(): string {
    // Generate professional short code: PROP-XXXXXXXX (13 characters)
    // Using uppercase alphanumeric (excluding confusing chars: 0, O, I, 1, l)
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 8; i++) {
      const randomIndex = Math.floor(Math.random() * chars.length);
      code += chars[randomIndex];
    }
    return `PROP-${code}`;
  }

  // Admin: Create property submission token
  app.post("/api/admin/property-tokens", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { inviteeEmail, inviteePhone, inviteeName, notes } = req.body;
      
      // CRITICAL: Ensure admin exists in users table for foreign key constraint
      // This must succeed before creating the token to avoid FK violations
      await storage.upsertUser({
        id: adminId,
        email: req.user.claims.email,
        firstName: req.user.claims.first_name || "Admin",
        lastName: req.user.claims.last_name || "User",
        role: "admin",
      });
      
      // Generate secure token
      const token = generateSecureToken();
      
      // Set expiration to 24 hours from now
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24);
      
      // Create token in database
      const tokenRecord = await storage.createPropertySubmissionToken({
        token,
        createdBy: adminId,
        expiresAt,
        used: false,
        inviteeEmail: inviteeEmail || null,
        inviteePhone: inviteePhone || null,
        inviteeName: inviteeName || null,
        notes: notes || null,
      });
      
      await createAuditLog(
        req,
        "create",
        "property_submission_token",
        tokenRecord.id,
        `Token de invitación creado${inviteeName ? ` para ${inviteeName}` : ''}${inviteeEmail ? ` (${inviteeEmail})` : ''}`
      );
      
      // Return token with full URL
      const baseUrl = req.protocol + '://' + req.get('host');
      const inviteUrl = `${baseUrl}/submit-property/${token}`;
      
      res.status(201).json({
        ...tokenRecord,
        inviteUrl,
      });
    } catch (error: any) {
      console.error("Error creating property submission token:", error);
      res.status(500).json({ message: error.message || "Error al crear token de invitación" });
    }
  });

  // Admin: List property submission tokens
  app.get("/api/admin/property-tokens", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      // Get all tokens (admin can see all tokens, not just their own)
      const tokens = await storage.getPropertySubmissionTokens({});
      
      // Add inviteUrl and status to each token
      const baseUrl = req.protocol + '://' + req.get('host');
      const tokensWithUrls = tokens.map(token => {
        const inviteUrl = `${baseUrl}/submit-property/${token.token}`;
        const now = new Date();
        const isExpired = now > token.expiresAt;
        const status = token.used ? 'used' : (isExpired ? 'expired' : 'pending');
        
        return {
          ...token,
          inviteUrl,
          status,
        };
      });
      
      res.json(tokensWithUrls);
    } catch (error: any) {
      console.error("Error fetching property submission tokens:", error);
      res.status(500).json({ message: error.message || "Error al obtener tokens" });
    }
  });

  // Admin: Delete property submission token
  app.delete("/api/admin/property-tokens/:id", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify token exists
      const existingToken = await storage.getPropertySubmissionToken(id);
      if (!existingToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }
      
      // Delete the token
      await storage.deletePropertySubmissionToken(id);
      
      await createAuditLog(
        req,
        "delete",
        "property_submission_token",
        id,
        `Token de invitación eliminado${existingToken.inviteeName ? ` (${existingToken.inviteeName})` : ''}`
      );
      
      res.json({ message: "Token eliminado exitosamente" });
    } catch (error: any) {
      console.error("Error deleting property submission token:", error);
      res.status(500).json({ message: error.message || "Error al eliminar el token" });
    }
  });

  // Admin: Regenerate property submission token
  app.post("/api/admin/property-tokens/:id/regenerate", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const adminId = req.user.claims.sub;
      
      // Get existing token
      const existingToken = await storage.getPropertySubmissionToken(id);
      if (!existingToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }
      
      // CRITICAL: Ensure admin exists in users table for foreign key constraint
      // This must succeed before creating the token to avoid FK violations
      await storage.upsertUser({
        id: adminId,
        email: req.user.claims.email,
        firstName: req.user.claims.first_name || "Admin",
        lastName: req.user.claims.last_name || "User",
        role: "admin",
      });
      
      // Delete old token
      await storage.deletePropertySubmissionToken(id);
      
      // Generate new secure token
      const token = generatePropertyToken();
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now
      
      // Create new token with same info
      const newTokenRecord = await storage.createPropertySubmissionToken({
        token,
        createdBy: adminId,
        expiresAt,
        inviteeEmail: existingToken.inviteeEmail,
        inviteePhone: existingToken.inviteePhone,
        inviteeName: existingToken.inviteeName,
        notes: existingToken.notes,
      });
      
      await createAuditLog(
        req,
        "update",
        "property_submission_token",
        newTokenRecord.id,
        `Token de invitación regenerado${existingToken.inviteeName ? ` para ${existingToken.inviteeName}` : ''}`
      );
      
      // Return new token with full URL
      const baseUrl = req.protocol + '://' + req.get('host');
      const inviteUrl = `${baseUrl}/submit-property/${token}`;
      
      res.status(201).json({
        ...newTokenRecord,
        inviteUrl,
      });
    } catch (error: any) {
      console.error("Error regenerating property submission token:", error);
      res.status(500).json({ message: error.message || "Error al regenerar el token" });
    }
  });

  // Public: Validate property submission token
  app.get("/api/property-tokens/:token/validate", async (req, res) => {
    try {
      const { token } = req.params;
      
      const tokenRecord = await storage.getPropertySubmissionTokenByToken(token);
      
      if (!tokenRecord) {
        return res.status(404).json({ 
          valid: false,
          message: "Token no encontrado" 
        });
      }
      
      // Check if token is already used
      if (tokenRecord.used) {
        return res.status(400).json({ 
          valid: false,
          message: "Este enlace ya fue utilizado" 
        });
      }
      
      // Check if token is expired
      if (new Date() > tokenRecord.expiresAt) {
        return res.status(400).json({ 
          valid: false,
          message: "Este enlace ha expirado" 
        });
      }
      
      // Token is valid
      res.json({ 
        valid: true,
        inviteeName: tokenRecord.inviteeName,
        inviteeEmail: tokenRecord.inviteeEmail,
        inviteePhone: tokenRecord.inviteePhone,
        expiresAt: tokenRecord.expiresAt,
      });
    } catch (error: any) {
      console.error("Error validating property submission token:", error);
      res.status(500).json({ message: error.message || "Error al validar token" });
    }
  });

  // Get draft linked to invitation token
  app.get("/api/property-tokens/:token/draft", async (req, res) => {
    try {
      const { token } = req.params;
      
      const tokenRecord = await storage.getPropertySubmissionTokenByToken(token);
      
      if (!tokenRecord) {
        return res.status(404).json({ message: "Token no encontrado" });
      }
      
      // Check if token has a linked draft
      if (!tokenRecord.propertyDraftId) {
        return res.status(404).json({ message: "No hay borrador vinculado a este token" });
      }
      
      // Get the draft
      const draft = await storage.getPropertySubmissionDraft(tokenRecord.propertyDraftId);
      
      if (!draft) {
        return res.status(404).json({ message: "Borrador no encontrado" });
      }
      
      res.json(draft);
    } catch (error: any) {
      console.error("Error fetching draft for token:", error);
      res.status(500).json({ message: error.message || "Error al obtener borrador" });
    }
  });

  // Property Agreement routes
  app.get("/api/property-agreements/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      const agreement = await storage.getPropertyAgreement(id);
      if (!agreement) {
        return res.status(404).json({ message: "Acuerdo no encontrado" });
      }
      
      if (agreement.userId !== userId) {
        return res.status(403).json({ message: "No autorizado" });
      }
      
      res.json(agreement);
    } catch (error: any) {
      console.error("Error fetching property agreement:", error);
      res.status(500).json({ message: error.message || "Error al obtener acuerdo" });
    }
  });

  app.post("/api/property-agreements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const validationResult = insertPropertyAgreementSchema.safeParse({
        ...req.body,
        userId
      });
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const agreement = await storage.createPropertyAgreement(validationResult.data);
      
      await createAuditLog(
        req,
        "create",
        "property_agreement",
        agreement.id,
        "Acuerdo de propiedad creado"
      );

      res.status(201).json(agreement);
    } catch (error: any) {
      console.error("Error creating property agreement:", error);
      res.status(500).json({ message: error.message || "Error al crear acuerdo" });
    }
  });

  app.post("/api/property-agreements/:id/sign", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const { signerName } = req.body;
      
      if (!signerName) {
        return res.status(400).json({ message: "Se requiere el nombre del firmante" });
      }
      
      const agreement = await storage.getPropertyAgreement(id);
      if (!agreement) {
        return res.status(404).json({ message: "Acuerdo no encontrado" });
      }
      
      if (agreement.userId !== userId) {
        return res.status(403).json({ message: "No autorizado" });
      }
      
      if (agreement.status === "signed") {
        return res.status(400).json({ message: "Este acuerdo ya ha sido firmado" });
      }
      
      const signerIp = req.ip || req.socket.remoteAddress || "unknown";
      const signed = await storage.signPropertyAgreement(id, signerName, signerIp);
      
      await createAuditLog(
        req,
        "update",
        "property_agreement",
        id,
        `Acuerdo firmado por ${signerName}`
      );

      res.json(signed);
    } catch (error: any) {
      console.error("Error signing property agreement:", error);
      res.status(500).json({ message: error.message || "Error al firmar acuerdo" });
    }
  });

  // Get user's property agreements (contracts)
  app.get("/api/property-agreements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const agreements = await storage.getPropertyAgreements({ userId });
      res.json(agreements);
    } catch (error: any) {
      console.error("Error fetching property agreements:", error);
      res.status(500).json({ message: error.message || "Error al obtener contratos" });
    }
  });

  // Sidebar Menu Visibility Configuration routes
  // Admin: Get sidebar configuration for a role
  app.get("/api/admin/sidebar-config/:role", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { role } = req.params;
      
      const config = await storage.getSidebarMenuVisibility(role);
      res.json(config);
    } catch (error: any) {
      console.error("Error fetching sidebar config:", error);
      res.status(500).json({ message: error.message || "Error al obtener configuración del sidebar" });
    }
  });

  // Admin: Update sidebar configuration in bulk
  app.post("/api/admin/sidebar-config", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { configurations } = req.body;
      
      if (!Array.isArray(configurations)) {
        return res.status(400).json({ message: "Se requiere un array de configuraciones" });
      }
      
      const results = await storage.bulkSetSidebarMenuVisibility(configurations);
      
      await createAuditLog(
        req,
        "update",
        "sidebar_menu_visibility",
        null,
        `Configuración del sidebar actualizada para ${configurations.length} items`
      );
      
      res.json(results);
    } catch (error: any) {
      console.error("Error updating sidebar config:", error);
      res.status(500).json({ message: error.message || "Error al actualizar configuración del sidebar" });
    }
  });

  // Admin: Reset sidebar configuration for a role
  app.delete("/api/admin/sidebar-config/:role", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { role } = req.params;
      
      await storage.resetSidebarMenuVisibility(role);
      
      await createAuditLog(
        req,
        "delete",
        "sidebar_menu_visibility",
        null,
        `Configuración del sidebar reseteada para rol ${role}`
      );
      
      res.json({ message: "Configuración reseteada exitosamente" });
    } catch (error: any) {
      console.error("Error resetting sidebar config:", error);
      res.status(500).json({ message: error.message || "Error al resetear configuración del sidebar" });
    }
  });

  // System Settings routes
  // Admin: Get a specific system setting
  app.get("/api/admin/system-settings/:key", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { key } = req.params;
      const setting = await storage.getSystemSetting(key);
      if (!setting) {
        return res.status(404).json({ message: "Configuración no encontrada" });
      }
      res.json(setting);
    } catch (error: any) {
      console.error("Error fetching system setting:", error);
      res.status(500).json({ message: error.message || "Error al obtener configuración" });
    }
  });

  // Admin: Get all system settings
  app.get("/api/admin/system-settings", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const settings = await storage.getAllSystemSettings();
      res.json(settings);
    } catch (error: any) {
      console.error("Error fetching system settings:", error);
      res.status(500).json({ message: error.message || "Error al obtener configuraciones" });
    }
  });

  // Admin: Update a system setting
  app.put("/api/admin/system-settings/:key", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { key } = req.params;
      const { value } = req.body;

      if (!value) {
        return res.status(400).json({ message: "El valor es requerido" });
      }

      const setting = await storage.updateSystemSetting(key, value);

      await createAuditLog(
        req,
        "update",
        "system_settings",
        key,
        `Configuración ${key} actualizada a ${value}`
      );

      res.json(setting);
    } catch (error: any) {
      console.error("Error updating system setting:", error);
      res.status(500).json({ message: error.message || "Error al actualizar configuración" });
    }
  });

  // Sidebar Menu Visibility Configuration routes (user-based)
  // Admin: Get users by role
  app.get("/api/admin/users-by-role/:role", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { role } = req.params;
      const users = await storage.getUsersByRole(role);
      res.json(users);
    } catch (error: any) {
      console.error("Error fetching users by role:", error);
      res.status(500).json({ message: error.message || "Error al obtener usuarios" });
    }
  });

  // Admin: Get sidebar configuration for a specific user
  app.get("/api/admin/sidebar-config-user/:userId", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const config = await storage.getSidebarMenuVisibilityByUser(userId);
      res.json(config);
    } catch (error: any) {
      console.error("Error fetching user sidebar config:", error);
      res.status(500).json({ message: error.message || "Error al obtener configuración del usuario" });
    }
  });

  // Admin: Update sidebar configuration for a specific user
  app.post("/api/admin/sidebar-config-user/:userId", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { configurations } = req.body;
      
      if (!Array.isArray(configurations)) {
        return res.status(400).json({ message: "Se requiere un array de configuraciones" });
      }
      
      const results = await storage.bulkSetSidebarMenuVisibilityUser(userId, configurations);
      
      await createAuditLog(
        req,
        "update",
        "sidebar_menu_visibility_user",
        userId,
        `Configuración del sidebar actualizada para usuario ${userId}, ${configurations.length} items`
      );
      
      res.json(results);
    } catch (error: any) {
      console.error("Error updating user sidebar config:", error);
      res.status(500).json({ message: error.message || "Error al actualizar configuración del usuario" });
    }
  });

  // Admin: Reset sidebar configuration for a specific user
  app.delete("/api/admin/sidebar-config-user/:userId", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      await storage.resetSidebarMenuVisibilityUser(userId);
      
      await createAuditLog(
        req,
        "delete",
        "sidebar_menu_visibility_user",
        userId,
        `Configuración del sidebar reseteada para usuario ${userId}`
      );
      
      res.json({ message: "Configuración de usuario reseteada exitosamente" });
    } catch (error: any) {
      console.error("Error resetting user sidebar config:", error);
      res.status(500).json({ message: error.message || "Error al resetear configuración del usuario" });
    }
  });

  // Rental Opportunity Requests (SOR) routes
  app.post("/api/rental-opportunity-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { propertyId, desiredMoveInDate, preferredContactMethod, notes } = req.body;

      // Verificar límite de SORs activas (máximo 3)
      const activeSORs = await db
        .select()
        .from(rentalOpportunityRequests)
        .where(
          and(
            eq(rentalOpportunityRequests.userId, userId),
            inArray(rentalOpportunityRequests.status, ["pending", "scheduled_visit"])
          )
        );

      if (activeSORs.length >= 3) {
        return res.status(400).json({ 
          error: "Ya tienes 3 solicitudes activas. Espera a que se procesen antes de crear una nueva." 
        });
      }

      // Crear SOR
      const [newSOR] = await db
        .insert(rentalOpportunityRequests)
        .values({
          propertyId,
          userId,
          desiredMoveInDate: desiredMoveInDate || null,
          preferredContactMethod: preferredContactMethod || "email",
          notes: notes || null,
          status: "pending",
        })
        .returning();

      // Registrar acción en lead_journeys
      await db.insert(leadJourneys).values({
        propertyId,
        userId,
        action: "request_opportunity",
      });

      res.json(newSOR);
    } catch (error: any) {
      console.error("Error creating rental opportunity request:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/rental-opportunity-requests/active-count", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const activeSORs = await db
        .select()
        .from(rentalOpportunityRequests)
        .where(
          and(
            eq(rentalOpportunityRequests.userId, userId),
            inArray(rentalOpportunityRequests.status, ["pending", "scheduled_visit"])
          )
        );

      res.json({ count: activeSORs.length });
    } catch (error: any) {
      console.error("Error getting active SOR count:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/rental-opportunity-requests/by-property/:propertyId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { propertyId } = req.params;

      const existingSOR = await db
        .select()
        .from(rentalOpportunityRequests)
        .where(
          and(
            eq(rentalOpportunityRequests.userId, userId),
            eq(rentalOpportunityRequests.propertyId, propertyId),
            inArray(rentalOpportunityRequests.status, ["pending", "scheduled_visit"])
          )
        )
        .limit(1);

      res.json(existingSOR[0] || null);
    } catch (error: any) {
      console.error("Error checking existing SOR:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Get user's SORs with property and appointment details
  app.get("/api/my-rental-opportunities", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const sorsWithDetails = await db
        .select({
          id: rentalOpportunityRequests.id,
          userId: rentalOpportunityRequests.userId,
          propertyId: rentalOpportunityRequests.propertyId,
          status: rentalOpportunityRequests.status,
          notes: rentalOpportunityRequests.notes,
          desiredMoveInDate: rentalOpportunityRequests.desiredMoveInDate,
          preferredContactMethod: rentalOpportunityRequests.preferredContactMethod,
          createdAt: rentalOpportunityRequests.createdAt,
          updatedAt: rentalOpportunityRequests.updatedAt,
        })
        .from(rentalOpportunityRequests)
        .where(eq(rentalOpportunityRequests.userId, userId))
        .orderBy(rentalOpportunityRequests.createdAt);

      // Enrich with property, appointment, and offer data
      const enrichedSORs = await Promise.all(
        sorsWithDetails.map(async (sor) => {
          const property = await storage.getProperty(sor.propertyId);
          
          // Get appointment if status is scheduled_visit
          let appointment = null;
          if (sor.status === "scheduled_visit") {
            const appointments = await storage.getAppointments();
            appointment = appointments.find(
              (apt) => apt.opportunityRequestId === sor.id
            );
          }

          // Get offer if status indicates offer was submitted
          let offer = null;
          if (["offer_submitted", "offer_negotiation", "offer_accepted"].includes(sor.status)) {
            const [foundOffer] = await db
              .select()
              .from(offers)
              .where(eq(offers.opportunityRequestId, sor.id))
              .limit(1);
            offer = foundOffer || null;
          }

          return {
            ...sor,
            property,
            appointment,
            offer,
          };
        })
      );

      res.json(enrichedSORs);
    } catch (error: any) {
      console.error("Error fetching user SORs:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Schedule visit from SOR
  app.post("/api/rental-opportunity-requests/:sorId/schedule-visit", isAuthenticated, async (req: any, res) => {
    let googleEventId: string | null = null;
    
    try {
      const userId = req.user.claims.sub;
      const { sorId } = req.params;
      const { date, type, notes } = req.body;

      // Verificar que la SOR existe y pertenece al usuario
      const [sor] = await db
        .select()
        .from(rentalOpportunityRequests)
        .where(
          and(
            eq(rentalOpportunityRequests.id, sorId),
            eq(rentalOpportunityRequests.userId, userId)
          )
        )
        .limit(1);

      if (!sor) {
        return res.status(404).json({ error: "Solicitud de oportunidad no encontrada" });
      }

      if (sor.status !== "pending") {
        return res.status(400).json({ 
          error: "Esta solicitud ya tiene una visita programada o ha sido procesada" 
        });
      }

      // Preparar datos del appointment
      let meetLink: string | null = null;

      // Crear evento de Google Meet si es video
      if (type === "video") {
        const property = await storage.getProperty(sor.propertyId);
        const appointmentDate = new Date(date);
        const endDate = new Date(appointmentDate.getTime() + 60 * 60 * 1000);

        try {
          const eventResult = await createGoogleMeetEvent({
            summary: `Visita Virtual: ${property?.title || "Propiedad"}`,
            description: `Visita virtual programada desde solicitud de oportunidad`,
            start: appointmentDate,
            end: endDate,
            attendees: [],
          });

          if (eventResult) {
            meetLink = eventResult.meetLink;
            googleEventId = eventResult.eventId;
          }
        } catch (meetError) {
          console.error("Error creating Google Meet event:", meetError);
          // Continue without meet link if event creation fails
        }
      }

      try {
        // Crear appointment
        const [appointment] = await db
          .insert(appointments)
          .values({
            propertyId: sor.propertyId,
            clientId: userId,
            opportunityRequestId: sorId,
            date: new Date(date),
            type,
            status: "pending",
            meetLink,
            googleEventId,
            notes: notes || null,
          })
          .returning();

        // Actualizar estado de SOR a scheduled_visit
        await db
          .update(rentalOpportunityRequests)
          .set({ 
            status: "scheduled_visit",
            updatedAt: new Date()
          })
          .where(eq(rentalOpportunityRequests.id, sorId));

        // Registrar en lead_journeys
        await db.insert(leadJourneys).values({
          propertyId: sor.propertyId,
          userId,
          action: "view_layer2", // Visita programada
          metadata: { appointmentId: appointment.id, sorId },
        });

        res.json(appointment);
      } catch (dbError) {
        // Rollback: Delete Google Meet event if any DB operation fails
        if (googleEventId) {
          try {
            await deleteGoogleMeetEvent(googleEventId);
            console.log(`Rolled back Google Meet event ${googleEventId} due to database operation failure`);
          } catch (rollbackError) {
            console.error("Error rolling back Google Meet event:", rollbackError);
          }
        }
        throw dbError;
      }
    } catch (error: any) {
      return handleGenericError(res, error, "al programar la visita desde SOR");
    }
  });

  // Submit offer from SOR (after visit completed)
  app.post("/api/rental-opportunity-requests/:sorId/submit-offer", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { sorId } = req.params;
      
      // Validar con Zod
      const offerSchema = z.object({
        offerAmount: z.string().min(1).refine((val) => parseFloat(val) > 0, {
          message: "El monto de la oferta debe ser mayor a 0",
        }),
        notes: z.string().optional(),
      });

      const validationResult = offerSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          error: "Datos inválidos",
          details: validationResult.error.errors 
        });
      }

      const { offerAmount, notes } = validationResult.data;

      // Verificar que la SOR existe y pertenece al usuario
      const [sor] = await db
        .select()
        .from(rentalOpportunityRequests)
        .where(
          and(
            eq(rentalOpportunityRequests.id, sorId),
            eq(rentalOpportunityRequests.userId, userId)
          )
        )
        .limit(1);

      if (!sor) {
        return res.status(404).json({ error: "Solicitud de oportunidad no encontrada" });
      }

      // Verificar que la visita ya se completó
      if (sor.status !== "visit_completed" && sor.status !== "scheduled_visit") {
        return res.status(400).json({ 
          error: "Debes completar la visita antes de hacer una oferta" 
        });
      }

      // Verificar que no exista ya una oferta para esta SOR
      const [existingOffer] = await db
        .select()
        .from(offers)
        .where(eq(offers.opportunityRequestId, sorId))
        .limit(1);

      if (existingOffer) {
        return res.status(400).json({ 
          error: "Ya existe una oferta para esta solicitud" 
        });
      }

      // Buscar el appointment asociado
      const [appointment] = await db
        .select()
        .from(appointments)
        .where(eq(appointments.opportunityRequestId, sorId))
        .limit(1);

      // Crear la oferta
      const [offer] = await db
        .insert(offers)
        .values({
          opportunityRequestId: sorId,
          propertyId: sor.propertyId,
          clientId: userId,
          appointmentId: appointment?.id || null,
          offerAmount: offerAmount.toString(),
          status: "pending",
          notes: notes || null,
        })
        .returning();

      // Actualizar estado de SOR a offer_submitted
      await db
        .update(rentalOpportunityRequests)
        .set({ 
          status: "offer_submitted",
          updatedAt: new Date()
        })
        .where(eq(rentalOpportunityRequests.id, sorId));

      // Registrar en lead_journeys
      await db.insert(leadJourneys).values({
        propertyId: sor.propertyId,
        userId,
        action: "submit_offer",
        metadata: { offerId: offer.id, sorId, offerAmount },
      });

      // Log offer creation
      await createAuditLog(
        req,
        "create",
        "offer",
        offer.id,
        `Oferta creada de $${offer.offerAmount} para propiedad ${sor.propertyId}`
      );

      res.status(201).json(offer);
    } catch (error: any) {
      console.error("Error submitting offer from SOR:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Get interested clients for owner's properties (with limited info - no contact details)
  app.get("/api/owner/interested-clients", isAuthenticated, requireRole(["owner"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      // Get all properties owned by this user
      const ownerProperties = await db
        .select({ id: properties.id })
        .from(properties)
        .where(eq(properties.ownerId, userId));

      if (ownerProperties.length === 0) {
        return res.json([]);
      }

      const propertyIds = ownerProperties.map(p => p.id);

      // Get all rental opportunity requests for these properties
      const interestedClients = await db
        .select({
          id: rentalOpportunityRequests.id,
          status: rentalOpportunityRequests.status,
          desiredMoveInDate: rentalOpportunityRequests.desiredMoveInDate,
          createdAt: rentalOpportunityRequests.createdAt,
          notes: rentalOpportunityRequests.notes,
          propertyId: rentalOpportunityRequests.propertyId,
          propertyTitle: properties.title,
          propertyLocation: properties.location,
          propertyPrice: properties.price,
          // Limited client info - NO CONTACT DETAILS
          clientId: users.id,
          clientFirstName: users.firstName,
          clientLastName: users.lastName,
          // Presentation card info if exists
          presentationCardId: presentationCards.id,
          cardPropertyType: presentationCards.propertyType,
          cardModality: presentationCards.modality,
          cardMinPrice: presentationCards.minPrice,
          cardMaxPrice: presentationCards.maxPrice,
        })
        .from(rentalOpportunityRequests)
        .innerJoin(properties, eq(rentalOpportunityRequests.propertyId, properties.id))
        .innerJoin(users, eq(rentalOpportunityRequests.userId, users.id))
        .leftJoin(presentationCards, eq(users.id, presentationCards.clientId))
        .where(inArray(rentalOpportunityRequests.propertyId, propertyIds))
        .orderBy(desc(rentalOpportunityRequests.createdAt));

      res.json(interestedClients);
    } catch (error: any) {
      console.error("Error getting interested clients:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Counter offer endpoint (for property owner/admin)
  app.post("/api/offers/:offerId/counter", isAuthenticated, requireRole(["admin", "propietario", "vendedor"]), async (req: any, res) => {
    try {
      const { offerId } = req.params;
      const { counterOfferAmount, counterOfferNotes } = req.body;

      // Validar el monto de la contraoferta
      if (!counterOfferAmount || parseFloat(counterOfferAmount) <= 0) {
        return res.status(400).json({ error: "El monto de la contraoferta debe ser mayor a 0" });
      }

      // Buscar la oferta
      const [existingOffer] = await db
        .select()
        .from(offers)
        .where(eq(offers.id, offerId))
        .limit(1);

      if (!existingOffer) {
        return res.status(404).json({ error: "Oferta no encontrada" });
      }

      if (existingOffer.status !== "pending") {
        return res.status(400).json({ 
          error: "Solo se pueden hacer contraofertas a ofertas pendientes" 
        });
      }

      // Actualizar la oferta con contraoferta
      const [updatedOffer] = await db
        .update(offers)
        .set({
          counterOfferAmount: counterOfferAmount.toString(),
          counterOfferNotes: counterOfferNotes ? sanitizeText(counterOfferNotes) : null,
          status: "countered",
          updatedAt: new Date()
        })
        .where(eq(offers.id, offerId))
        .returning();

      // Actualizar estado de SOR a offer_negotiation
      if (existingOffer.opportunityRequestId) {
        await db
          .update(rentalOpportunityRequests)
          .set({ 
            status: "offer_negotiation",
            updatedAt: new Date()
          })
          .where(eq(rentalOpportunityRequests.id, existingOffer.opportunityRequestId));
      }

      // Registrar en lead_journeys
      await db.insert(leadJourneys).values({
        propertyId: existingOffer.propertyId,
        userId: existingOffer.clientId,
        action: "counter_offer",
        metadata: { offerId, counterOfferAmount },
      });

      // Log counter offer
      await createAuditLog(
        req,
        "update",
        "offer",
        offerId,
        `Contraoferta realizada de $${counterOfferAmount} (oferta original: $${existingOffer.offerAmount})`
      );

      res.json(updatedOffer);
    } catch (error: any) {
      console.error("Error creating counter offer:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Accept offer endpoint (for property owner/admin)
  app.post("/api/offers/:offerId/accept", isAuthenticated, requireRole(["admin", "propietario", "vendedor"]), async (req: any, res) => {
    try {
      const { offerId } = req.params;

      // Buscar la oferta
      const [existingOffer] = await db
        .select()
        .from(offers)
        .where(eq(offers.id, offerId))
        .limit(1);

      if (!existingOffer) {
        return res.status(404).json({ error: "Oferta no encontrada" });
      }

      if (existingOffer.status === "accepted") {
        return res.status(400).json({ error: "Esta oferta ya fue aceptada" });
      }

      // Actualizar la oferta a aceptada
      const [updatedOffer] = await db
        .update(offers)
        .set({
          status: "accepted",
          updatedAt: new Date()
        })
        .where(eq(offers.id, offerId))
        .returning();

      // Actualizar estado de SOR a offer_accepted
      if (existingOffer.opportunityRequestId) {
        await db
          .update(rentalOpportunityRequests)
          .set({ 
            status: "offer_accepted",
            updatedAt: new Date()
          })
          .where(eq(rentalOpportunityRequests.id, existingOffer.opportunityRequestId));
      }

      // Registrar en lead_journeys
      await db.insert(leadJourneys).values({
        propertyId: existingOffer.propertyId,
        userId: existingOffer.clientId,
        action: "accept_offer",
        metadata: { offerId },
      });

      // Log offer acceptance
      await createAuditLog(
        req,
        "update",
        "offer",
        offerId,
        `Oferta aceptada de $${existingOffer.offerAmount}`
      );

      res.json(updatedOffer);
    } catch (error: any) {
      console.error("Error accepting offer:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Reject offer endpoint (for property owner/admin)
  app.post("/api/offers/:offerId/reject", isAuthenticated, requireRole(["admin", "propietario", "vendedor"]), async (req: any, res) => {
    try {
      const { offerId } = req.params;
      const { notes } = req.body;

      // Buscar la oferta
      const [existingOffer] = await db
        .select()
        .from(offers)
        .where(eq(offers.id, offerId))
        .limit(1);

      if (!existingOffer) {
        return res.status(404).json({ error: "Oferta no encontrada" });
      }

      if (existingOffer.status === "accepted") {
        return res.status(400).json({ error: "No se puede rechazar una oferta ya aceptada" });
      }

      // Actualizar la oferta a rechazada
      const [updatedOffer] = await db
        .update(offers)
        .set({
          status: "rejected",
          counterOfferNotes: notes ? sanitizeText(notes) : null,
          updatedAt: new Date()
        })
        .where(eq(offers.id, offerId))
        .returning();

      // Actualizar estado de SOR a rejected
      if (existingOffer.opportunityRequestId) {
        await db
          .update(rentalOpportunityRequests)
          .set({ 
            status: "rejected",
            updatedAt: new Date()
          })
          .where(eq(rentalOpportunityRequests.id, existingOffer.opportunityRequestId));
      }

      // Registrar en lead_journeys
      await db.insert(leadJourneys).values({
        propertyId: existingOffer.propertyId,
        userId: existingOffer.clientId,
        action: "reject_offer",
        metadata: { offerId },
      });

      // Log offer rejection
      await createAuditLog(
        req,
        "update",
        "offer",
        offerId,
        `Oferta rechazada de $${existingOffer.offerAmount}`
      );

      res.json(updatedOffer);
    } catch (error: any) {
      console.error("Error rejecting offer:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Favorites routes
  app.post("/api/favorites", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { propertyId } = req.body;

      if (!propertyId) {
        return res.status(400).json({ message: "Property ID is required" });
      }

      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      const favorite = await storage.addFavorite({ userId, propertyId });
      res.status(201).json(favorite);
    } catch (error: any) {
      console.error("Error adding favorite:", error);
      if (error.message?.includes("duplicate")) {
        return res.status(400).json({ message: "Property already in favorites" });
      }
      res.status(500).json({ message: "Failed to add favorite" });
    }
  });

  app.delete("/api/favorites/:propertyId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { propertyId } = req.params;

      await storage.removeFavorite(userId, propertyId);
      res.status(204).send();
    } catch (error) {
      console.error("Error removing favorite:", error);
      res.status(500).json({ message: "Failed to remove favorite" });
    }
  });

  app.get("/api/favorites", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const favorites = await storage.getUserFavorites(userId);
      res.json(favorites);
    } catch (error) {
      console.error("Error fetching favorites:", error);
      res.status(500).json({ message: "Failed to fetch favorites" });
    }
  });

  app.get("/api/favorites/:propertyId/check", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { propertyId } = req.params;

      const isFavorite = await storage.isFavorite(userId, propertyId);
      res.json({ isFavorite });
    } catch (error) {
      console.error("Error checking favorite:", error);
      res.status(500).json({ message: "Failed to check favorite" });
    }
  });

  // Leads/CRM routes
  app.get("/api/leads", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { status, assignedToId } = req.query;
      
      // For sellers: get leads they registered OR are assigned to
      if (currentUser.role === "seller") {
        const filters: any = {};
        if (status) filters.status = status;
        if (assignedToId) filters.assignedToId = assignedToId;
        
        // Get leads using the new seller filter
        const leads = await storage.getLeadsForSeller(userId, filters);
        return res.json(leads);
      }
      
      // For admins: apply regular filters
      const filters: any = {};
      if (status) filters.status = status;
      if (assignedToId) filters.assignedToId = assignedToId;

      const leads = await storage.getLeads(filters);
      res.json(leads);
    } catch (error) {
      console.error("Error fetching leads:", error);
      res.status(500).json({ message: "Failed to fetch leads" });
    }
  });

  app.get("/api/leads/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const lead = await storage.getLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      // Sellers can only access leads they registered OR are assigned to
      if (currentUser.role === "seller" && lead.registeredById !== userId && lead.assignedToId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para acceder a este lead" });
      }
      
      res.json(lead);
    } catch (error) {
      console.error("Error fetching lead:", error);
      res.status(500).json({ message: "Failed to fetch lead" });
    }
  });

  // Validate phone number for duplicates (real-time validation)
  app.get("/api/leads/validate-phone/:phone", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { phone } = req.params;
      
      if (!phone) {
        return res.status(400).json({ message: "Teléfono requerido" });
      }

      // Check for existing lead with this phone
      const existingLead = await storage.getActiveLeadByPhone(phone);
      
      if (!existingLead) {
        return res.json({ 
          isDuplicate: false,
          message: "Teléfono disponible"
        });
      }

      // Get original seller information
      const originalSeller = await storage.getUser(existingLead.registeredById);
      
      if (!originalSeller) {
        return res.json({
          isDuplicate: true,
          message: "Lead duplicado detectado"
        });
      }

      // Return duplicate information (excluding phone for security)
      res.json({
        isDuplicate: true,
        lead: {
          id: existingLead.id,
          firstName: existingLead.firstName,
          lastName: existingLead.lastName,
          email: existingLead.email,
          budget: existingLead.budget,
          status: existingLead.status,
          source: existingLead.source,
          notes: existingLead.notes,
          registeredAt: existingLead.createdAt,
          // Exclude phone for security
        },
        originalSeller: {
          id: originalSeller.id,
          firstName: originalSeller.firstName,
          lastName: originalSeller.lastName,
          email: originalSeller.email,
          phone: originalSeller.phone,
        },
        message: `Este teléfono ya fue registrado por ${originalSeller.firstName} ${originalSeller.lastName} el ${new Date(existingLead.createdAt).toLocaleDateString('es-MX')}`
      });
    } catch (error) {
      console.error("Error validating phone:", error);
      res.status(500).json({ message: "Error al validar teléfono" });
    }
  });

  app.post("/api/leads", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Handle both admin and regular users
      let currentUser;
      if (req.user.adminAuth) {
        // Admin user - get from admin table
        const admin = await storage.getAdminById(userId);
        if (!admin) {
          return res.status(404).json({ message: "Usuario no encontrado" });
        }
        // Normalize admin to user shape for consistent downstream access
        currentUser = {
          id: admin.id,
          firstName: admin.firstName,
          lastName: admin.lastName,
          email: admin.email,
          role: admin.role || 'admin', // Use admin role or default to 'admin'
        };
      } else {
        // Regular user - get from users table
        currentUser = await storage.getUser(userId);
        if (!currentUser) {
          return res.status(404).json({ message: "Usuario no encontrado" });
        }
      }

      const leadData = req.body;
      
      // Obtener configuración del sistema para período de validez
      const validityConfig = await storage.getSystemConfig("lead_validity_months");
      const validityMonths = validityConfig ? parseInt(validityConfig.value) : 3;
      
      // Calcular fecha de validez
      const validUntil = new Date();
      validUntil.setMonth(validUntil.getMonth() + validityMonths);
      
      // Verificar si existe un lead activo (no expirado) con el mismo teléfono
      const existingLead = await storage.getActiveLeadByPhone(leadData.phone);
      
      if (existingLead) {
        // Lead duplicado detectado - calcular tiempo restante
        const now = new Date();
        const validUntilDate = new Date(existingLead.validUntil);
        const daysRemaining = Math.ceil((validUntilDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        const monthsRemaining = Math.floor(daysRemaining / 30);
        const daysRemainingAfterMonths = daysRemaining % 30;
        
        const originalSeller = await storage.getUser(existingLead.registeredById);
        
        // Obtener propiedades ofrecidas al lead por el vendedor original
        const offersToLead = await storage.getLeadPropertyOffers({ leadId: existingLead.id });
        const propertyNames = await Promise.all(
          offersToLead.map(async (offer) => {
            const property = await storage.getProperty(offer.propertyId);
            return property?.title || "Propiedad sin nombre";
          })
        );
        
        // Enviar notificación al vendedor original
        if (originalSeller && originalSeller.email) {
          try {
            await sendDuplicateLeadNotification(
              originalSeller.email,
              `${originalSeller.firstName} ${originalSeller.lastName}`,
              `${existingLead.firstName} ${existingLead.lastName}`,
              `${currentUser.firstName} ${currentUser.lastName}`,
              propertyNames
            );
          } catch (emailError) {
            console.error("Error enviando notificación de duplicado:", emailError);
          }
        }
        
        // Crear notificación en el sistema para el vendedor original
        await storage.createNotification({
          userId: existingLead.registeredById,
          title: "Lead duplicado detectado",
          message: `El lead ${existingLead.firstName} ${existingLead.lastName} (${existingLead.phone}) fue registrado nuevamente por ${currentUser.firstName} ${currentUser.lastName}`,
          type: "lead_duplicate",
          link: `/leads/${existingLead.id}`,
        });
        
        await createAuditLog(req, "create", "lead", existingLead.id, `Intento de crear lead duplicado: ${leadData.firstName} ${leadData.lastName} (${leadData.phone})`);
        
        // Construir mensaje de tiempo restante
        let timeMessage = "";
        if (monthsRemaining > 0) {
          timeMessage = `${monthsRemaining} ${monthsRemaining === 1 ? 'mes' : 'meses'}`;
          if (daysRemainingAfterMonths > 0) {
            timeMessage += ` y ${daysRemainingAfterMonths} ${daysRemainingAfterMonths === 1 ? 'día' : 'días'}`;
          }
        } else {
          timeMessage = `${daysRemaining} ${daysRemaining === 1 ? 'día' : 'días'}`;
        }
        
        return res.status(409).json({ 
          message: `Este lead ya fue registrado por ${originalSeller?.firstName} ${originalSeller?.lastName} el ${new Date(existingLead.createdAt).toLocaleDateString('es-MX')}. Tiempo restante para que se libere: ${timeMessage}`,
          existingLead: {
            id: existingLead.id,
            firstName: existingLead.firstName,
            lastName: existingLead.lastName,
            phone: existingLead.phone,
            registeredBy: `${originalSeller?.firstName} ${originalSeller?.lastName}`,
            createdAt: existingLead.createdAt,
            validUntil: existingLead.validUntil,
            daysRemaining,
          },
          isDuplicate: true
        });
      }
      
      // Crear nuevo lead con fecha de validez
      // Leads registrados por vendedores/admin se marcan como verificados automáticamente
      const lead = await storage.createLead({
        ...leadData,
        registeredById: userId,
        validUntil,
        emailVerified: true, // Auto-verificado cuando es registrado por staff
      });
      
      await createAuditLog(req, "create", "lead", lead.id, `Lead creado: ${lead.firstName} ${lead.lastName}`);
      
      // Calculate lead score automatically
      try {
        await storage.calculateLeadScore(lead.id);
        
        // Create workflow event
        await storage.createWorkflowEvent({
          eventType: "lead_created",
          entityType: "lead",
          entityId: lead.id,
          userId: userId,
          metadata: { firstName: lead.firstName, lastName: lead.lastName, source: lead.source },
        });
      } catch (scoringError) {
        console.error("Error calculating lead score:", scoringError);
        // Don't fail lead creation if scoring fails
      }
      
      res.status(201).json(lead);
    } catch (error: any) {
      console.error("Error creating lead:", error);
      res.status(400).json({ message: error.message || "Failed to create lead" });
    }
  });

  app.patch("/api/leads/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const existingLead = await storage.getLead(id);
      if (!existingLead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      // Sellers can only update their own leads
      if (currentUser.role === "seller" && existingLead.registeredById !== userId) {
        return res.status(403).json({ message: "No tienes permiso para actualizar este lead" });
      }
      
      const updatedLead = await storage.updateLead(id, updates);
      
      await createAuditLog(req, "update", "lead", id, `Lead actualizado: ${updatedLead.firstName} ${updatedLead.lastName}`);
      
      // Recalculate lead score after update
      try {
        await storage.calculateLeadScore(id);
        
        // Create workflow event
        await storage.createWorkflowEvent({
          eventType: "lead_updated",
          entityType: "lead",
          entityId: id,
          userId: userId,
          metadata: { updates: Object.keys(updates) },
        });
      } catch (scoringError) {
        console.error("Error recalculating lead score:", scoringError);
      }
      
      res.json(updatedLead);
    } catch (error: any) {
      console.error("Error updating lead:", error);
      res.status(400).json({ message: error.message || "Failed to update lead" });
    }
  });

  app.patch("/api/leads/:id/status", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }
      
      const existingLead = await storage.getLead(id);
      if (!existingLead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      // Sellers can only update status of their own leads
      if (currentUser.role === "seller" && existingLead.registeredById !== userId) {
        return res.status(403).json({ message: "No tienes permiso para actualizar el estado de este lead" });
      }
      
      const updatedLead = await storage.updateLeadStatus(id, status);
      
      // Register status change in lead history
      await storage.createLeadHistory({
        leadId: id,
        action: "status_changed",
        field: "status",
        oldValue: existingLead.status,
        newValue: status,
        userId: userId,
        description: `Estado cambió de "${existingLead.status}" a "${status}"`,
      });
      
      await createAuditLog(req, "update", "lead", id, `Estado de lead actualizado a: ${status}`);
      
      // Recalculate lead score after status change
      try {
        await storage.calculateLeadScore(id);
        
        // Create workflow event for status change
        await storage.createWorkflowEvent({
          eventType: "lead_status_changed",
          entityType: "lead",
          entityId: id,
          userId: userId,
          metadata: { newStatus: status, previousStatus: existingLead.status },
        });
        
        // Check if we need to create alerts based on status change
        if (status === "perdido") {
          await storage.createSystemAlert({
            userId: existingLead.registeredById,
            alertType: "lead_lost",
            priority: "medium",
            title: "Lead perdido",
            message: `El lead ${updatedLead.firstName} ${updatedLead.lastName} ha sido marcado como perdido`,
            relatedEntityType: "lead",
            relatedEntityId: id,
          });
        }
      } catch (error) {
        console.error("Error in lead status change automation:", error);
      }
      
      res.json(updatedLead);
    } catch (error: any) {
      console.error("Error updating lead status:", error);
      res.status(400).json({ message: error.message || "Failed to update lead status" });
    }
  });

  // Get lead history
  app.get("/api/leads/:id/history", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const lead = await storage.getLead(id);
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      // Sellers can only view history of their own leads
      if (currentUser.role === "seller" && lead.registeredById !== userId && lead.assignedToId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para ver el historial de este lead" });
      }
      
      const history = await storage.getLeadHistory(id);
      
      // Enrich history with user info
      const enrichedHistory = await Promise.all(
        history.map(async (entry) => {
          const user = await storage.getUser(entry.userId);
          return {
            ...entry,
            user: user ? {
              id: user.id,
              firstName: user.firstName,
              lastName: user.lastName,
              email: user.email,
            } : null,
          };
        })
      );
      
      res.json(enrichedHistory);
    } catch (error) {
      console.error("Error fetching lead history:", error);
      res.status(500).json({ message: "Failed to fetch lead history" });
    }
  });

  app.delete("/api/leads/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      const existingLead = await storage.getLead(id);
      if (!existingLead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      await createAuditLog(req, "delete", "lead", id, `Lead eliminado: ${existingLead.firstName} ${existingLead.lastName}`);
      
      await storage.deleteLead(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting lead:", error);
      res.status(500).json({ message: "Failed to delete lead" });
    }
  });

  // Reassign lead to another seller (Admin only)
  app.patch("/api/leads/:id/reassign", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { newSellerId } = req.body;
      
      if (!newSellerId) {
        return res.status(400).json({ message: "Nuevo vendedor requerido" });
      }
      
      const existingLead = await storage.getLead(id);
      if (!existingLead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const newSeller = await storage.getUser(newSellerId);
      if (!newSeller || newSeller.role !== "seller") {
        return res.status(400).json({ message: "El usuario seleccionado no es un vendedor válido" });
      }
      
      const previousSeller = await storage.getUser(existingLead.registeredById);
      
      const updatedLead = await storage.updateLead(id, { registeredById: newSellerId });
      
      await createAuditLog(
        req, 
        "update", 
        "lead", 
        id, 
        `Lead reasignado de ${previousSeller?.name || 'vendedor anterior'} a ${newSeller.name}`
      );
      
      // Create notification for new seller
      await storage.createSystemAlert({
        userId: newSellerId,
        alertType: "lead_assigned",
        priority: "high",
        title: "Nuevo lead asignado",
        message: `Se te ha asignado el lead: ${updatedLead.firstName} ${updatedLead.lastName}`,
        relatedEntityType: "lead",
        relatedEntityId: id,
      });
      
      res.json(updatedLead);
    } catch (error) {
      console.error("Error reassigning lead:", error);
      res.status(500).json({ message: "Failed to reassign lead" });
    }
  });

  // Get lead appointments history
  app.get("/api/leads/:id/appointments", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const lead = await storage.getLead(id);
      if (!lead) {
        return res.status(404).json({ message: "Lead no encontrado" });
      }
      
      // Sellers can only access appointments for their own leads
      if (currentUser.role === "seller" && lead.registeredById !== userId) {
        return res.status(403).json({ message: "No tienes permiso para acceder a las citas de este lead" });
      }
      
      const leadAppointments = await db
        .select()
        .from(appointments)
        .where(eq(appointments.leadId, id))
        .orderBy(desc(appointments.date));
      
      // Enrich with property and staff info
      const enrichedAppointments = await Promise.all(
        leadAppointments.map(async (apt) => {
          const property = apt.propertyId ? await storage.getProperty(apt.propertyId) : null;
          const staff = apt.assignedStaffId ? await storage.getUser(apt.assignedStaffId) : null;
          return {
            ...apt,
            property: property ? {
              id: property.id,
              title: getPropertyTitle(property),
              location: property.location,
            } : null,
            assignedStaff: staff ? {
              id: staff.id,
              name: staff.name,
            } : null,
          };
        })
      );
      
      res.json(enrichedAppointments);
    } catch (error) {
      console.error("Error fetching lead appointments:", error);
      res.status(500).json({ message: "Failed to fetch lead appointments" });
    }
  });

  // Lead email verification route (public)
  app.get("/api/verify-lead", emailVerificationLimiter, async (req: any, res) => {
    try {
      const { token, email } = req.query;
      
      if (!token || !email) {
        return res.status(400).json({ message: "Token y email son requeridos" });
      }
      
      // Buscar el lead por email
      const lead = await storage.getLeadByEmail(email as string);
      if (!lead) {
        return res.status(404).json({ message: "Lead no encontrado" });
      }
      
      // Verificar si ya está verificado
      if (lead.emailVerified) {
        return res.status(200).json({ 
          message: "El email ya fue verificado anteriormente",
          alreadyVerified: true
        });
      }
      
      // Obtener el token de verificación
      const verificationToken = await storage.getEmailVerificationTokenByUserId(lead.id);
      if (!verificationToken || verificationToken.token !== token) {
        return res.status(400).json({ message: "Token de verificación inválido" });
      }
      
      // Verificar que no haya expirado
      if (new Date() > verificationToken.expiresAt) {
        await storage.deleteEmailVerificationToken(verificationToken.id);
        return res.status(400).json({ message: "El token ha expirado" });
      }
      
      // Marcar el email del lead como verificado
      await storage.verifyLeadEmail(lead.id);
      
      // Eliminar el token usado
      await storage.deleteEmailVerificationToken(verificationToken.id);
      
      res.json({ 
        message: "Email verificado exitosamente",
        success: true
      });
    } catch (error) {
      console.error("Error verifying lead email:", error);
      res.status(500).json({ message: "Error al verificar el email" });
    }
  });

  // Owner referral email verification route (public)
  app.get("/api/verify-owner-referral/:token", emailVerificationLimiter, async (req: any, res) => {
    try {
      const { token } = req.params;
      
      if (!token) {
        return res.status(400).json({ message: "Token es requerido" });
      }
      
      // Buscar el referido por token
      const referral = await storage.getOwnerReferralByVerificationToken(token);
      if (!referral) {
        return res.status(404).json({ message: "Token de verificación inválido o expirado" });
      }
      
      // Verificar si ya está verificado
      if (referral.emailVerified) {
        return res.status(200).json({ 
          message: "El email ya fue verificado anteriormente",
          alreadyVerified: true,
          referral: {
            id: referral.id,
            firstName: referral.firstName,
            lastName: referral.lastName,
            propertyAddress: referral.propertyAddress
          }
        });
      }
      
      // Verificar que no haya expirado
      if (referral.verificationTokenExpiry && new Date() > referral.verificationTokenExpiry) {
        return res.status(400).json({ message: "El token ha expirado" });
      }
      
      // Marcar el email del referido como verificado
      const updatedReferral = await storage.verifyOwnerReferralEmail(referral.id);
      
      res.json({ 
        message: "Email verificado exitosamente. Un administrador revisará tu solicitud pronto.",
        success: true,
        referral: {
          id: updatedReferral.id,
          firstName: updatedReferral.firstName,
          lastName: updatedReferral.lastName,
          propertyAddress: updatedReferral.propertyAddress
        }
      });
    } catch (error) {
      console.error("Error verifying owner referral email:", error);
      res.status(500).json({ message: "Error al verificar el email" });
    }
  });

  // Route to offer properties to leads (seller only)
  app.post("/api/leads/:leadId/offer-property", isAuthenticated, requireRole(["seller", "master", "admin"]), async (req: any, res) => {
    try {
      const { leadId } = req.params;
      const { propertyId } = req.body;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (!propertyId) {
        return res.status(400).json({ message: "ID de propiedad es requerido" });
      }
      
      // Verificar que el lead existe
      const lead = await storage.getLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead no encontrado" });
      }
      
      // Sellers can only offer properties to their own leads
      if (currentUser.role === "seller" && lead.registeredById !== userId) {
        return res.status(403).json({ message: "No tienes permiso para ofrecer propiedades a este lead" });
      }
      
      // Verificar que la propiedad existe
      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }
      
      // Crear el registro de oferta de propiedad
      const offer = await storage.createLeadPropertyOffer({
        leadId,
        propertyId,
        offeredById: userId,
      });
      
      await createAuditLog(req, "create", "lead_property_offer", offer.id, `Propiedad ${property.title} ofrecida a lead ${lead.firstName} ${lead.lastName}`);
      
      res.status(201).json({ 
        message: "Propiedad ofrecida al lead exitosamente",
        offer
      });
    } catch (error: any) {
      console.error("Error offering property to lead:", error);
      res.status(400).json({ message: error.message || "Error al ofrecer propiedad al lead" });
    }
  });

  // Route to get properties offered to a lead
  app.get("/api/leads/:leadId/offered-properties", isAuthenticated, requireRole(["seller", "master", "admin", "management"]), async (req: any, res) => {
    try {
      const { leadId } = req.params;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify the lead exists
      const lead = await storage.getLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead no encontrado" });
      }
      
      // Sellers can only access offered properties for their own leads
      if (currentUser.role === "seller" && lead.registeredById !== userId) {
        return res.status(403).json({ message: "No tienes permiso para acceder a las propiedades ofrecidas de este lead" });
      }
      
      const offers = await storage.getLeadPropertyOffers({ leadId });
      
      // Enrich with property details
      const enrichedOffers = await Promise.all(
        offers.map(async (offer) => {
          const property = await storage.getProperty(offer.propertyId);
          const offeredBy = await storage.getUser(offer.offeredById);
          return {
            ...offer,
            property,
            offeredBy: offeredBy ? { 
              id: offeredBy.id, 
              firstName: offeredBy.firstName, 
              lastName: offeredBy.lastName 
            } : null
          };
        })
      );
      
      res.json(enrichedOffers);
    } catch (error) {
      console.error("Error fetching offered properties:", error);
      res.status(500).json({ message: "Error al obtener propiedades ofrecidas" });
    }
  });

  // Owner Referral routes
  
  // POST /api/owner-referrals - Create new owner referral (sellers only)
  app.post("/api/owner-referrals", isAuthenticated, requireRole(["seller"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      
      const referralData = {
        ...req.body,
        referrerId: userId,
        commissionPercent: req.body.commissionPercent || "20.00",
      };
      
      // Generate verification token
      const verificationToken = crypto.randomUUID();
      const verificationTokenExpiry = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
      
      const ownerReferral = await storage.createOwnerReferral({
        ...referralData,
        verificationToken,
        verificationTokenExpiry,
      });
      
      // Send verification email to owner
      const verificationLink = `${process.env.REPLIT_DEV_DOMAIN || 'http://localhost:5000'}/verify-owner-referral/${verificationToken}`;
      const sellerName = `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim();
      
      await sendOwnerReferralVerificationEmail(
        ownerReferral.email,
        ownerReferral.firstName,
        sellerName,
        ownerReferral.propertyAddress || 'Propiedad referida',
        verificationLink
      );
      
      await createAuditLog(req, "create", "owner_referral", ownerReferral.id, `Referido de propietario creado: ${ownerReferral.firstName} ${ownerReferral.lastName}`);
      
      res.status(201).json({ 
        message: "Referido de propietario creado. Se ha enviado un email de verificación al propietario.",
        ownerReferral 
      });
    } catch (error: any) {
      console.error("Error creating owner referral:", error);
      res.status(400).json({ message: error.message || "Error al crear referido de propietario" });
    }
  });
  
  // GET /api/owner-referrals - Get owner referrals
  app.get("/api/owner-referrals", isAuthenticated, requireRole(["seller", "master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      
      let referrals;
      
      if (currentUser.role === "seller") {
        // Sellers can only see their own referrals
        referrals = await storage.getOwnerReferrals({ referrerId: userId });
      } else {
        // Admins can see all referrals
        const filters: any = {};
        if (req.query.status) {
          filters.status = req.query.status;
        }
        if (req.query.referrerId) {
          filters.referrerId = req.query.referrerId;
        }
        referrals = await storage.getOwnerReferrals(filters);
      }
      
      res.json(referrals);
    } catch (error) {
      console.error("Error fetching owner referrals:", error);
      res.status(500).json({ message: "Error al obtener referidos de propietarios" });
    }
  });
  
  // GET /api/owner-referrals/:id - Get specific owner referral
  app.get("/api/owner-referrals/:id", isAuthenticated, requireRole(["seller", "master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }
      
      const referral = await storage.getOwnerReferral(id);
      
      if (!referral) {
        return res.status(404).json({ message: "Referido no encontrado" });
      }
      
      // Sellers can only see their own referrals
      if (currentUser.role === "seller" && referral.referrerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para ver este referido" });
      }
      
      res.json(referral);
    } catch (error) {
      console.error("Error fetching owner referral:", error);
      res.status(500).json({ message: "Error al obtener referido de propietario" });
    }
  });
  
  // PATCH /api/owner-referrals/:id/approve - Approve owner referral (admin only)
  app.patch("/api/owner-referrals/:id/approve", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      let { commissionAmount } = req.body;
      const userId = req.user.claims.sub;
      
      const referral = await storage.getOwnerReferral(id);
      
      if (!referral) {
        return res.status(404).json({ message: "Referido no encontrado" });
      }
      
      if (!referral.emailVerified) {
        return res.status(400).json({ message: "El email del propietario debe ser verificado antes de aprobar" });
      }
      
      // Calculate default 20% commission if not provided
      if (!commissionAmount && referral.estimatedValue) {
        const estimatedValue = parseFloat(referral.estimatedValue);
        if (!isNaN(estimatedValue)) {
          commissionAmount = (estimatedValue * 0.20).toFixed(2);
        }
      }
      
      const updatedReferral = await storage.approveOwnerReferralByAdmin(id, userId, commissionAmount);
      
      // Send notification to seller
      const seller = await storage.getUser(referral.referrerId);
      if (seller && seller.email) {
        await sendOwnerReferralApprovedNotification(
          seller.email,
          `${seller.firstName || ''} ${seller.lastName || ''}`.trim(),
          `${referral.firstName} ${referral.lastName}`,
          referral.propertyAddress || 'Propiedad referida',
          commissionAmount || updatedReferral.commissionAmount || '0.00'
        );
      }
      
      await createAuditLog(req, "update", "owner_referral", id, `Referido de propietario aprobado con comisión de $${commissionAmount || updatedReferral.commissionAmount}`);
      
      res.json({ 
        message: "Referido aprobado exitosamente. Se ha notificado al vendedor.",
        ownerReferral: updatedReferral 
      });
    } catch (error: any) {
      console.error("Error approving owner referral:", error);
      res.status(400).json({ message: error.message || "Error al aprobar referido" });
    }
  });
  
  // PATCH /api/owner-referrals/:id/reject - Reject owner referral (admin only)
  app.patch("/api/owner-referrals/:id/reject", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { rejectionReason } = req.body;
      const userId = req.user.claims.sub;
      
      if (!rejectionReason) {
        return res.status(400).json({ message: "Se requiere una razón de rechazo" });
      }
      
      const referral = await storage.getOwnerReferral(id);
      
      if (!referral) {
        return res.status(404).json({ message: "Referido no encontrado" });
      }
      
      const updatedReferral = await storage.rejectOwnerReferralByAdmin(id, userId, rejectionReason);
      
      await createAuditLog(req, "update", "owner_referral", id, `Referido de propietario rechazado: ${rejectionReason}`);
      
      res.json({ 
        message: "Referido rechazado exitosamente",
        ownerReferral: updatedReferral 
      });
    } catch (error: any) {
      console.error("Error rejecting owner referral:", error);
      res.status(400).json({ message: error.message || "Error al rechazar referido" });
    }
  });

  // Appointment routes
  // Admin route to get ALL appointments in the system
  app.get("/api/admin/appointments/all", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const appointments = await storage.getAllAppointmentsAdmin();
      res.json(appointments);
    } catch (error) {
      console.error("Error fetching admin appointments:", error);
      res.status(500).json({ message: "Failed to fetch admin appointments" });
    }
  });

  // Admin route to get seller management data
  app.get("/api/admin/sellers/all", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const sellersData = await storage.getSellerManagementData();
      res.json(sellersData);
    } catch (error) {
      console.error("Error fetching seller management data:", error);
      res.status(500).json({ message: "Failed to fetch seller management data" });
    }
  });

  // Admin route to update any appointment
  app.patch("/api/admin/appointments/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const updatedAppointment = await storage.updateAppointment(id, req.body);

      await createAuditLog(req, "update", "appointment", id, "Cita actualizada por administrador");

      res.json({ 
        message: "Cita actualizada exitosamente",
        appointment: updatedAppointment 
      });
    } catch (error: any) {
      console.error("Error updating appointment:", error);
      res.status(400).json({ message: error.message || "Error al actualizar la cita" });
    }
  });

  // Admin route to cancel any appointment
  app.post("/api/admin/appointments/:id/cancel", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const updatedAppointment = await storage.updateAppointment(id, {
        status: "cancelled" as any,
      });

      await createAuditLog(req, "update", "appointment", id, "Cita cancelada por administrador");

      res.json({ 
        message: "Cita cancelada exitosamente",
        appointment: updatedAppointment 
      });
    } catch (error: any) {
      console.error("Error cancelling appointment:", error);
      res.status(400).json({ message: error.message || "Error al cancelar la cita" });
    }
  });

  app.get("/api/appointments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { status, clientId, propertyId } = req.query;
      const filters: any = {};
      if (status) filters.status = status;
      if (propertyId) filters.propertyId = propertyId;
      
      // Security: Only admins/masters/sellers can filter by different clientId
      // Clients can only see their own appointments
      if (clientId && clientId !== userId) {
        if (!["master", "admin", "admin_jr", "seller"].includes(user.role)) {
          return res.status(403).json({ message: "No tienes permiso para ver citas de otros clientes" });
        }
        filters.clientId = clientId;
      } else if (user.role === "client") {
        // Clients always see only their own appointments
        filters.clientId = userId;
      } else if (clientId) {
        // Admin/seller requested specific clientId
        filters.clientId = clientId;
      }

      const appointments = await storage.getAppointments(filters);
      
      // Enrich appointments with additional data
      const enrichedAppointments = await Promise.all(
        appointments.map(async (apt) => {
          const enriched: any = { ...apt };
          
          // Add property info
          if (apt.propertyId) {
            enriched.property = await storage.getProperty(apt.propertyId);
          }
          
          // Add client info
          if (apt.clientId) {
            const client = await storage.getUser(apt.clientId);
            if (client) {
              enriched.client = {
                email: client.email,
                firstName: client.firstName,
                lastName: client.lastName,
                phone: client.phone,
                nationality: client.nationality,
                profileImageUrl: client.profileImageUrl,
              };
            }
          }
          
          // Add concierge info with rating
          if (apt.conciergeId) {
            const concierge = await storage.getUser(apt.conciergeId);
            if (concierge) {
              // Get concierge reviews to calculate rating
              const reviews = await storage.getConciergeReviews({ conciergeId: apt.conciergeId });
              const avgRating = reviews.length > 0 
                ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length 
                : 0;
              
              enriched.concierge = {
                id: concierge.id,
                firstName: concierge.firstName,
                lastName: concierge.lastName,
                email: concierge.email,
                phone: concierge.phone,
                profileImageUrl: concierge.profileImageUrl,
                rating: avgRating || undefined,
                reviewCount: reviews.length || undefined,
              };
            }
          }
          
          // Add presentation card info
          if (apt.presentationCardId) {
            const presentationCard = await storage.getPresentationCard(apt.presentationCardId);
            if (presentationCard) {
              enriched.presentationCard = presentationCard;
            }
          }
          
          return enriched;
        })
      );
      
      res.json(enrichedAppointments);
    } catch (error) {
      console.error("Error fetching appointments:", error);
      res.status(500).json({ message: "Failed to fetch appointments" });
    }
  });

  // Get available concierges for a specific time slot
  app.get("/api/appointments/available-concierges", isAuthenticated, async (req: any, res) => {
    try {
      const { date, mode } = req.query;
      
      if (!date) {
        return res.status(400).json({ message: "Date parameter is required" });
      }

      const slotDate = new Date(date);
      // Convert mode to duration: individual=60min (default), tour=30min
      const durationMinutes = mode === 'tour' ? 30 : 60;
      const availableConcierges = await storage.getAvailableConcierguesForSlot(slotDate, durationMinutes);
      
      // Enrich with ratings
      const enrichedConcierges = await Promise.all(
        availableConcierges.map(async (concierge) => {
          const reviews = await storage.getConciergeReviews({ conciergeId: concierge.id });
          const avgRating = reviews.length > 0 
            ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length 
            : 0;
          
          return {
            ...concierge,
            rating: avgRating || undefined,
            reviewCount: reviews.length || undefined,
          };
        })
      );
      
      res.json(enrichedConcierges);
    } catch (error) {
      console.error("Error fetching available concierges:", error);
      res.status(500).json({ message: "Failed to fetch available concierges" });
    }
  });

  // Get slot availability count
  app.get("/api/appointments/slot-availability", isAuthenticated, async (req: any, res) => {
    try {
      const { date } = req.query;
      
      if (!date) {
        return res.status(400).json({ message: "Date parameter is required" });
      }

      const slotDate = new Date(date);
      const availableCount = await storage.getAvailableSlotCount(slotDate);
      
      res.json({ 
        date: slotDate, 
        availableSpaces: availableCount,
        isAvailable: availableCount > 0 
      });
    } catch (error) {
      console.error("Error checking slot availability:", error);
      res.status(500).json({ message: "Failed to check slot availability" });
    }
  });

  // Assign concierge to appointment (for owners and admins)
  app.patch("/api/appointments/:id/assign-concierge", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { conciergeId, accessType, accessCode, accessInstructions } = req.body;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Check permissions: owner of the property or admin
      const property = await storage.getProperty(appointment.propertyId);
      const isOwner = property?.ownerId === userId;
      const isAdmin = user && ["master", "admin", "admin_jr", "management"].includes(user.role);

      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "No tienes permiso para asignar conserjes a esta cita" });
      }

      // Validate concierge is available
      const availableConcierges = await storage.getAvailableConcierguesForSlot(appointment.date);
      const isConciergeAvailable = availableConcierges.some(c => c.id === conciergeId);

      if (!isConciergeAvailable) {
        return res.status(400).json({ message: "El conserje seleccionado no está disponible para este horario" });
      }

      // Assign concierge with access information
      const updatedAppointment = await storage.assignConciergeToAppointment(
        id,
        conciergeId,
        userId,
        { accessType, accessCode, accessInstructions }
      );

      await createAuditLog(req, "update", "appointment", id, `Conserje asignado por ${isOwner ? "propietario" : "administrador"}`);

      // Send notifications to all parties
      const concierge = await storage.getUser(conciergeId);
      const client = await storage.getUser(appointment.clientId);
      
      const notifications = [];
      const appointmentDate = new Date(appointment.date).toLocaleString('es-MX', { 
        dateStyle: 'full',
        timeStyle: 'short'
      });
      const propertyLocation = property?.location || "ubicación no disponible";
      const accessTypeLabel = {
        lockbox: "Lockbox",
        electronic: "Cerradura Electrónica",
        manual: "Acceso Manual",
        other: "Otro"
      }[accessType] || accessType;

      // Notify client - confirmation with property address, time, concierge info
      if (client) {
        notifications.push(
          storage.createNotification({
            userId: client.id,
            type: "appointment",
            title: "Conserje Asignado a tu Cita",
            message: `Tu cita para ${property?.title} el ${appointmentDate} ha sido confirmada. Conserje asignado: ${concierge?.firstName} ${concierge?.lastName}. Ubicación: ${propertyLocation}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "high",
          })
        );
      }

      // Notify property owner - confirmation with concierge assignment
      if (property?.ownerId && property.ownerId !== userId) {
        notifications.push(
          storage.createNotification({
            userId: property.ownerId,
            type: "appointment",
            title: "Conserje Asignado",
            message: `Se ha asignado a ${concierge?.firstName} ${concierge?.lastName} para la cita en ${property.title} el ${appointmentDate}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "medium",
          })
        );
      }

      // Notify concierge - appointment details, access instructions, property location
      if (concierge) {
        const accessInfo = accessType === "manual" 
          ? `Acceso: ${accessTypeLabel}. ${accessInstructions || 'Sin instrucciones adicionales'}`
          : `Acceso: ${accessTypeLabel}. Código: ${accessCode || 'N/A'}. ${accessInstructions || ''}`;
        
        notifications.push(
          storage.createNotification({
            userId: concierge.id,
            type: "appointment",
            title: "Nueva Cita Asignada",
            message: `Has sido asignado a una cita en ${property?.title} el ${appointmentDate}. Ubicación: ${propertyLocation}. ${accessInfo}`,
            relatedEntityType: "appointment",
            relatedEntityId: appointment.id,
            priority: "high",
          })
        );
      }

      // Notify admins - assignment confirmation
      const admins = await storage.getUsersByRole("admin");
      const masters = await storage.getUsersByRole("master");
      const allAdmins = [...admins, ...masters];
      
      for (const admin of allAdmins) {
        if (admin.id !== userId) { // Don't notify the admin who made the assignment
          notifications.push(
            storage.createNotification({
              userId: admin.id,
              type: "appointment",
              title: "Conserje Asignado a Cita",
              message: `${concierge?.firstName} ${concierge?.lastName} asignado a cita en ${property?.title} el ${appointmentDate} por ${isOwner ? "propietario" : "administrador"}`,
              relatedEntityType: "appointment",
              relatedEntityId: appointment.id,
              priority: "low",
            })
          );
        }
      }

      // Create all notifications
      await Promise.all(notifications);

      res.json({ 
        message: "Conserje asignado exitosamente",
        appointment: updatedAppointment,
        concierge: concierge ? {
          firstName: concierge.firstName,
          lastName: concierge.lastName,
          email: concierge.email,
          phoneNumber: concierge.phoneNumber,
        } : null
      });
    } catch (error: any) {
      console.error("Error assigning concierge:", error);
      res.status(400).json({ message: error.message || "Error al asignar conserje" });
    }
  });

  app.post("/api/appointments", isAuthenticated, async (req: any, res) => {
    let googleEventId: string | null = null;
    
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Determine clientId: admins/masters can specify, others use their own ID
      let clientId = userId;
      if (req.body.clientId && req.body.clientId !== userId) {
        if (user && ["master", "admin", "admin_jr", "seller"].includes(user.role)) {
          clientId = req.body.clientId;
        }
        // Non-admins cannot specify different clientId, silently use their own
      }
      
      // Validate manual property data (only for sellers and admins)
      const hasPropertyId = !!req.body.propertyId;
      const hasManualProperty = req.body.condominiumName || req.body.unitNumber;
      
      if (hasManualProperty) {
        // Only sellers and admins can create appointments with manual properties
        if (!user || !["master", "admin", "admin_jr", "seller"].includes(user.role)) {
          return res.status(403).json({ 
            message: "Solo vendedores y administradores pueden crear citas con propiedades manuales" 
          });
        }
        
        // Can't have both propertyId and manual property data
        if (hasPropertyId) {
          return res.status(400).json({ 
            message: "No puedes proporcionar propertyId y datos de propiedad manual al mismo tiempo" 
          });
        }
        
        // Both condominiumName and unitNumber are required for manual properties
        if (!req.body.condominiumName || !req.body.unitNumber) {
          return res.status(400).json({ 
            message: "Debes proporcionar tanto el nombre del condominio como el número de unidad" 
          });
        }
      } else if (!hasPropertyId) {
        // Must have either propertyId or manual property data
        return res.status(400).json({ 
          message: "Debes proporcionar una propiedad existente o los datos de condominio y unidad" 
        });
      }
      
      // Clean special values and convert date string to Date object if needed
      const cleanedBody = {
        ...req.body,
        clientId,
        conciergeId: req.body.conciergeId === "none" ? undefined : req.body.conciergeId,
        // Convert date string to Date object (JSON serialization converts Date to string)
        date: req.body.date ? new Date(req.body.date) : req.body.date,
      };
      
      const appointmentData = insertAppointmentSchema.parse(cleanedBody);

      // Validate: Client can only have 1 appointment per day
      // Get start and end of the appointment date
      const appointmentDate = new Date(appointmentData.date);
      const startOfAppointmentDay = new Date(appointmentDate);
      startOfAppointmentDay.setHours(0, 0, 0, 0);
      const endOfAppointmentDay = new Date(appointmentDate);
      endOfAppointmentDay.setHours(23, 59, 59, 999);

      // Check if client already has an appointment on this day (excluding cancelled ones)
      const existingAppointments = await storage.getAppointments();
      const clientAppointmentsOnDay = existingAppointments.filter(apt => {
        const aptDate = new Date(apt.date);
        return apt.clientId === clientId && 
               apt.status !== "cancelled" &&
               aptDate >= startOfAppointmentDay && 
               aptDate <= endOfAppointmentDay;
      });

      if (clientAppointmentsOnDay.length > 0) {
        return res.status(400).json({ 
          message: "Ya tienes una cita programada para este día. Solo puedes coordinar 1 cita por día. Si necesitas coordinar otra cita el mismo día, primero debes cancelar la que tienes." 
        });
      }

      // Create Google Meet event if type is video
      let meetLink = null;
      
      if (appointmentData.type === "video") {
        const property = appointmentData.propertyId ? await storage.getProperty(appointmentData.propertyId) : null;
        const propertyTitle = property?.title || 
          (appointmentData.condominiumName && appointmentData.unitNumber 
            ? `${appointmentData.condominiumName} - ${appointmentData.unitNumber}`
            : "Propiedad");
        
        const appointmentDate = new Date(appointmentData.date);
        const endDate = new Date(appointmentDate.getTime() + 60 * 60 * 1000); // 1 hour later

        try {
          const eventResult = await createGoogleMeetEvent({
            summary: `Visita Virtual: ${propertyTitle}`,
            description: `Cita virtual para visitar la propiedad`,
            start: appointmentDate,
            end: endDate,
            attendees: [], // Can be extended to include emails
          });

          if (eventResult) {
            meetLink = eventResult.meetLink;
            googleEventId = eventResult.eventId;
          }
        } catch (meetError) {
          console.error("Error creating Google Meet event:", meetError);
          // Continue without meet link if event creation fails
        }
      }

      try {
        const appointment = await storage.createAppointment({
          ...appointmentData,
          meetLink: meetLink || appointmentData.meetLink,
          googleEventId: googleEventId || undefined,
        });

        // Log appointment creation
        const property = appointment.propertyId ? await storage.getProperty(appointment.propertyId) : null;
        const propertyDescription = property?.title || 
          (appointment.condominiumName && appointment.unitNumber 
            ? `${appointment.condominiumName} - ${appointment.unitNumber}`
            : "propiedad");
        
        await createAuditLog(
          req,
          "create",
          "appointment",
          appointment.id,
          `Cita creada para ${propertyDescription} - ${new Date(appointment.date).toLocaleDateString()}`
        );

        // Auto-approval logic (only for properties in system)
        if (property && property.ownerId) {
          const ownerSettings = await storage.getOwnerSettings(property.ownerId);
          
          // Check if auto-approval is enabled and property has valid access
          if (ownerSettings?.autoApproveAppointments) {
            const accessInfo = property.accessInfo as any;
            let shouldAutoApprove = false;
            
            // Check if has lockbox OR smart lock with ongoing validity
            if (accessInfo?.accessType === "unattended") {
              if (accessInfo.method === "lockbox" && accessInfo.lockboxCode) {
                shouldAutoApprove = true;
              } else if (accessInfo.method === "smart_lock" && accessInfo.smartLockCode) {
                // Only auto-approve if smart lock doesn't expire same day or has ongoing validity
                if (accessInfo.smartLockExpirationDuration === "ongoing") {
                  shouldAutoApprove = true;
                }
              }
            }
            
            if (shouldAutoApprove) {
              // Auto-approve the appointment
              const approvedAppointment = await storage.updateAppointment(appointment.id, {
                ownerApprovalStatus: "approved",
                ownerApprovedAt: new Date(),
                ownerApprovalNotes: "Aprobada automáticamente por configuración del propietario",
              });
              
              // Create notifications for concierge, client, and admin
              const notifications = [];
              
              // Notify concierge if assigned
              if (appointment.conciergeId) {
                notifications.push(
                  storage.createNotification({
                    userId: appointment.conciergeId,
                    type: "appointment",
                    title: "Cita Aprobada Automáticamente",
                    message: `La cita para ${property.title} el ${new Date(appointment.date).toLocaleDateString()} ha sido aprobada automáticamente`,
                    relatedEntityType: "appointment",
                    relatedEntityId: appointment.id,
                    priority: "medium",
                  })
                );
              }
              
              // Notify client
              notifications.push(
                storage.createNotification({
                  userId: appointment.clientId,
                  type: "appointment",
                  title: "Cita Aprobada",
                  message: `Tu cita para ${property.title} el ${new Date(appointment.date).toLocaleDateString()} ha sido aprobada`,
                  relatedEntityType: "appointment",
                  relatedEntityId: appointment.id,
                  priority: "high",
                })
              );
              
              // Notify admins
              const admins = await storage.getUsers({ role: "admin" });
              for (const admin of admins) {
                notifications.push(
                  storage.createNotification({
                    userId: admin.id,
                    type: "appointment",
                    title: "Cita Aprobada Automáticamente",
                    message: `Cita para ${property.title} aprobada automáticamente el ${new Date(appointment.date).toLocaleDateString()}`,
                    relatedEntityType: "appointment",
                    relatedEntityId: appointment.id,
                    priority: "low",
                  })
                );
              }
              
              // Create all notifications
              await Promise.all(notifications);
              
              // Log auto-approval
              await createAuditLog(
                req,
                "update",
                "appointment",
                appointment.id,
                `Cita auto-aprobada para ${property.title}`
              );
              
              res.status(201).json(approvedAppointment);
              return;
            }
          }
        }

        res.status(201).json(appointment);
      } catch (dbError) {
        // Rollback: Delete Google Meet event if appointment creation fails
        if (googleEventId) {
          try {
            await deleteGoogleMeetEvent(googleEventId);
            console.log(`Rolled back Google Meet event ${googleEventId} due to appointment creation failure`);
          } catch (rollbackError) {
            console.error("Error rolling back Google Meet event:", rollbackError);
          }
        }
        throw dbError;
      }
    } catch (error: any) {
      return handleGenericError(res, error, "al crear la cita");
    }
  });

  app.patch("/api/appointments/:id", isAuthenticated, requireResourceOwnership('appointment'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const appointment = await storage.updateAppointment(id, req.body);
      
      // Log appointment update
      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `Cita actualizada - Estado: ${appointment.status}`
      );
      
      res.json(appointment);
    } catch (error) {
      console.error("Error updating appointment:", error);
      res.status(500).json({ message: "Failed to update appointment" });
    }
  });

  app.delete("/api/appointments/:id", isAuthenticated, requireResourceOwnership('appointment'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const appointment = await storage.getAppointment(id);

      // Log appointment deletion (before deletion to capture details)
      if (appointment) {
        const property = await storage.getProperty(appointment.propertyId);
        await createAuditLog(
          req,
          "delete",
          "appointment",
          id,
          `Cita cancelada para ${property?.title || "propiedad"} - ${new Date(appointment.date).toLocaleDateString()}`
        );
      }

      if (appointment?.googleEventId) {
        await deleteGoogleMeetEvent(appointment.googleEventId);
      }

      await storage.deleteAppointment(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting appointment:", error);
      res.status(500).json({ message: "Failed to delete appointment" });
    }
  });

  // Seller/Admin Appointment Management Routes
  // Create appointment with lead (seller can only use their own leads)
  app.post("/api/seller/appointments/create-with-lead", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    let googleEventId: string | null = null;
    
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const { leadId, propertyId, condominiumName, unitNumber, date, type, notes } = req.body;

      // Validate required fields
      if (!leadId || !date || !type) {
        return res.status(400).json({ message: "Lead, fecha y tipo son requeridos" });
      }

      // Validate property input: must have propertyId OR (condominiumName + unitNumber)
      if (!propertyId && (!condominiumName || !unitNumber)) {
        return res.status(400).json({ message: "Debes proporcionar un ID de propiedad O nombre de condominio y número de unidad" });
      }

      // Verify lead exists and belongs to seller (unless admin)
      const lead = await storage.getLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead no encontrado" });
      }

      // Sellers can only create appointments with their own leads
      if (user?.role === "seller" && lead.registeredById !== userId) {
        return res.status(403).json({ message: "Solo puedes crear citas con leads que tú registraste" });
      }

      // Verify property exists and is published (only if propertyId provided)
      let property = null;
      if (propertyId) {
        property = await storage.getProperty(propertyId);
        if (!property) {
          return res.status(404).json({ message: "Propiedad no encontrada" });
        }

        if (!property.published) {
          return res.status(400).json({ message: "Solo puedes crear citas con propiedades publicadas" });
        }
      }

      // Use clientId if lead is registered, otherwise use lead contact info
      const clientId = lead.userId || undefined;
      const leadContactInfo = !clientId ? {
        leadId: lead.id,
        leadEmail: lead.email,
        leadPhone: lead.phoneNumber || undefined,
        leadName: `${lead.firstName} ${lead.lastName}`,
      } : {};

      // Create Google Meet event if type is video
      let meetLink = null;
      const propertyTitle = property ? property.title : `${condominiumName} - ${unitNumber}`;
      
      if (type === "video") {
        const appointmentDate = new Date(date);
        const endDate = new Date(appointmentDate.getTime() + 60 * 60 * 1000); // 1 hour later

        try {
          const eventResult = await createGoogleMeetEvent({
            summary: `Visita Virtual: ${propertyTitle}`,
            description: `Cita virtual para visitar la propiedad`,
            start: appointmentDate,
            end: endDate,
            attendees: [],
          });

          if (eventResult) {
            meetLink = eventResult.meetLink;
            googleEventId = eventResult.eventId;
          }
        } catch (meetError) {
          console.error("Error creating Google Meet event:", meetError);
        }
      }

      // Create appointment with auto-approved status
      const appointment = await storage.createAppointment({
        propertyId: propertyId || undefined,
        condominiumName: condominiumName || undefined,
        unitNumber: unitNumber || undefined,
        clientId,
        ...leadContactInfo, // Include lead info if no clientId
        date: new Date(date),
        type,
        mode: "individual",
        status: "confirmed", // Auto-confirmed for seller-created appointments
        ownerApprovalStatus: "approved",
        ownerApprovedAt: new Date(),
        ownerApprovalNotes: `Cita creada por ${user?.role} ${user?.firstName} ${user?.lastName}`,
        visitType: "visita_cliente",
        notes,
        meetLink,
        googleEventId: googleEventId || undefined,
      });

      // Update lead status if needed
      if (lead.status === "nuevo" || lead.status === "contactado" || lead.status === "calificado") {
        await storage.updateLeadStatus(leadId, "visita_agendada");
      }

      await createAuditLog(
        req,
        "create",
        "appointment",
        appointment.id,
        `${user?.role} creó cita con lead ${lead.firstName} ${lead.lastName} para ${propertyTitle}`
      );

      // Notify client about the appointment (only if registered user)
      if (clientId) {
        await storage.createNotification({
          userId: clientId,
          type: "appointment",
          title: "Nueva Cita Agendada",
          message: `Se ha agendado una cita para visitar ${propertyTitle} el ${new Date(date).toLocaleDateString()}`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        });
      }

      res.status(201).json(appointment);
    } catch (error: any) {
      // Rollback Google Meet event if appointment creation fails
      if (googleEventId) {
        try {
          await deleteGoogleMeetEvent(googleEventId);
        } catch (rollbackError) {
          console.error("Error rolling back Google Meet event:", rollbackError);
        }
      }
      console.error("Error creating appointment with lead:", error);
      res.status(500).json({ message: error.message || "Error al crear cita con lead" });
    }
  });

  // Seller/Admin approve appointment directly
  app.post("/api/seller/appointments/:id/approve", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Update appointment to confirmed
      const updated = await storage.updateAppointment(id, {
        status: "confirmed",
        ownerApprovalStatus: "approved",
        ownerApprovedAt: new Date(),
        ownerApprovalNotes: `Aprobada por ${user?.role} ${user?.firstName} ${user?.lastName}`,
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `${user?.role} aprobó cita directamente`
      );

      // Notify client (only if they have a user account)
      if (appointment.clientId) {
        await storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Cita Aprobada",
          message: `Tu cita ha sido aprobada`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        });
      }

      res.json(updated);
    } catch (error: any) {
      console.error("Error approving appointment:", error);
      res.status(500).json({ message: error.message || "Error al aprobar cita" });
    }
  });

  // Seller/Admin cancel appointment directly
  app.post("/api/seller/appointments/:id/cancel", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      // Cancel appointment
      const updated = await storage.updateAppointment(id, {
        status: "cancelled",
      });

      // Delete Google Meet event if exists
      if (appointment.googleEventId) {
        try {
          await deleteGoogleMeetEvent(appointment.googleEventId);
        } catch (error) {
          console.error("Error deleting Google Meet event:", error);
        }
      }

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `${user?.role} canceló cita${reason ? `: ${reason}` : ""}`
      );

      // Notify client (only if they have a user account)
      if (appointment.clientId) {
        await storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Cita Cancelada",
          message: `Tu cita ha sido cancelada${reason ? `: ${reason}` : ""}`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        });
      }

      res.json(updated);
    } catch (error: any) {
      console.error("Error cancelling appointment:", error);
      res.status(500).json({ message: error.message || "Error al cancelar cita" });
    }
  });

  // Seller/Admin reschedule appointment directly
  app.patch("/api/seller/appointments/:id/reschedule", isAuthenticated, requireRole(["master", "admin", "admin_jr", "seller", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { newDate } = req.body;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      if (!newDate) {
        return res.status(400).json({ message: "Nueva fecha es requerida" });
      }

      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Cita no encontrada" });
      }

      const oldDate = new Date(appointment.date);

      // Update appointment date directly
      const updated = await storage.updateAppointment(id, {
        date: new Date(newDate),
        rescheduleStatus: "none", // Reset reschedule status since this is direct change
      });

      await createAuditLog(
        req,
        "update",
        "appointment",
        id,
        `${user?.role} reprogramó cita de ${oldDate.toLocaleDateString()} a ${new Date(newDate).toLocaleDateString()}`
      );

      // Notify client (only if they have a user account)
      if (appointment.clientId) {
        await storage.createNotification({
          userId: appointment.clientId,
          type: "appointment",
          title: "Cita Reprogramada",
          message: `Tu cita ha sido reprogramada para el ${new Date(newDate).toLocaleDateString()}`,
          relatedEntityType: "appointment",
          relatedEntityId: appointment.id,
          priority: "high",
        });
      }

      res.json(updated);
    } catch (error: any) {
      console.error("Error rescheduling appointment:", error);
      res.status(500).json({ message: error.message || "Error al reprogramar cita" });
    }
  });

  // Calendar Events routes
  app.get("/api/calendar-events", isAuthenticated, async (req, res) => {
    try {
      const { eventType, assignedToId, status, propertyId, startDate, endDate } = req.query;
      const filters: any = {};
      if (eventType) filters.eventType = eventType;
      if (assignedToId) filters.assignedToId = assignedToId;
      if (status) filters.status = status;
      if (propertyId) filters.propertyId = propertyId;
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);

      const events = await storage.getCalendarEvents(filters);
      res.json(events);
    } catch (error) {
      console.error("Error fetching calendar events:", error);
      res.status(500).json({ message: "Failed to fetch calendar events" });
    }
  });

  app.post("/api/calendar-events", isAuthenticated, requireRole(["master", "admin", "admin_jr", "management"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Include createdById before validation
      const eventData = {
        ...req.body,
        startDate: new Date(req.body.startDate),
        endDate: new Date(req.body.endDate),
        createdById: userId,
      };

      // Validate complete event data
      const validatedData = insertCalendarEventSchema.parse(eventData);

      const event = await storage.createCalendarEvent(validatedData);

      await createAuditLog(
        req,
        "create",
        "calendar_event",
        event.id,
        `Evento de calendario creado: ${event.title} - ${event.eventType}`
      );

      res.status(201).json(event);
    } catch (error: any) {
      console.error("Error creating calendar event:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(400).json({ message: error.message || "Failed to create calendar event" });
    }
  });

  app.patch("/api/calendar-events/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Validate and coerce dates if present
      const updates = { ...req.body };
      if (updates.startDate) {
        updates.startDate = new Date(updates.startDate);
      }
      if (updates.endDate) {
        updates.endDate = new Date(updates.endDate);
      }

      // Use partial validation
      const validatedData = insertCalendarEventSchema.partial().parse(updates);
      
      const event = await storage.updateCalendarEvent(id, validatedData);

      await createAuditLog(
        req,
        "update",
        "calendar_event",
        id,
        `Evento de calendario actualizado: ${event.title} - Estado: ${event.status}`
      );

      res.json(event);
    } catch (error: any) {
      console.error("Error updating calendar event:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to update calendar event" });
    }
  });

  app.delete("/api/calendar-events/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr", "management"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const event = await storage.getCalendarEvent(id);

      if (event) {
        await createAuditLog(
          req,
          "delete",
          "calendar_event",
          id,
          `Evento de calendario eliminado: ${event.title}`
        );
      }

      await storage.deleteCalendarEvent(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting calendar event:", error);
      res.status(500).json({ message: "Failed to delete calendar event" });
    }
  });

  // Business Hours routes
  app.get("/api/business-hours", async (req, res) => {
    try {
      const hours = await storage.getBusinessHours();
      res.json(hours);
    } catch (error) {
      console.error("Error fetching business hours:", error);
      res.status(500).json({ message: "Error al obtener los horarios de atención" });
    }
  });

  app.put("/api/business-hours/:dayOfWeek", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { dayOfWeek } = req.params;
      const { isOpen, openTime, closeTime } = req.body;

      const updatedHours = await storage.upsertBusinessHours({
        dayOfWeek: parseInt(dayOfWeek),
        isOpen,
        openTime,
        closeTime,
      });

      await createAuditLog(
        req,
        "update",
        "business_hours",
        updatedHours.id,
        `Horario de atención actualizado para el día ${dayOfWeek}`
      );

      res.json(updatedHours);
    } catch (error) {
      console.error("Error updating business hours:", error);
      res.status(500).json({ message: "Error al actualizar los horarios de atención" });
    }
  });

  // Concierge Blocked Slots routes
  app.get("/api/concierge-blocked-slots", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Usuario no encontrado" });
      }

      // Conserjes ven solo sus slots, admins ven todos
      let slots;
      if (user.role === "concierge") {
        slots = await storage.getConciergeBlockedSlots(userId);
      } else if (["master", "admin", "admin_jr"].includes(user.role)) {
        // Admins can filter by conciergeId
        const { conciergeId } = req.query;
        slots = conciergeId 
          ? await storage.getConciergeBlockedSlots(conciergeId as string)
          : [];
      } else {
        return res.status(403).json({ message: "No autorizado" });
      }

      res.json(slots);
    } catch (error) {
      console.error("Error fetching concierge blocked slots:", error);
      res.status(500).json({ message: "Error al obtener los horarios bloqueados" });
    }
  });

  app.post("/api/concierge-blocked-slots", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const user = await storage.getUser(userId);
      if (!user || user.role !== "concierge") {
        return res.status(403).json({ message: "Solo los conserjes pueden bloquear horarios" });
      }

      const { startTime, endTime, reason } = req.body;

      // Validate no confirmed appointments exist in this timeframe
      const appointments = await storage.getAppointments({
        status: "confirmed",
      });

      const startDate = new Date(startTime);
      const endDate = new Date(endTime);

      const conflictingAppointments = appointments.filter((apt: any) => {
        if (apt.conciergeId !== userId) return false;
        const aptDate = new Date(apt.date);
        return aptDate >= startDate && aptDate <= endDate;
      });

      if (conflictingAppointments.length > 0) {
        return res.status(400).json({ 
          message: "No puedes bloquear horarios con citas confirmadas",
          conflictingAppointments: conflictingAppointments.length
        });
      }

      const slot = await storage.createConciergeBlockedSlot({
        conciergeId: userId,
        startTime: startDate,
        endTime: endDate,
        reason,
      });

      await createAuditLog(
        req,
        "create",
        "concierge_blocked_slot",
        slot.id,
        `Horario bloqueado: ${startTime} - ${endTime}`
      );

      res.status(201).json(slot);
    } catch (error) {
      console.error("Error creating concierge blocked slot:", error);
      res.status(500).json({ message: "Error al bloquear el horario" });
    }
  });

  app.delete("/api/concierge-blocked-slots/:id", isAuthenticated, requireResourceOwnership('blocked-slot', 'conciergeId'), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const { id } = req.params;
      const slot = await storage.getConciergeBlockedSlot(id);

      if (!slot) {
        return res.status(404).json({ message: "Horario bloqueado no encontrado" });
      }

      // Only the owner concierge can delete their blocked slots
      if (slot.conciergeId !== userId) {
        return res.status(403).json({ message: "No autorizado para eliminar este horario" });
      }

      await storage.deleteConciergeBlockedSlot(id);

      await createAuditLog(
        req,
        "delete",
        "concierge_blocked_slot",
        id,
        `Horario desbloqueado`
      );

      res.json({ message: "Horario desbloqueado exitosamente" });
    } catch (error) {
      console.error("Error deleting concierge blocked slot:", error);
      res.status(500).json({ message: "Error al desbloquear el horario" });
    }
  });

  // Review routes
  // Property Reviews
  app.get("/api/reviews/properties", async (req, res) => {
    try {
      const { propertyId, clientId } = req.query;
      const filters: any = {};
      if (propertyId) filters.propertyId = propertyId;
      if (clientId) filters.clientId = clientId;
      const reviews = await storage.getPropertyReviews(filters);
      res.json(reviews);
    } catch (error) {
      console.error("Error fetching property reviews:", error);
      res.status(500).json({ message: "Failed to fetch property reviews" });
    }
  });

  app.post("/api/reviews/properties", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Security: Remove clientId from body to prevent impersonation
      const { clientId: _, ...bodyWithoutClientId } = req.body;
      
      // Enforce authenticated user as the reviewer
      const reviewData = {
        ...bodyWithoutClientId,
        clientId: userId,
      };
      
      const review = await storage.createPropertyReview(reviewData);
      
      await createAuditLog(
        req,
        "create",
        "property_review",
        review.id,
        `Review creado para propiedad ${review.propertyId} - Rating: ${review.rating}`
      );
      
      res.status(201).json(review);
    } catch (error: any) {
      console.error("Error creating property review:", error);
      res.status(400).json({ message: error.message || "Failed to create property review" });
    }
  });

  // Appointment Reviews
  app.get("/api/reviews/appointments", isAuthenticated, async (req, res) => {
    try {
      const { appointmentId, clientId } = req.query;
      const filters: any = {};
      if (appointmentId) filters.appointmentId = appointmentId;
      if (clientId) filters.clientId = clientId;
      const reviews = await storage.getAppointmentReviews(filters);
      res.json(reviews);
    } catch (error) {
      console.error("Error fetching appointment reviews:", error);
      res.status(500).json({ message: "Failed to fetch appointment reviews" });
    }
  });

  app.post("/api/reviews/appointments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Security: Remove clientId from body to prevent impersonation
      const { clientId: _, ...bodyWithoutClientId } = req.body;
      
      // Optional: Verify user attended the appointment
      if (req.body.appointmentId) {
        const appointment = await storage.getAppointment(req.body.appointmentId);
        if (!appointment || appointment.clientId !== userId) {
          return res.status(403).json({ 
            message: "Solo puedes dejar reviews de citas a las que asististe" 
          });
        }
      }
      
      // Enforce authenticated user as the reviewer
      const reviewData = {
        ...bodyWithoutClientId,
        clientId: userId,
      };
      
      const review = await storage.createAppointmentReview(reviewData);
      
      await createAuditLog(
        req,
        "create",
        "appointment_review",
        review.id,
        `Review creado para cita ${review.appointmentId} - Rating: ${review.rating}`
      );
      
      res.status(201).json(review);
    } catch (error: any) {
      console.error("Error creating appointment review:", error);
      res.status(400).json({ message: error.message || "Failed to create appointment review" });
    }
  });

  // Concierge Reviews (from clients)
  app.get("/api/reviews/concierges", async (req, res) => {
    try {
      const { conciergeId, clientId } = req.query;
      const filters: any = {};
      if (conciergeId) filters.conciergeId = conciergeId;
      if (clientId) filters.clientId = clientId;
      const reviews = await storage.getConciergeReviews(filters);
      res.json(reviews);
    } catch (error) {
      console.error("Error fetching concierge reviews:", error);
      res.status(500).json({ message: "Failed to fetch concierge reviews" });
    }
  });

  app.post("/api/reviews/concierges", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Security: Remove clientId from body to prevent impersonation
      const { clientId: _, ...bodyWithoutClientId } = req.body;
      
      // Enforce authenticated user as the reviewer
      const reviewData = {
        ...bodyWithoutClientId,
        clientId: userId,
      };
      
      const review = await storage.createConciergeReview(reviewData);
      
      await createAuditLog(
        req,
        "create",
        "concierge_review",
        review.id,
        `Review creado para conserje ${review.conciergeId} - Rating: ${review.rating}`
      );
      
      res.status(201).json(review);
    } catch (error: any) {
      console.error("Error creating concierge review:", error);
      res.status(400).json({ message: error.message || "Failed to create concierge review" });
    }
  });

  // Client Reviews (from concierges)
  app.get("/api/reviews/clients", isAuthenticated, async (req: any, res) => {
    try {
      const { clientId, conciergeId } = req.query;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Only concierges can view client reviews
      if (user?.role !== "concierge" && !["admin", "master", "admin_jr"].includes(user?.role as string)) {
        return res.status(403).json({ message: "Acceso denegado" });
      }
      
      const filters: any = {};
      if (clientId) filters.clientId = clientId;
      if (conciergeId) filters.conciergeId = conciergeId;
      const reviews = await storage.getClientReviews(filters);
      res.json(reviews);
    } catch (error) {
      console.error("Error fetching client reviews:", error);
      res.status(500).json({ message: "Failed to fetch client reviews" });
    }
  });

  app.post("/api/reviews/clients", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Security: Only concierges can create client reviews
      if (user?.role !== "concierge") {
        return res.status(403).json({ message: "Solo los conserjes pueden dejar reviews de clientes" });
      }
      
      // Security: Remove conciergeId from body to prevent impersonation
      const { conciergeId: _, ...bodyWithoutConciergeId } = req.body;
      
      // Enforce authenticated concierge as the reviewer
      const reviewData = {
        ...bodyWithoutConciergeId,
        conciergeId: userId,
      };
      
      const review = await storage.createClientReview(reviewData);
      
      await createAuditLog(
        req,
        "create",
        "client_review",
        review.id,
        `Review creado para cliente ${review.clientId} - Rating: ${review.rating}`
      );
      
      res.status(201).json(review);
    } catch (error: any) {
      console.error("Error creating client review:", error);
      res.status(400).json({ message: error.message || "Failed to create client review" });
    }
  });

  // Presentation card routes
  app.get("/api/presentation-cards", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Admin and master can see all cards if they pass a clientId
      // Regular users can only see their own cards
      let clientId: string | undefined;
      
      if (user && ["admin", "master"].includes(user.role)) {
        clientId = req.query.clientId as string;
      } else {
        // Force regular users to only see their own cards
        clientId = userId;
      }
      
      const cards = await storage.getPresentationCards(clientId);
      res.json(cards);
    } catch (error) {
      console.error("Error fetching presentation cards:", error);
      res.status(500).json({ message: "Failed to fetch presentation cards" });
    }
  });

  app.get("/api/presentation-cards/:id/matches", async (req, res) => {
    try {
      const { id } = req.params;
      const properties = await storage.matchPropertiesForCard(id);
      res.json(properties);
    } catch (error) {
      console.error("Error matching properties:", error);
      res.status(500).json({ message: "Failed to match properties" });
    }
  });

  app.post("/api/presentation-cards", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      // Always use authenticated user's ID as clientId to prevent spoofing
      const clientId = userId;

      // Check if user already has 3 cards
      const existingCards = await db
        .select()
        .from(presentationCards)
        .where(eq(presentationCards.clientId, clientId));

      if (existingCards.length >= 3) {
        return res.status(400).json({ 
          message: "Has alcanzado el límite de 3 tarjetas de presentación. Elimina una existente para crear una nueva." 
        });
      }

      const cardData = insertPresentationCardSchema.parse({
        ...req.body,
        clientId,
      });

      const card = await storage.createPresentationCard(cardData);
      res.status(201).json(card);
    } catch (error: any) {
      console.error("Error creating presentation card:", error);
      res.status(400).json({ message: error.message || "Failed to create presentation card" });
    }
  });

  app.patch("/api/presentation-cards/:id", isAuthenticated, requireResourceOwnership('presentation-card', 'clientId'), async (req, res) => {
    try {
      const { id } = req.params;
      const card = await storage.updatePresentationCard(id, req.body);
      res.json(card);
    } catch (error) {
      console.error("Error updating presentation card:", error);
      res.status(500).json({ message: "Failed to update presentation card" });
    }
  });

  app.delete("/api/presentation-cards/:id", isAuthenticated, requireResourceOwnership('presentation-card', 'clientId'), async (req, res) => {
    try {
      const { id} = req.params;
      await storage.deletePresentationCard(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting presentation card:", error);
      res.status(500).json({ message: "Failed to delete presentation card" });
    }
  });

  // Activate/deactivate presentation card
  app.patch("/api/presentation-cards/:id/toggle-active", isAuthenticated, requireResourceOwnership('presentation-card', 'clientId'), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;

      // First, find the card and check its current state
      const existingCard = await db.query.presentationCards.findFirst({
        where: and(
          eq(presentationCards.id, id),
          eq(presentationCards.clientId, userId)
        )
      });

      if (!existingCard) {
        return res.status(404).json({ message: "Presentation card not found" });
      }

      // If activating, deactivate all other cards first
      if (!existingCard.isActive) {
        await db.update(presentationCards)
          .set({ isActive: false })
          .where(eq(presentationCards.clientId, userId));
      }

      // Toggle the card's active state
      const card = await db.update(presentationCards)
        .set({ isActive: !existingCard.isActive })
        .where(and(
          eq(presentationCards.id, id),
          eq(presentationCards.clientId, userId)
        ))
        .returning();

      res.json(card[0]);
    } catch (error) {
      console.error("Error toggling presentation card:", error);
      res.status(500).json({ message: "Failed to toggle presentation card" });
    }
  });

  // Property Recommendations routes (seller to client)
  app.post("/api/property-recommendations", isAuthenticated, async (req: any, res) => {
    try {
      const sellerId = req.user.claims.sub;
      const { propertyId, clientId, presentationCardId, message } = req.body;

      const recommendation = await db.insert(propertyRecommendations)
        .values({
          propertyId,
          clientId,
          sellerId,
          presentationCardId: presentationCardId || null,
          message: message || null,
        })
        .returning();

      res.status(201).json(recommendation[0]);
    } catch (error) {
      console.error("Error creating recommendation:", error);
      res.status(500).json({ message: "Failed to create recommendation" });
    }
  });

  app.get("/api/my-property-recommendations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const recommendations = await db
        .select({
          id: propertyRecommendations.id,
          propertyId: propertyRecommendations.propertyId,
          sellerId: propertyRecommendations.sellerId,
          presentationCardId: propertyRecommendations.presentationCardId,
          message: propertyRecommendations.message,
          isRead: propertyRecommendations.isRead,
          isInterested: propertyRecommendations.isInterested,
          createdAt: propertyRecommendations.createdAt,
        })
        .from(propertyRecommendations)
        .where(eq(propertyRecommendations.clientId, userId))
        .orderBy(desc(propertyRecommendations.createdAt));

      // Enrich with property and seller data
      const enriched = await Promise.all(
        recommendations.map(async (rec) => {
          const property = await db.select().from(properties).where(eq(properties.id, rec.propertyId)).limit(1);
          const seller = await db.select().from(users).where(eq(users.id, rec.sellerId)).limit(1);
          return {
            ...rec,
            property: property[0] || null,
            seller: seller[0] ? { 
              id: seller[0].id, 
              firstName: seller[0].firstName, 
              lastName: seller[0].lastName,
              profileImageUrl: seller[0].profileImageUrl
            } : null,
          };
        })
      );

      res.json(enriched);
    } catch (error) {
      console.error("Error fetching recommendations:", error);
      res.status(500).json({ message: "Failed to fetch recommendations" });
    }
  });

  app.patch("/api/property-recommendations/:id/mark-read", isAuthenticated, requireResourceOwnership('property-recommendation', 'clientId'), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;

      const recommendation = await db.update(propertyRecommendations)
        .set({ isRead: true })
        .where(and(
          eq(propertyRecommendations.id, id),
          eq(propertyRecommendations.clientId, userId)
        ))
        .returning();

      if (!recommendation[0]) {
        return res.status(404).json({ message: "Recommendation not found" });
      }

      res.json(recommendation[0]);
    } catch (error) {
      console.error("Error marking recommendation as read:", error);
      res.status(500).json({ message: "Failed to mark recommendation as read" });
    }
  });

  app.patch("/api/property-recommendations/:id/set-interest", isAuthenticated, requireResourceOwnership('property-recommendation', 'clientId'), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const { isInterested } = req.body;

      const recommendation = await db.update(propertyRecommendations)
        .set({ isInterested, isRead: true })
        .where(and(
          eq(propertyRecommendations.id, id),
          eq(propertyRecommendations.clientId, userId)
        ))
        .returning();

      if (!recommendation[0]) {
        return res.status(404).json({ message: "Recommendation not found" });
      }

      res.json(recommendation[0]);
    } catch (error) {
      console.error("Error setting interest:", error);
      res.status(500).json({ message: "Failed to set interest" });
    }
  });

  // Auto Suggestions routes
  app.get("/api/my-auto-suggestions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const suggestions = await db
        .select({
          id: autoSuggestions.id,
          propertyId: autoSuggestions.propertyId,
          presentationCardId: autoSuggestions.presentationCardId,
          matchScore: autoSuggestions.matchScore,
          matchReasons: autoSuggestions.matchReasons,
          isRead: autoSuggestions.isRead,
          isInterested: autoSuggestions.isInterested,
          createdAt: autoSuggestions.createdAt,
        })
        .from(autoSuggestions)
        .where(eq(autoSuggestions.clientId, userId))
        .orderBy(desc(autoSuggestions.matchScore), desc(autoSuggestions.createdAt));

      // Enrich with property data
      const enriched = await Promise.all(
        suggestions.map(async (sug) => {
          const property = await db.select().from(properties).where(eq(properties.id, sug.propertyId)).limit(1);
          return {
            ...sug,
            property: property[0] || null,
          };
        })
      );

      res.json(enriched);
    } catch (error) {
      console.error("Error fetching auto suggestions:", error);
      res.status(500).json({ message: "Failed to fetch auto suggestions" });
    }
  });

  app.patch("/api/auto-suggestions/:id/mark-read", isAuthenticated, requireResourceOwnership('auto-suggestion', 'clientId'), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;

      const suggestion = await db.update(autoSuggestions)
        .set({ isRead: true })
        .where(and(
          eq(autoSuggestions.id, id),
          eq(autoSuggestions.clientId, userId)
        ))
        .returning();

      if (!suggestion[0]) {
        return res.status(404).json({ message: "Suggestion not found" });
      }

      res.json(suggestion[0]);
    } catch (error) {
      console.error("Error marking suggestion as read:", error);
      res.status(500).json({ message: "Failed to mark suggestion as read" });
    }
  });

  app.patch("/api/auto-suggestions/:id/set-interest", isAuthenticated, requireResourceOwnership('auto-suggestion', 'clientId'), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const { isInterested } = req.body;

      const suggestion = await db.update(autoSuggestions)
        .set({ isInterested, isRead: true })
        .where(and(
          eq(autoSuggestions.id, id),
          eq(autoSuggestions.clientId, userId)
        ))
        .returning();

      if (!suggestion[0]) {
        return res.status(404).json({ message: "Suggestion not found" });
      }

      res.json(suggestion[0]);
    } catch (error) {
      console.error("Error setting interest:", error);
      res.status(500).json({ message: "Failed to set interest" });
    }
  });

  // Service provider routes
  app.get("/api/service-providers", async (req, res) => {
    try {
      const { specialty, available } = req.query;
      const filters: any = {};
      if (specialty) filters.specialty = specialty;
      if (available !== undefined) filters.available = available === "true";

      const providers = await storage.getServiceProviders(filters);
      res.json(providers);
    } catch (error) {
      console.error("Error fetching service providers:", error);
      res.status(500).json({ message: "Failed to fetch service providers" });
    }
  });

  app.post("/api/service-providers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const providerData = insertServiceProviderSchema.parse({
        ...req.body,
        userId,
      });

      const provider = await storage.createServiceProvider(providerData);
      res.status(201).json(provider);
    } catch (error: any) {
      console.error("Error creating service provider:", error);
      res.status(400).json({ message: error.message || "Failed to create service provider" });
    }
  });

  app.patch("/api/service-providers/:id", isAuthenticated, requireResourceOwnership('service-provider', 'userId'), async (req, res) => {
    try {
      const { id } = req.params;
      const provider = await storage.updateServiceProvider(id, req.body);
      res.json(provider);
    } catch (error) {
      console.error("Error updating service provider:", error);
      res.status(500).json({ message: "Failed to update service provider" });
    }
  });

  // Service routes
  app.get("/api/service-providers/:id/services", async (req, res) => {
    try {
      const { id } = req.params;
      const services = await storage.getServicesByProvider(id);
      res.json(services);
    } catch (error) {
      console.error("Error fetching services:", error);
      res.status(500).json({ message: "Failed to fetch services" });
    }
  });

  app.post("/api/services", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get the service provider for this user
      const providers = await storage.getServiceProviders({ userId });
      if (!providers || providers.length === 0) {
        return res.status(403).json({ message: "You must be a registered service provider to create services" });
      }
      
      const provider = providers[0];
      
      // Force providerId from authenticated user's service provider
      const serviceData = insertServiceSchema.parse({
        ...req.body,
        providerId: provider.id,
      });
      
      const service = await storage.createService(serviceData);
      res.status(201).json(service);
    } catch (error: any) {
      console.error("Error creating service:", error);
      res.status(400).json({ message: error.message || "Failed to create service" });
    }
  });

  app.patch("/api/services/:id", isAuthenticated, requireResourceOwnership('service', 'providerId'), async (req, res) => {
    try {
      const { id } = req.params;
      const service = await storage.updateService(id, req.body);
      res.json(service);
    } catch (error) {
      console.error("Error updating service:", error);
      res.status(500).json({ message: "Failed to update service" });
    }
  });

  app.delete("/api/services/:id", isAuthenticated, requireResourceOwnership('service', 'providerId'), async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteService(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting service:", error);
      res.status(500).json({ message: "Failed to delete service" });
    }
  });

  // Service Booking routes
  app.get("/api/service-bookings", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const { clientId, providerId, status } = req.query;
      
      const filters: any = {};
      
      if (clientId) {
        filters.clientId = clientId;
      } else if (user?.role !== "master" && user?.role !== "admin") {
        filters.clientId = userId;
      }
      
      if (providerId) filters.providerId = providerId;
      if (status) filters.status = status;

      const bookings = await storage.getServiceBookings(filters);
      res.json(bookings);
    } catch (error) {
      console.error("Error fetching service bookings:", error);
      res.status(500).json({ message: "Failed to fetch service bookings" });
    }
  });

  app.post("/api/service-bookings", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const bookingData = insertServiceBookingSchema.parse({
        ...req.body,
        clientId: userId,
      });
      
      const booking = await storage.createServiceBooking(bookingData);
      
      await createAuditLog(req, "create", "service_booking", booking.id, 
        `Created service booking for service ${booking.serviceId}`);
      
      res.status(201).json(booking);
    } catch (error: any) {
      console.error("Error creating service booking:", error);
      res.status(400).json({ message: error.message || "Failed to create service booking" });
    }
  });

  app.patch("/api/service-bookings/:id", isAuthenticated, requireResourceOwnership('service-booking', 'clientId'), async (req, res) => {
    try {
      const { id } = req.params;
      const booking = await storage.updateServiceBooking(id, req.body);
      res.json(booking);
    } catch (error) {
      console.error("Error updating service booking:", error);
      res.status(500).json({ message: "Failed to update service booking" });
    }
  });

  app.delete("/api/service-bookings/:id", isAuthenticated, requireResourceOwnership('service-booking', 'clientId'), async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteServiceBooking(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting service booking:", error);
      res.status(500).json({ message: "Failed to delete service booking" });
    }
  });

  // Provider Application routes
  app.post("/api/provider-applications", async (req, res) => {
    try {
      const applicationData = insertProviderApplicationSchema.parse({
        ...req.body,
        status: "pending",
      });
      
      const application = await storage.createProviderApplication(applicationData);
      res.status(201).json(application);
    } catch (error: any) {
      console.error("Error creating provider application:", error);
      res.status(400).json({ message: error.message || "Failed to create provider application" });
    }
  });

  app.get("/api/provider-applications", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { status } = req.query;
      const filters: any = {};
      if (status && typeof status === "string") {
        filters.status = status;
      }
      
      const applications = await storage.getProviderApplications(filters);
      res.json(applications);
    } catch (error) {
      console.error("Error fetching provider applications:", error);
      res.status(500).json({ message: "Failed to fetch provider applications" });
    }
  });

  app.get("/api/provider-applications/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const application = await storage.getProviderApplication(id);
      
      if (!application) {
        return res.status(404).json({ message: "Provider application not found" });
      }
      
      res.json(application);
    } catch (error) {
      console.error("Error fetching provider application:", error);
      res.status(500).json({ message: "Failed to fetch provider application" });
    }
  });

  app.patch("/api/provider-applications/:id/status", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;
      const adminId = req.user.id;
      
      if (!["approved", "rejected"].includes(status)) {
        return res.status(400).json({ message: "Status must be 'approved' or 'rejected'" });
      }
      
      const application = await storage.updateProviderApplicationStatus(id, status, adminId, notes);
      
      // Log the action
      await createAuditLog(
        req,
        "update",
        "provider_application",
        id,
        `Provider application ${status} - ${application.fullName}`
      );
      
      res.json(application);
    } catch (error: any) {
      console.error("Error updating provider application status:", error);
      res.status(500).json({ message: error.message || "Failed to update provider application status" });
    }
  });

  // Referral Configuration routes
  app.get("/api/referrals/config", isAuthenticated, async (req, res) => {
    try {
      const config = await storage.getReferralConfig();
      res.json(config || { clientReferralCommissionPercent: "5.00", ownerReferralCommissionPercent: "10.00" });
    } catch (error) {
      console.error("Error fetching referral config:", error);
      res.status(500).json({ message: "Failed to fetch referral configuration" });
    }
  });

  app.patch("/api/referrals/config", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { clientReferralCommissionPercent, ownerReferralCommissionPercent } = req.body;

      const config = await storage.updateReferralConfig({
        clientReferralCommissionPercent,
        ownerReferralCommissionPercent,
      }, userId);

      await createAuditLog(
        req,
        "update",
        "referral_config",
        config.id,
        `Configuración de comisiones actualizada - Clientes: ${config.clientReferralCommissionPercent}%, Propietarios: ${config.ownerReferralCommissionPercent}%`
      );

      res.json(config);
    } catch (error: any) {
      console.error("Error updating referral config:", error);
      res.status(500).json({ message: error.message || "Failed to update referral configuration" });
    }
  });

  // Update custom referral percentages for a specific user
  app.patch("/api/admin/users/:userId/referral-config", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId } = req.params;
      const { customClientReferralPercent, customOwnerReferralPercent } = req.body;

      const updates: any = {};
      if (customClientReferralPercent !== undefined) {
        updates.customClientReferralPercent = customClientReferralPercent === null ? null : customClientReferralPercent;
      }
      if (customOwnerReferralPercent !== undefined) {
        updates.customOwnerReferralPercent = customOwnerReferralPercent === null ? null : customOwnerReferralPercent;
      }

      const user = await storage.updateUser(userId, updates);

      await createAuditLog(
        req,
        "update",
        "user",
        userId,
        `Comisiones personalizadas actualizadas - Cliente: ${customClientReferralPercent ?? 'global'}%, Propietario: ${customOwnerReferralPercent ?? 'global'}%`
      );

      res.json(user);
    } catch (error: any) {
      console.error("Error updating user referral config:", error);
      res.status(500).json({ message: error.message || "Failed to update user referral configuration" });
    }
  });

  // Admin: Get all referrals with user information
  app.get("/api/admin/referrals/all", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { userId, type, status } = req.query;
      
      let clientReferrals: any[] = [];
      let ownerReferrals: any[] = [];

      if (!type || type === "client") {
        const clientFilters: any = {};
        if (userId) clientFilters.referrerId = userId;
        if (status) clientFilters.status = status;
        clientReferrals = await storage.getClientReferrals(clientFilters);
      }

      if (!type || type === "owner") {
        const ownerFilters: any = {};
        if (userId) ownerFilters.referrerId = userId;
        if (status) ownerFilters.status = status;
        ownerReferrals = await storage.getOwnerReferrals(ownerFilters);
      }

      // Get unique user IDs
      const userIds = new Set([
        ...clientReferrals.map(r => r.referrerId),
        ...ownerReferrals.map(r => r.referrerId),
      ]);

      // Fetch user information
      const users = await Promise.all(
        Array.from(userIds).map(id => storage.getUser(id as string))
      );

      const usersMap = new Map(
        users.filter(u => u).map(u => [u!.id, u])
      );

      // Group referrals by user
      const referralsByUser = new Map();

      for (const referral of clientReferrals) {
        if (!referralsByUser.has(referral.referrerId)) {
          const user = usersMap.get(referral.referrerId);
          referralsByUser.set(referral.referrerId, {
            user: {
              id: user?.id,
              firstName: user?.firstName,
              lastName: user?.lastName,
              email: user?.email,
              role: user?.role,
              profileImageUrl: user?.profileImageUrl,
            },
            clientReferrals: [],
            ownerReferrals: [],
          });
        }
        referralsByUser.get(referral.referrerId).clientReferrals.push(referral);
      }

      for (const referral of ownerReferrals) {
        if (!referralsByUser.has(referral.referrerId)) {
          const user = usersMap.get(referral.referrerId);
          referralsByUser.set(referral.referrerId, {
            user: {
              id: user?.id,
              firstName: user?.firstName,
              lastName: user?.lastName,
              email: user?.email,
              role: user?.role,
              profileImageUrl: user?.profileImageUrl,
            },
            clientReferrals: [],
            ownerReferrals: [],
          });
        }
        referralsByUser.get(referral.referrerId).ownerReferrals.push(referral);
      }

      res.json(Array.from(referralsByUser.values()));
    } catch (error) {
      console.error("Error fetching all referrals:", error);
      res.status(500).json({ message: "Failed to fetch referrals" });
    }
  });

  // Client Referral routes
  app.get("/api/referrals/clients", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(403).json({ message: "User not found" });
      }
      
      let filters: any = {};
      
      if (["master", "admin", "admin_jr"].includes(user.role)) {
        if (req.query.referrerId) {
          filters.referrerId = req.query.referrerId;
        }
        if (req.query.status) {
          filters.status = req.query.status;
        }
      } else if (user.role === "seller") {
        filters.sellerView = userId;
        if (req.query.status) {
          filters.status = req.query.status;
        }
      } else {
        filters.referrerId = userId;
        if (req.query.status) {
          filters.status = req.query.status;
        }
      }

      const referrals = await storage.getClientReferrals(filters);
      res.json(referrals);
    } catch (error) {
      console.error("Error fetching client referrals:", error);
      res.status(500).json({ message: "Failed to fetch client referrals" });
    }
  });

  // NOTA: Los vendedores NO pueden referir clientes, solo pueden referir propietarios
  // Este endpoint está restringido solo para administradores
  app.post("/api/referrals/clients", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get current commission config
      const config = await storage.getReferralConfig();
      const commissionPercent = config?.clientReferralCommissionPercent || "5.00";

      const referralData = {
        ...req.body,
        referrerId: userId,
        commissionPercent,
        status: "pendiente_confirmacion",
      };

      const referral = await storage.createClientReferral(referralData);

      await createAuditLog(
        req,
        "create",
        "client_referral",
        referral.id,
        `Referido de cliente creado: ${referral.firstName} ${referral.lastName}`
      );

      res.status(201).json(referral);
    } catch (error: any) {
      console.error("Error creating client referral:", error);
      res.status(400).json({ message: error.message || "Failed to create client referral" });
    }
  });

  app.patch("/api/referrals/clients/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const referral = await storage.updateClientReferral(id, req.body);

      await createAuditLog(
        req,
        "update",
        "client_referral",
        id,
        `Referido de cliente actualizado - Estado: ${referral.status}`
      );

      res.json(referral);
    } catch (error: any) {
      console.error("Error updating client referral:", error);
      res.status(500).json({ message: error.message || "Failed to update client referral" });
    }
  });

  // Owner Referral routes
  app.get("/api/referrals/owners", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(403).json({ message: "User not found" });
      }
      
      let filters: any = {};
      
      if (["master", "admin", "admin_jr"].includes(user.role)) {
        if (req.query.referrerId) {
          filters.referrerId = req.query.referrerId;
        }
        if (req.query.status) {
          filters.status = req.query.status;
        }
      } else if (user.role === "seller") {
        filters.sellerView = userId;
        if (req.query.status) {
          filters.status = req.query.status;
        }
      } else {
        filters.referrerId = userId;
        if (req.query.status) {
          filters.status = req.query.status;
        }
      }

      const referrals = await storage.getOwnerReferrals(filters);
      res.json(referrals);
    } catch (error) {
      console.error("Error fetching owner referrals:", error);
      res.status(500).json({ message: "Failed to fetch owner referrals" });
    }
  });

  app.post("/api/referrals/owners", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get current commission config
      const config = await storage.getReferralConfig();
      const commissionPercent = config?.ownerReferralCommissionPercent || "10.00";

      const referralData = {
        ...req.body,
        referrerId: userId,
        commissionPercent,
        status: "pendiente_confirmacion",
      };

      const referral = await storage.createOwnerReferral(referralData);

      await createAuditLog(
        req,
        "create",
        "owner_referral",
        referral.id,
        `Referido de propietario creado: ${referral.firstName} ${referral.lastName}`
      );

      res.status(201).json(referral);
    } catch (error: any) {
      console.error("Error creating owner referral:", error);
      res.status(400).json({ message: error.message || "Failed to create owner referral" });
    }
  });

  app.patch("/api/referrals/owners/:id", isAuthenticated, requireFullAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const referral = await storage.updateOwnerReferral(id, req.body);

      await createAuditLog(
        req,
        "update",
        "owner_referral",
        id,
        `Referido de propietario actualizado - Estado: ${referral.status}`
      );

      res.json(referral);
    } catch (error: any) {
      console.error("Error updating owner referral:", error);
      res.status(500).json({ message: error.message || "Failed to update owner referral" });
    }
  });

  app.patch("/api/referrals/owners/:id/approve", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      let { commissionAmount } = req.body;
      const userId = req.user.claims.sub;
      
      const referral = await storage.getOwnerReferral(id);
      
      if (!referral) {
        return res.status(404).json({ message: "Referido no encontrado" });
      }
      
      if (!referral.emailVerified) {
        return res.status(400).json({ message: "El email del propietario debe ser verificado antes de aprobar" });
      }
      
      // Calculate default 20% commission if not provided
      if (!commissionAmount && referral.estimatedValue) {
        const estimatedValue = parseFloat(referral.estimatedValue);
        if (!isNaN(estimatedValue)) {
          commissionAmount = (estimatedValue * 0.20).toFixed(2);
        }
      }
      
      const updatedReferral = await storage.approveOwnerReferralByAdmin(id, userId, commissionAmount);
      
      // Send notification to seller
      const seller = await storage.getUser(referral.referrerId);
      if (seller && seller.email) {
        await sendOwnerReferralApprovedNotification(
          seller.email,
          `${seller.firstName || ''} ${seller.lastName || ''}`.trim(),
          `${referral.firstName} ${referral.lastName}`,
          referral.propertyAddress || 'Propiedad referida',
          commissionAmount || updatedReferral.commissionAmount || '0.00'
        );
      }
      
      await createAuditLog(
        req, 
        "update", 
        "owner_referral", 
        id, 
        `Referido de propietario aprobado con comisión de $${commissionAmount || updatedReferral.commissionAmount}`
      );
      
      res.json({ 
        message: "Referido aprobado exitosamente. Se ha notificado al vendedor.",
        ownerReferral: updatedReferral 
      });
    } catch (error: any) {
      console.error("Error approving owner referral:", error);
      res.status(400).json({ message: error.message || "Error al aprobar referido" });
    }
  });

  app.patch("/api/referrals/owners/:id/reject", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { rejectionReason } = req.body;
      const userId = req.user.claims.sub;
      
      if (!rejectionReason) {
        return res.status(400).json({ message: "Se requiere una razón de rechazo" });
      }
      
      const referral = await storage.getOwnerReferral(id);
      
      if (!referral) {
        return res.status(404).json({ message: "Referido no encontrado" });
      }
      
      const updatedReferral = await storage.rejectOwnerReferralByAdmin(id, userId, rejectionReason);
      
      await createAuditLog(
        req, 
        "update", 
        "owner_referral", 
        id, 
        `Referido de propietario rechazado: ${rejectionReason}`
      );
      
      res.json({ 
        message: "Referido rechazado exitosamente",
        ownerReferral: updatedReferral 
      });
    } catch (error: any) {
      console.error("Error rejecting owner referral:", error);
      res.status(400).json({ message: error.message || "Error al rechazar referido" });
    }
  });

  // Offer routes
  app.get("/api/offers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { status, clientId, propertyId } = req.query;
      const filters: any = {};
      if (status) filters.status = status;
      if (propertyId) filters.propertyId = propertyId;
      
      // Security: Only admins/masters/sellers can filter by different clientId
      // Clients can only see their own offers
      if (clientId && clientId !== userId) {
        if (!["master", "admin", "admin_jr", "seller"].includes(user.role)) {
          return res.status(403).json({ message: "No tienes permiso para ver ofertas de otros clientes" });
        }
        filters.clientId = clientId;
      } else if (user.role === "client") {
        // Clients always see only their own offers
        filters.clientId = userId;
      } else if (clientId) {
        // Admin/seller requested specific clientId
        filters.clientId = clientId;
      }

      const offers = await storage.getOffers(filters);
      res.json(offers);
    } catch (error) {
      console.error("Error fetching offers:", error);
      res.status(500).json({ message: "Failed to fetch offers" });
    }
  });

  app.post("/api/offers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Determine clientId: admins/masters/sellers can specify, others use their own ID
      let clientId = userId;
      if (req.body.clientId && req.body.clientId !== userId) {
        if (user && ["master", "admin", "admin_jr", "seller"].includes(user.role)) {
          clientId = req.body.clientId;
        }
        // Non-admins cannot specify different clientId, silently use their own
      }
      
      // Clean special values
      const cleanedBody = {
        ...req.body,
        clientId,
        appointmentId: req.body.appointmentId === "none" ? undefined : req.body.appointmentId,
      };
      
      const offerData = insertOfferSchema.parse(cleanedBody);

      const offer = await storage.createOffer(offerData);
      
      // Log offer creation
      await createAuditLog(
        req,
        "create",
        "offer",
        offer.id,
        `Oferta creada de $${offer.offerAmount} - Estado: ${offer.status}`
      );
      
      res.status(201).json(offer);
    } catch (error: any) {
      console.error("Error creating offer:", error);
      res.status(400).json({ message: error.message || "Failed to create offer" });
    }
  });

  app.patch("/api/offers/:id", isAuthenticated, requireResourceOwnership('offer'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const offer = await storage.updateOffer(id, req.body);
      
      // Log offer update
      await createAuditLog(
        req,
        "update",
        "offer",
        id,
        `Oferta actualizada - Estado: ${offer.status}`
      );
      
      res.json(offer);
    } catch (error) {
      console.error("Error updating offer:", error);
      res.status(500).json({ message: "Failed to update offer" });
    }
  });

  // Owner Offer Management routes
  app.get("/api/owner/offers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      if (!user || !["owner", "admin", "master"].includes(user.role)) {
        return res.status(403).json({ message: "Solo propietarios pueden acceder a esta ruta" });
      }

      const offers = await storage.getOffersByOwner(userId);
      res.json(offers);
    } catch (error) {
      console.error("Error fetching owner offers:", error);
      res.status(500).json({ message: "Error al obtener ofertas" });
    }
  });

  app.patch("/api/owner/offers/:id/accept", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify offer exists and user is the owner
      const offer = await storage.getOffer(id);
      if (!offer) {
        return res.status(404).json({ message: "Oferta no encontrada" });
      }

      const property = await storage.getProperty(offer.propertyId);
      if (!property || property.ownerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para aceptar esta oferta" });
      }

      // Validate workflow state - owner can accept when it's client's turn (pending or countered by client)
      if (offer.status === 'accepted' || offer.status === 'rejected') {
        return res.status(400).json({ message: "Esta oferta ya fue procesada" });
      }

      if (offer.status === 'countered' && offer.lastOfferedBy === 'owner') {
        return res.status(400).json({ message: "No puedes aceptar tu propia contraoferta. Espera la respuesta del cliente." });
      }

      const { offer: acceptedOffer, contract } = await storage.acceptOffer(id);
      
      // Create notification for client about accepted offer
      await storage.createNotification({
        userId: offer.clientId,
        title: "Oferta Aceptada",
        message: `Tu oferta de renta para ${property.title || 'la propiedad'} ha sido aceptada por el propietario.`,
        category: "offer",
        relatedEntityType: "offer",
        relatedEntityId: id,
      });

      // Create notification for client about contract
      if (contract) {
        await storage.createNotification({
          userId: offer.clientId,
          title: "Completar Formato de Inquilino",
          message: `Por favor completa el formato de inquilino para proceder con el contrato de ${property.title || 'la propiedad'}.`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contract.id,
        });

        // Create notification for owner about contract
        await storage.createNotification({
          userId: property.ownerId!,
          title: "Completar Formato de Propietario",
          message: `Por favor completa el formato de propietario para proceder con el contrato de ${property.title || 'la propiedad'}.`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contract.id,
        });
      }

      await createAuditLog(
        req,
        "update",
        "offer",
        id,
        `Oferta aceptada por propietario - Contrato creado: ${contract?.id}`
      );

      res.json({ offer: acceptedOffer, contract });
    } catch (error) {
      console.error("Error accepting offer:", error);
      res.status(500).json({ message: "Error al aceptar oferta" });
    }
  });

  // POST endpoint for accept (compatibility with testing/external APIs)
  app.post("/api/owner/offers/:id/accept", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify offer exists and user is the owner
      const offer = await storage.getOffer(id);
      if (!offer) {
        return res.status(404).json({ message: "Oferta no encontrada" });
      }

      const property = await storage.getProperty(offer.propertyId);
      if (!property || property.ownerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para aceptar esta oferta" });
      }

      // Validate workflow state - owner can accept when it's client's turn (pending or countered by client)
      if (offer.status === 'accepted' || offer.status === 'rejected') {
        return res.status(400).json({ message: "Esta oferta ya fue procesada" });
      }

      if (offer.status === 'countered' && offer.lastOfferedBy === 'owner') {
        return res.status(400).json({ message: "No puedes aceptar tu propia contraoferta. Espera la respuesta del cliente." });
      }

      const { offer: acceptedOffer, contract } = await storage.acceptOffer(id);
      
      console.log(`[ACCEPT OFFER] Offer ${id} accepted. Contract created: ${contract?.id}`);
      
      // Create notification for client about accepted offer
      await storage.createNotification({
        userId: offer.clientId,
        title: "Oferta Aceptada",
        message: `Tu oferta de renta para ${property.title || 'la propiedad'} ha sido aceptada por el propietario.`,
        category: "offer",
        relatedEntityType: "offer",
        relatedEntityId: id,
      });

      // Create notification for client about contract
      if (contract) {
        await storage.createNotification({
          userId: offer.clientId,
          title: "Completar Formato de Inquilino",
          message: `Por favor completa el formato de inquilino para proceder con el contrato de ${property.title || 'la propiedad'}.`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contract.id,
        });

        // Create notification for owner about contract
        await storage.createNotification({
          userId: property.ownerId!,
          title: "Completar Formato de Propietario",
          message: `Por favor completa el formato de propietario para proceder con el contrato de ${property.title || 'la propiedad'}.`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contract.id,
        });
      }

      await createAuditLog(
        req,
        "update",
        "offer",
        id,
        `Oferta aceptada por propietario - Contrato creado: ${contract?.id}`
      );

      res.json({ offer: acceptedOffer, contract });
    } catch (error) {
      console.error("Error accepting offer:", error);
      res.status(500).json({ message: "Error al aceptar oferta" });
    }
  });

  app.patch("/api/owner/offers/:id/reject", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const userId = req.user.claims.sub;
      
      // Verify offer exists and user is the owner
      const offer = await storage.getOffer(id);
      if (!offer) {
        return res.status(404).json({ message: "Oferta no encontrada" });
      }

      const property = await storage.getProperty(offer.propertyId);
      if (!property || property.ownerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para rechazar esta oferta" });
      }

      // Validate workflow state
      if (offer.status === 'accepted' || offer.status === 'rejected') {
        return res.status(400).json({ message: "Esta oferta ya fue procesada" });
      }

      if (offer.status === 'countered' && offer.lastOfferedBy === 'owner') {
        return res.status(400).json({ message: "No puedes rechazar tu propia contraoferta. Espera la respuesta del cliente." });
      }

      const rejectedOffer = await storage.rejectOffer(id, reason);
      
      // Create notification for client
      await storage.createNotification({
        userId: offer.clientId,
        title: "Oferta Rechazada",
        message: `Tu oferta de renta para ${property.title || 'la propiedad'} ha sido rechazada. ${reason ? `Razón: ${reason}` : ''}`,
        category: "offer",
        relatedEntityType: "offer",
        relatedEntityId: id,
      });

      await createAuditLog(
        req,
        "update",
        "offer",
        id,
        `Oferta rechazada por propietario${reason ? ': ' + reason : ''}`
      );

      res.json(rejectedOffer);
    } catch (error) {
      console.error("Error rejecting offer:", error);
      res.status(500).json({ message: "Error al rechazar oferta" });
    }
  });

  app.post("/api/owner/offers/:id/counter-offer", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Validate counter offer payload with Zod
      const counterOfferSchema = z.object({
        counterOfferAmount: z.string().optional(),
        counterOfferServicesIncluded: z.any().optional(),
        counterOfferServicesExcluded: z.any().optional(),
        counterOfferNotes: z.string().optional(),
      });

      const validatedData = counterOfferSchema.parse(req.body);
      
      // Verify offer exists and user is the owner
      const offer = await storage.getOffer(id);
      if (!offer) {
        return res.status(404).json({ message: "Oferta no encontrada" });
      }

      const property = await storage.getProperty(offer.propertyId);
      if (!property || property.ownerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para contraofertar esta oferta" });
      }

      // Validate workflow state - owner can counter-offer when it's their turn (pending or countered by client)
      if (offer.status === 'accepted' || offer.status === 'rejected') {
        return res.status(400).json({ message: "Esta oferta ya fue procesada" });
      }

      if (offer.status === 'countered' && offer.lastOfferedBy === 'owner') {
        return res.status(400).json({ message: "Ya enviaste una contraoferta. Espera la respuesta del cliente." });
      }

      // Check negotiation round limit
      const currentRound = offer.negotiationRound || 0;
      if (currentRound >= 3) {
        return res.status(400).json({ message: "Se alcanzó el límite máximo de 3 rondas de negociación" });
      }

      const counterOffer = await storage.createCounterOffer(id, {
        ...validatedData,
        offeredBy: 'owner'
      });
      
      // Create notification for client
      await storage.createNotification({
        userId: offer.clientId,
        title: "Contraoferta Recibida",
        message: `El propietario ha enviado una contraoferta para tu solicitud de renta de ${property.title || 'la propiedad'}.`,
        category: "offer",
        relatedEntityType: "offer",
        relatedEntityId: id,
      });

      await createAuditLog(
        req,
        "create",
        "offer",
        id,
        `Contraoferta creada por propietario - Ronda ${counterOffer.negotiationRound}`
      );

      res.json(counterOffer);
    } catch (error: any) {
      console.error("Error creating counter offer:", error);
      res.status(400).json({ message: error.message || "Error al crear contraoferta" });
    }
  });

  // Client Offer Management routes
  app.get("/api/client/my-offers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const offers = await storage.getOffers({ clientId: userId });
      
      // Enrich offers with property and owner data
      const enrichedOffers = await Promise.all(
        offers.map(async (offer) => {
          const property = await storage.getProperty(offer.propertyId);
          let owner = null;
          if (property?.ownerId) {
            owner = await storage.getUser(property.ownerId);
          }
          return {
            ...offer,
            property,
            owner
          };
        })
      );
      
      res.json(enrichedOffers);
    } catch (error) {
      console.error("Error fetching client offers:", error);
      res.status(500).json({ message: "Error al obtener ofertas" });
    }
  });

  app.patch("/api/client/offers/:id/accept-counter", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify offer exists and user is the client
      const offer = await storage.getOffer(id);
      if (!offer) {
        return res.status(404).json({ message: "Oferta no encontrada" });
      }

      if (offer.clientId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para aceptar esta contraoferta" });
      }

      // Validate workflow state - client can accept when it's owner's turn (countered by owner)
      if (offer.status === 'accepted' || offer.status === 'rejected') {
        return res.status(400).json({ message: "Esta oferta ya fue procesada" });
      }

      if (offer.status !== 'countered') {
        return res.status(400).json({ message: "No hay contraoferta pendiente para aceptar" });
      }

      if (offer.lastOfferedBy === 'client') {
        return res.status(400).json({ message: "No puedes aceptar tu propia contraoferta. Espera la respuesta del propietario." });
      }

      const { offer: acceptedOffer, contract } = await storage.acceptOffer(id);
      
      // Get property and owner for notification
      const property = await storage.getProperty(offer.propertyId);
      if (property?.ownerId) {
        await storage.createNotification({
          userId: property.ownerId,
          title: "Contraoferta Aceptada",
          message: `El cliente ha aceptado tu contraoferta para ${property.title || 'la propiedad'}.`,
          category: "offer",
          relatedEntityType: "offer",
          relatedEntityId: id,
        });

        // Create notification for owner about contract
        if (contract) {
          await storage.createNotification({
            userId: property.ownerId,
            title: "Completar Formato de Propietario",
            message: `Por favor completa el formato de propietario para proceder con el contrato de ${property.title || 'la propiedad'}.`,
            category: "contract",
            relatedEntityType: "rental_contract",
            relatedEntityId: contract.id,
          });
        }
      }

      // Create notification for client about contract
      if (contract) {
        await storage.createNotification({
          userId: offer.clientId,
          title: "Completar Formato de Inquilino",
          message: `Por favor completa el formato de inquilino para proceder con el contrato de ${property.title || 'la propiedad'}.`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contract.id,
        });
      }

      await createAuditLog(
        req,
        "update",
        "offer",
        id,
        `Contraoferta aceptada por cliente - Contrato creado: ${contract?.id}`
      );

      res.json({ offer: acceptedOffer, contract });
    } catch (error) {
      console.error("Error accepting counter offer:", error);
      res.status(500).json({ message: "Error al aceptar contraoferta" });
    }
  });

  app.patch("/api/client/offers/:id/reject-counter", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const userId = req.user.claims.sub;
      
      // Verify offer exists and user is the client
      const offer = await storage.getOffer(id);
      if (!offer) {
        return res.status(404).json({ message: "Oferta no encontrada" });
      }

      if (offer.clientId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para rechazar esta contraoferta" });
      }

      // Validate workflow state
      if (offer.status === 'accepted' || offer.status === 'rejected') {
        return res.status(400).json({ message: "Esta oferta ya fue procesada" });
      }

      if (offer.status !== 'countered') {
        return res.status(400).json({ message: "No hay contraoferta pendiente para rechazar" });
      }

      if (offer.lastOfferedBy === 'client') {
        return res.status(400).json({ message: "No puedes rechazar tu propia contraoferta. Espera la respuesta del propietario." });
      }

      const rejectedOffer = await storage.rejectOffer(id, reason);
      
      // Get property and owner for notification
      const property = await storage.getProperty(offer.propertyId);
      if (property?.ownerId) {
        await storage.createNotification({
          userId: property.ownerId,
          title: "Contraoferta Rechazada",
          message: `El cliente ha rechazado tu contraoferta para ${property.title || 'la propiedad'}. ${reason ? `Razón: ${reason}` : ''}`,
          category: "offer",
          relatedEntityType: "offer",
          relatedEntityId: id,
        });
      }

      await createAuditLog(
        req,
        "update",
        "offer",
        id,
        `Contraoferta rechazada por cliente${reason ? ': ' + reason : ''}`
      );

      res.json(rejectedOffer);
    } catch (error) {
      console.error("Error rejecting counter offer:", error);
      res.status(500).json({ message: "Error al rechazar contraoferta" });
    }
  });

  app.post("/api/client/offers/:id/counter-offer", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Validate counter offer payload with Zod
      const counterOfferSchema = z.object({
        counterOfferAmount: z.string().optional(),
        counterOfferServicesIncluded: z.any().optional(),
        counterOfferServicesExcluded: z.any().optional(),
        counterOfferNotes: z.string().optional(),
      });

      const validatedData = counterOfferSchema.parse(req.body);
      
      // Verify offer exists and user is the client
      const offer = await storage.getOffer(id);
      if (!offer) {
        return res.status(404).json({ message: "Oferta no encontrada" });
      }

      if (offer.clientId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para contraofertar" });
      }

      // Validate workflow state - client can counter-offer when it's their turn (countered by owner)
      if (offer.status === 'accepted' || offer.status === 'rejected') {
        return res.status(400).json({ message: "Esta oferta ya fue procesada" });
      }

      if (offer.status === 'countered' && offer.lastOfferedBy === 'client') {
        return res.status(400).json({ message: "Ya enviaste una contraoferta. Espera la respuesta del propietario." });
      }

      // Check negotiation round limit
      const currentRound = offer.negotiationRound || 0;
      if (currentRound >= 3) {
        return res.status(400).json({ message: "Se alcanzó el límite máximo de 3 rondas de negociación" });
      }

      const counterOffer = await storage.createCounterOffer(id, {
        ...validatedData,
        offeredBy: 'client'
      });
      
      // Get property and owner for notification
      const property = await storage.getProperty(offer.propertyId);
      if (property?.ownerId) {
        await storage.createNotification({
          userId: property.ownerId,
          title: "Nueva Contraoferta",
          message: `El cliente ha enviado una contraoferta para tu propiedad ${property.title || ''}.`,
          category: "offer",
          relatedEntityType: "offer",
          relatedEntityId: id,
        });
      }

      await createAuditLog(
        req,
        "create",
        "offer",
        id,
        `Contraoferta creada por cliente - Ronda ${counterOffer.negotiationRound}`
      );

      res.json(counterOffer);
    } catch (error: any) {
      console.error("Error creating counter offer:", error);
      res.status(400).json({ message: error.message || "Error al crear contraoferta" });
    }
  });

  // Contract Routes
  app.get("/api/contracts/:contractId", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      // Verify user has access to this contract (tenant, owner, or admin)
      const property = await storage.getProperty(contract.propertyId);
      const user = await storage.getUser(userId);
      const isAdmin = user && ["master", "admin", "admin_jr"].includes(user.role);
      
      if (contract.tenantId !== userId && property?.ownerId !== userId && !isAdmin) {
        return res.status(403).json({ message: "No tienes permiso para ver este contrato" });
      }

      // Get additional info
      const tenantInfo = await storage.getContractTenantInfo(contractId);
      const ownerInfo = await storage.getContractOwnerInfo(contractId);

      res.json({ contract, tenantInfo, ownerInfo, property });
    } catch (error) {
      console.error("Error fetching contract:", error);
      res.status(500).json({ message: "Error al obtener contrato" });
    }
  });

  app.get("/api/contracts/:contractId/tenant-info", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      // Verify user is the tenant
      if (contract.tenantId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para ver esta información" });
      }

      const tenantInfo = await storage.getContractTenantInfo(contractId);
      res.json(tenantInfo || null);
    } catch (error) {
      console.error("Error fetching tenant info:", error);
      res.status(500).json({ message: "Error al obtener información del inquilino" });
    }
  });

  app.post("/api/contracts/:contractId/tenant-info", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      // Verify user is the tenant
      if (contract.tenantId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para actualizar esta información" });
      }

      // Validate request body with Zod schema
      const validationResult = insertContractTenantInfoSchema
        .omit({ rentalContractId: true })
        .partial()
        .safeParse(req.body);

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);

      // Check if info already exists
      const existingInfo = await storage.getContractTenantInfo(contractId);
      
      let tenantInfo;
      if (existingInfo) {
        tenantInfo = await storage.updateContractTenantInfo(contractId, sanitizedData);
      } else {
        tenantInfo = await storage.createContractTenantInfo({
          ...sanitizedData,
          rentalContractId: contractId
        });
      }

      // Update contract status if both forms are complete
      const ownerInfo = await storage.getContractOwnerInfo(contractId);
      if (ownerInfo) {
        await storage.updateRentalContractStatus(contractId, 'pendiente_verificacion');
        
        // Notify admin to verify
        const admins = await storage.getAllAdmins();
        for (const admin of admins) {
          await storage.createNotification({
            userId: admin.userId,
            title: "Contrato Listo para Verificación",
            message: `El contrato ${contractId} ha sido completado y está listo para verificación.`,
            category: "contract",
            relatedEntityType: "rental_contract",
            relatedEntityId: contractId,
          });
        }
      }

      await createAuditLog(
        req,
        existingInfo ? "update" : "create",
        "contract_tenant_info",
        contractId,
        `Información de inquilino ${existingInfo ? 'actualizada' : 'creada'}`
      );

      res.json(tenantInfo);
    } catch (error) {
      console.error("Error saving tenant info:", error);
      res.status(500).json({ message: "Error al guardar información del inquilino" });
    }
  });

  app.get("/api/contracts/:contractId/owner-info", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const property = await storage.getProperty(contract.propertyId);
      
      // Verify user is the owner
      if (property?.ownerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para ver esta información" });
      }

      const ownerInfo = await storage.getContractOwnerInfo(contractId);
      res.json(ownerInfo || null);
    } catch (error) {
      console.error("Error fetching owner info:", error);
      res.status(500).json({ message: "Error al obtener información del propietario" });
    }
  });

  app.post("/api/contracts/:contractId/owner-info", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const property = await storage.getProperty(contract.propertyId);
      
      // Verify user is the owner
      if (property?.ownerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para actualizar esta información" });
      }

      // Validate request body with Zod schema
      const validationResult = insertContractOwnerInfoSchema
        .omit({ rentalContractId: true })
        .partial()
        .safeParse(req.body);

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.errors 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);

      // Check if info already exists
      const existingInfo = await storage.getContractOwnerInfo(contractId);
      
      let ownerInfo;
      if (existingInfo) {
        ownerInfo = await storage.updateContractOwnerInfo(contractId, sanitizedData);
      } else {
        ownerInfo = await storage.createContractOwnerInfo({
          ...sanitizedData,
          rentalContractId: contractId
        });
      }

      // Update contract status if both forms are complete
      const tenantInfo = await storage.getContractTenantInfo(contractId);
      if (tenantInfo) {
        await storage.updateRentalContractStatus(contractId, 'pendiente_verificacion');
        
        // Notify admin to verify
        const admins = await storage.getAllAdmins();
        for (const admin of admins) {
          await storage.createNotification({
            userId: admin.userId,
            title: "Contrato Listo para Verificación",
            message: `El contrato ${contractId} ha sido completado y está listo para verificación.`,
            category: "contract",
            relatedEntityType: "rental_contract",
            relatedEntityId: contractId,
          });
        }
      }

      await createAuditLog(
        req,
        existingInfo ? "update" : "create",
        "contract_owner_info",
        contractId,
        `Información de propietario ${existingInfo ? 'actualizada' : 'creada'}`
      );

      res.json(ownerInfo);
    } catch (error) {
      console.error("Error saving owner info:", error);
      res.status(500).json({ message: "Error al guardar información del propietario" });
    }
  });

  app.patch("/api/contracts/:contractId/verify", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const { verified, notes } = req.body;
      const userId = req.user.claims.sub;
      
      // Verify user is admin
      const user = await storage.getUser(userId);
      if (!user || !["master", "admin", "admin_jr"].includes(user.role)) {
        return res.status(403).json({ message: "No tienes permiso para verificar contratos" });
      }
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      if (contract.status !== 'pendiente_verificacion') {
        return res.status(400).json({ message: "El contrato no está en estado pendiente de verificación" });
      }

      if (verified) {
        // Approve and move to apartado
        await storage.updateRentalContractStatus(contractId, 'apartado', {
          apartadoDate: new Date()
        });

        // Notify tenant and owner to sign
        await storage.createNotification({
          userId: contract.tenantId,
          title: "Contrato Verificado - Firma Digital",
          message: `Tu contrato ha sido verificado. Por favor firma digitalmente para continuar.`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contractId,
        });

        const property = await storage.getProperty(contract.propertyId);
        if (property?.ownerId) {
          await storage.createNotification({
            userId: property.ownerId,
            title: "Contrato Verificado - Firma Digital",
            message: `El contrato ha sido verificado. Por favor firma digitalmente para continuar.`,
            category: "contract",
            relatedEntityType: "rental_contract",
            relatedEntityId: contractId,
          });
        }
      } else {
        // Reject and move back to draft
        await storage.updateRentalContractStatus(contractId, 'draft');

        // Notify about rejection
        await storage.createNotification({
          userId: contract.tenantId,
          title: "Contrato Requiere Correcciones",
          message: `Tu contrato requiere correcciones. ${notes || ''}`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contractId,
        });
      }

      await createAuditLog(
        req,
        "update",
        "rental_contract",
        contractId,
        `Contrato ${verified ? 'verificado' : 'rechazado'} por admin${notes ? ': ' + notes : ''}`
      );

      const updatedContract = await storage.getRentalContract(contractId);
      res.json(updatedContract);
    } catch (error) {
      console.error("Error verifying contract:", error);
      res.status(500).json({ message: "Error al verificar contrato" });
    }
  });

  // Offer Token routes - Enlaces privados para ofertas sin login (soporta sistema interno y externo)
  app.post("/api/offer-tokens", isAuthenticated, requireRole(["admin", "master", "admin_jr", "seller", "external_agency_admin", "external_agency_accounting", "external_agency_seller"]), async (req: any, res) => {
    try {
      const { propertyId, externalUnitId, externalClientId, leadId } = req.body;
      const userId = req.user.claims.sub;
      
      // Debug logging for troubleshooting agency-specific issues
      console.log('[Offer Token Creation] Request body:', { 
        propertyId, 
        externalUnitId, 
        externalClientId, 
        leadId,
        propertyIdType: typeof propertyId,
        externalUnitIdType: typeof externalUnitId
      });
      
      // Check if user is from external agency
      const userAgencyId = await getUserAgencyId(req);
      const isExternalAgencyUser = !!userAgencyId;
      
      console.log('[Offer Token Creation] User context:', {
        userId: req.user.claims.sub,
        userAgencyId,
        isExternalAgencyUser
      });

      let property = null;
      let externalUnit = null;
      let externalClient = null;
      let auditMessage = "";

      // Determine if this is for internal or external system
      // For external agency users, ALWAYS require externalUnitId
      const isExternalFlow = !!externalUnitId;
      
      if (isExternalAgencyUser && !externalUnitId) {
        console.error('[Offer Token Creation] External agency user missing externalUnitId');
        return res.status(400).json({ 
          message: "Para agencias externas se requiere externalUnitId" 
        });
      }
      
      if (isExternalFlow) {
        // External system flow - validate externalUnitId is a valid string
        if (typeof externalUnitId !== 'string' || !externalUnitId.trim()) {
          console.error('[Offer Token Creation] Invalid externalUnitId:', externalUnitId);
          return res.status(400).json({ message: "ID de unidad inválido" });
        }
        
        externalUnit = await storage.getExternalUnit(externalUnitId);
        if (!externalUnit) {
          console.error('[Offer Token Creation] Unit not found:', externalUnitId);
          return res.status(404).json({ message: "Unidad no encontrada" });
        }
        
        console.log('[Offer Token Creation] Found external unit:', {
          unitId: externalUnit.id,
          agencyId: externalUnit.agencyId,
          unitNumber: externalUnit.unitNumber
        });
        
        // Verify user has access to this agency
        const agencyId = await getUserAgencyId(req);
        if (!agencyId || String(externalUnit.agencyId) !== String(agencyId)) {
          console.error('[Offer Token Creation] Agency access denied:', {
            userAgencyId: agencyId,
            unitAgencyId: externalUnit.agencyId
          });
          return res.status(403).json({ message: "No tienes acceso a esta unidad" });
        }
        
        // If externalClientId provided, validate it belongs to same agency
        if (externalClientId) {
          externalClient = await storage.getExternalClient(externalClientId);
          if (!externalClient) {
            return res.status(404).json({ message: "Cliente no encontrado" });
          }
          if (String(externalClient.agencyId) !== String(agencyId)) {
            return res.status(403).json({ message: "No tienes acceso a este cliente" });
          }
        }
        
        // Get condominium name for audit
        const condo = externalUnit.condominiumId ? await storage.getExternalCondominium(externalUnit.condominiumId) : null;
        auditMessage = `Token de oferta creado para unidad externa ${condo?.name || ''} - ${externalUnit.unitNumber} (Agency ID: ${agencyId})`;
        if (externalClient) {
          auditMessage += ` - Cliente: ${externalClient.firstName} ${externalClient.lastName}`;
        }
      } else if (propertyId) {
        // Internal system flow
        property = await storage.getProperty(propertyId);
        if (!property) {
          return res.status(404).json({ message: "Propiedad no encontrada" });
        }
        auditMessage = `Token de oferta creado para propiedad interna ${property.title || propertyId}`;
      } else {
        return res.status(400).json({ message: "Se requiere propertyId o externalUnitId" });
      }

      // If leadId provided, validate lead exists (internal system only)
      if (leadId) {
        const lead = await storage.getLead(leadId);
        if (!lead) {
          return res.status(404).json({ message: "Lead no encontrado" });
        }
      }

      // Generate unique token
      const token = crypto.randomBytes(32).toString('hex');
      
      // Calculate expiration (24 hours from now)
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24);

      // Rule: Only one active link per client
      // Delete all active (non-completed) tokens for this client before creating a new one
      // This preserves completed tokens (isUsed = true)
      if (externalClientId) {
        await db.delete(offerTokens)
          .where(
            and(
              eq(offerTokens.externalClientId, externalClientId),
              eq(offerTokens.isUsed, false)
            )
          );
      }

      // Create offer token
      const offerToken = await db.insert(offerTokens).values({
        token,
        propertyId: propertyId || null,
        externalUnitId: externalUnitId || null,
        externalClientId: externalClientId || null,
        leadId: leadId || null,
        createdBy: userId,
        expiresAt,
        isUsed: false,
      }).returning();

      // Update lead status to "oferta_enviada" if leadId provided (internal only)
      if (leadId) {
        await storage.updateLeadStatus(leadId, "oferta_enviada");
        auditMessage += ' y lead actualizado a oferta_enviada';
      }

      await createAuditLog(
        req,
        "create",
        "offer_token",
        offerToken[0].id,
        auditMessage
      );

      // Log property activity for external units
      if (externalUnit) {
        try {
          await db.insert(externalPropertyActivityHistory).values({
            agencyId: externalUnit.agencyId,
            unitId: externalUnit.id,
            condominiumId: externalUnit.condominiumId || null,
            activityType: 'offer_sent',
            leadId: null,
            leadName: null,
            clientId: externalClientId || null,
            clientName: externalClient ? `${externalClient.firstName || ''} ${externalClient.lastName || ''}`.trim() : null,
            offerTokenId: offerToken[0].id,
            performedBy: userId,
            performedByName: null, // Will be populated by trigger/hook if needed
            details: {
              recipientType: 'tenant',
              channel: 'link',
              notes: auditMessage
            },
          });
        } catch (activityError) {
          console.error("Error logging property activity:", activityError);
          // Don't fail the main request if activity logging fails
        }
      }


      // Get agency info for friendly URL generation
      let agencySlug = null;
      if (externalUnit?.agencyId) {
        const agency = await db.select({ slug: externalAgencies.slug })
          .from(externalAgencies)
          .where(eq(externalAgencies.id, externalUnit.agencyId))
          .limit(1);
        if (agency.length) {
          agencySlug = agency[0].slug;
        }
      }

      // Return token with property or unit info and slugs for friendly URLs
      res.status(201).json({
        ...offerToken[0],
        property,
        externalUnit,
        externalClient,
        agencySlug,
        unitSlug: externalUnit?.slug,
      });
    } catch (error: any) {
      console.error("Error creating offer token:", error);
      res.status(400).json({ message: error.message || "Error al crear token de oferta" });
    }
  });

  // Validate offer token (public route - OPTIMIZED)
  app.get("/api/offer-tokens/:token/validate", async (req, res) => {
    try {
      const { token } = req.params;

      // Single optimized query with only necessary fields
      const data = await storage.getOfferTokenDataLean(token);

      if (!data) {
        return res.status(404).json({ 
          valid: false, 
          message: "Token no encontrado" 
        });
      }

      // Check if expired
      if (new Date() > new Date(data.expiresAt)) {
        return res.status(410).json({ 
          valid: false, 
          message: "Este enlace ha expirado" 
        });
      }

      // Check if already used - but allow viewing completed offers
      const isCompleted = data.isUsed;
      
      // If token is used but has no offer data, something went wrong
      if (isCompleted && !data.offerData) {
        return res.status(409).json({
          valid: false,
          message: "Este enlace fue utilizado pero no contiene datos de la oferta"
        });
      }

      // Map optimized data to frontend format
      const property = data.unitId ? {
        id: data.unitId,
        title: `${data.condoName || ''} - Unidad ${data.unitNumber}`,
        type: data.unitType,
        bedrooms: data.bedrooms,
        bathrooms: data.bathrooms,
        size: data.size,
        description: data.description,
        includedServices: data.includedServices || [],
        photos: data.photos || [],
        monthlyRentPrice: data.monthlyRent,
        currency: data.currency,
        address: data.condoAddress || '',
        isExternal: true,
      } : null;

      const externalClient = data.clientId ? {
        id: data.clientId,
        firstName: data.clientFirstName,
        lastName: data.clientLastName,
        email: data.clientEmail,
        phone: data.clientPhone,
      } : null;

      const externalAgency = data.agencyId ? {
        id: data.agencyId,
        name: data.agencyName,
        logoUrl: data.agencyLogo,
      } : null;

      const creatorUser = data.creatorId ? {
        id: data.creatorId,
        firstName: data.creatorFirstName,
        lastName: data.creatorLastName,
        profilePictureUrl: data.creatorProfilePic,
      } : null;

      // Get lead info if leadId exists (internal system support)
      let lead = null;
      if (data.leadId) {
        lead = await storage.getLead(data.leadId);
      }

      res.json({
        valid: true,
        isCompleted,
        property,
        lead,
        externalClient,
        externalAgency,
        creatorUser,
        submittedOffer: isCompleted ? data.offerData : null,
        expiresAt: data.expiresAt,
      });
    } catch (error) {
      console.error("Error validating offer token:", error);
      res.status(500).json({ message: "Error al validar token" });
    }
  });

  // Upload pet photos for offer (public route)
  app.post("/api/offer-tokens/:token/upload-pet-photos", upload.array('petPhotos', 3), async (req: any, res) => {
    try {
      const { token } = req.params;
      
      // Validate token exists
      const [offerToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.token, token))
        .limit(1);

      if (!offerToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      // Check if expired
      if (new Date() > new Date(offerToken.expiresAt)) {
        return res.status(410).json({ message: "Este enlace ha expirado" });
      }

      if (!req.files || req.files.length === 0) {
        return res.status(400).json({ message: "No se subieron archivos" });
      }

      // Generate URLs for uploaded files
      const photoUrls = (req.files as Express.Multer.File[]).map(file => {
        return `/attached_assets/stock_images/${file.filename}`;
      });

      res.json({ 
        message: "Fotos subidas exitosamente",
        urls: photoUrls 
      });
    } catch (error) {
      console.error("Error uploading pet photos:", error);
      res.status(500).json({ message: "Error al subir fotos" });
    }
  });

  // Submit offer via token (public route)
  app.post("/api/offer-tokens/:token/submit", async (req, res) => {
    try {
      const { token } = req.params;
      const offerData = req.body;

      const [offerToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.token, token))
        .limit(1);

      if (!offerToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      // Check if expired
      if (new Date() > new Date(offerToken.expiresAt)) {
        return res.status(410).json({ message: "Este enlace ha expirado" });
      }

      // Check if already used
      if (offerToken.isUsed) {
        return res.status(410).json({ message: "Este enlace ya fue utilizado" });
      }

      // Update offer token with submitted data
      const [updatedToken] = await db
        .update(offerTokens)
        .set({
          offerData: {
            ...offerData,
            submittedAt: new Date().toISOString(),
          },
          isUsed: true,
          updatedAt: new Date(),
        })
        .where(eq(offerTokens.id, offerToken.id))
        .returning();

      // Update lead status to "en_negociacion" if leadId exists
      if (offerToken.leadId) {
        await storage.updateLeadStatus(offerToken.leadId, "en_negociacion");
      }

      res.json({
        message: "Oferta enviada exitosamente",
        tokenId: updatedToken.id,
      });
    } catch (error) {
      console.error("Error submitting offer:", error);
      res.status(500).json({ message: "Error al enviar oferta" });
    }
  });

  // Get all received offers (admins only)
  app.get("/api/offer-tokens", isAuthenticated, requireRole(["admin", "master", "admin_jr"]), async (req, res) => {
    try {
      const { status } = req.query;

      let query = db
        .select()
        .from(offerTokens)
        .orderBy(desc(offerTokens.createdAt));

      if (status === "used") {
        query = query.where(eq(offerTokens.isUsed, true));
      } else if (status === "pending") {
        query = query.where(eq(offerTokens.isUsed, false));
      }

      const tokens = await query;

      // Enrich with property, creator, and lead info
      const enrichedTokens = await Promise.all(
        tokens.map(async (token) => {
          const property = await storage.getProperty(token.propertyId);
          const creator = await storage.getUser(token.createdBy);
          let lead = null;
          if (token.leadId) {
            lead = await storage.getLead(token.leadId);
          }
          return {
            ...token,
            property,
            creator,
            lead,
          };
        })
      );

      res.json(enrichedTokens);
    } catch (error) {
      console.error("Error fetching offer tokens:", error);
      res.status(500).json({ message: "Error al obtener tokens de oferta" });
    }
  });

  // Delete offer token (admins only)
  app.delete("/api/offer-tokens/:id", isAuthenticated, requireRole(["admin", "master", "admin_jr"]), async (req, res) => {
    try {
      const { id } = req.params;

      // Check if token exists
      const [existingToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.id, id))
        .limit(1);

      if (!existingToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      // Delete the token
      await db
        .delete(offerTokens)
        .where(eq(offerTokens.id, id));

      res.json({ message: "Link eliminado exitosamente" });
    } catch (error) {
      console.error("Error deleting offer token:", error);
      res.status(500).json({ message: "Error al eliminar link" });
    }
  });

  // Send offer link via email
  app.post("/api/offer-tokens/:id/send-email", isAuthenticated, requireRole(["admin", "master", "admin_jr", "seller"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { clientEmail, clientName } = req.body;

      if (!clientEmail || !clientName) {
        return res.status(400).json({ message: "Email y nombre del cliente son requeridos" });
      }

      // Get offer token
      const [offerToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.id, id))
        .limit(1);

      if (!offerToken) {
        return res.status(404).json({ message: "Token de oferta no encontrado" });
      }

      // Get property info
      const property = await storage.getProperty(offerToken.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Build offer link
      const baseUrl = process.env.NODE_ENV === 'production' 
        ? `https://${process.env.REPLIT_DOMAINS?.split(',')[0] || 'app.replit.dev'}`
        : 'http://localhost:5000';
      const offerLink = `${baseUrl}/offer/${offerToken.token}`;

      // Send email
      await sendOfferLinkEmail(
        clientEmail,
        clientName,
        property.title || 'la propiedad',
        offerLink
      );

      await createAuditLog(
        req,
        "create",
        "offer_token_email",
        offerToken.id,
        `Email enviado a ${clientEmail} con link de oferta para ${property.title}`
      );

      res.json({ 
        message: "Email enviado exitosamente",
        offerLink 
      });
    } catch (error: any) {
      console.error("Error sending offer link email:", error);
      res.status(500).json({ message: error.message || "Error al enviar email" });
    }
  });

  // Generate PDF for offer
  app.get("/api/offers/:id/pdf", isAuthenticated, requireRole(["admin", "master", "admin_jr"]), async (req, res) => {
    try {
      const { id } = req.params;

      // Get offer token
      const [offerToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.id, id))
        .limit(1);

      if (!offerToken) {
        return res.status(404).json({ message: "Token de oferta no encontrado" });
      }

      if (!offerToken.isUsed || !offerToken.offerData) {
        return res.status(400).json({ message: "La oferta aún no ha sido completada" });
      }

      // Get property info
      const property = await storage.getProperty(offerToken.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Generate PDF
      const pdfBuffer = await generateOfferPDF(offerToken.offerData, property);

      // Set headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="oferta-${offerToken.id}.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Error generating PDF:", error);
      res.status(500).json({ message: "Error al generar PDF" });
    }
  });

  // Rental Form Token routes - Enlaces privados para formato de renta de inquilino (soporta sistema interno y externo)
  app.post("/api/rental-form-tokens", isAuthenticated, requireRole(["admin", "master", "admin_jr", "seller", "external_agency_admin", "external_agency_accounting", "external_agency_seller"]), async (req: any, res) => {
    try {
      const { propertyId, externalUnitId, externalClientId, externalUnitOwnerId, leadId, recipientType = 'tenant' } = req.body;
      const userId = req.user.claims.sub;

      let property = null;
      let externalUnit = null;
      let externalClient = null;
      let externalUnitOwner = null;
      let auditMessage = "";

      // Determine if this is for internal or external system BEFORE any lookups
      const isExternalFlow = !!externalUnitId;
      
      if (isExternalFlow) {
        // External system flow
        externalUnit = await storage.getExternalUnit(externalUnitId);
        if (!externalUnit) {
          return res.status(404).json({ message: "Unidad no encontrada" });
        }
        
        // Verify user has access to this agency
        const agencyId = await getUserAgencyId(req);
        if (!agencyId || String(externalUnit.agencyId) !== String(agencyId)) {
          return res.status(403).json({ message: "No tienes acceso a esta unidad" });
        }
        
        // If externalClientId provided (tenant flow), validate it belongs to same agency
        if (externalClientId && recipientType === 'tenant') {
          externalClient = await storage.getExternalClient(externalClientId);
          if (!externalClient) {
            return res.status(404).json({ message: "Cliente no encontrado" });
          }
          if (String(externalClient.agencyId) !== String(agencyId)) {
            return res.status(403).json({ message: "No tienes acceso a este cliente" });
          }
        }
        
        // If externalUnitOwnerId provided (owner flow), validate it exists and belongs to this unit
        if (externalUnitOwnerId && recipientType === 'owner') {
          externalUnitOwner = await storage.getExternalUnitOwner(externalUnitOwnerId);
          if (!externalUnitOwner) {
            return res.status(404).json({ message: "Propietario no encontrado" });
          }
          if (String(externalUnitOwner.unitId) !== String(externalUnitId)) {
            return res.status(400).json({ message: "El propietario no pertenece a esta unidad" });
          }
        }
        
        // Get condominium name for audit
        const condo = externalUnit.condominiumId ? await storage.getExternalCondominium(externalUnit.condominiumId) : null;
        auditMessage = `Token de formato de renta creado para unidad externa ${condo?.name || ''} - ${externalUnit.unitNumber} (Agency ID: ${agencyId})`;
        if (externalClient) {
          auditMessage += ` - Cliente: ${externalClient.firstName} ${externalClient.lastName}`;
        }
        if (externalUnitOwner) {
          auditMessage += ` - Propietario: ${externalUnitOwner.ownerName}`;
        }
      } else if (propertyId) {
        // Internal system flow
        property = await storage.getProperty(propertyId);
        if (!property) {
          return res.status(404).json({ message: "Propiedad no encontrada" });
        }
        auditMessage = `Token de formato de renta creado para propiedad interna ${property.title || property.id}`;
      } else {
        return res.status(400).json({ message: "Se requiere propertyId o externalUnitId" });
      }

      // Generate unique token (16 characters - suficiente para enlaces temporales)
      const token = crypto.randomBytes(8).toString('hex');
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24); // 24 hour expiration

      const [rentalFormToken] = await db
        .insert(tenantRentalFormTokens)
        .values({
          token,
          recipientType,
          propertyId: propertyId || null,
          externalUnitId: externalUnitId || null,
          externalClientId: externalClientId || null,
          externalUnitOwnerId: externalUnitOwnerId || null,
          leadId: leadId || null,
          createdBy: userId,
          expiresAt,
          isUsed: false,
        })
        .returning();

      // Business rule: Only one active rental form link per client/owner
      // Delete all OTHER active (non-completed) tokens for this client or owner
      // This preserves completed tokens (isUsed = true) and the new token we just created
      if (externalClientId && recipientType === 'tenant') {
        await db.delete(tenantRentalFormTokens)
          .where(
            and(
              eq(tenantRentalFormTokens.externalClientId, externalClientId),
              eq(tenantRentalFormTokens.isUsed, false),
              ne(tenantRentalFormTokens.id, rentalFormToken.id)
            )
          );
      } else if (externalUnitOwnerId && recipientType === 'owner') {
        await db.delete(tenantRentalFormTokens)
          .where(
            and(
              eq(tenantRentalFormTokens.externalUnitOwnerId, externalUnitOwnerId),
              eq(tenantRentalFormTokens.isUsed, false),
              ne(tenantRentalFormTokens.id, rentalFormToken.id)
            )
          );
      }

      await createAuditLog(
        req,
        "create",
        "rental_form_token",
        rentalFormToken.id,
        auditMessage
      );

      // Get agency info for friendly URL generation
      let agencySlug = null;
      if (externalUnit?.agencyId) {
        const agency = await db.select({ slug: externalAgencies.slug })
          .from(externalAgencies)
          .where(eq(externalAgencies.id, externalUnit.agencyId))
          .limit(1);
        if (agency.length) {
          agencySlug = agency[0].slug;
        }
      }

      res.json({
        ...rentalFormToken,
        property,
        externalUnit,
        externalClient,
        externalUnitOwner,
        agencySlug,
        unitSlug: externalUnit?.slug,
      });
    } catch (error: any) {
      console.error("Error creating rental form token:", error);
      res.status(400).json({ message: error.message || "Error al crear token de formato de renta" });
    }
  });

  // Validate rental form token (public route - OPTIMIZED)
  app.get("/api/rental-form-tokens/:token/validate", async (req, res) => {
    try {
      const { token } = req.params;

      // Single optimized query with only necessary fields
      const data = await storage.getRentalFormTokenDataLean(token);

      if (!data) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      // Check if token is expired
      if (new Date() > new Date(data.expiresAt)) {
        return res.status(400).json({ message: "Este enlace ha expirado" });
      }

      // Check if token is already used
      if (data.isUsed) {
        return res.status(400).json({ message: "Este enlace ya ha sido utilizado" });
      }

      const recipientType = data.recipientType || 'tenant';
      
      // Map optimized data to frontend format
      const unit = data.unitId ? {
        id: data.unitId,
        unitNumber: data.unitNumber,
        propertyType: data.unitType,
        bedrooms: data.bedrooms,
        bathrooms: data.bathrooms,
        area: data.size,
        monthlyRent: data.monthlyRent,
        currency: data.currency,
      } : null;

      const condominium = data.condoName ? {
        name: data.condoName,
        address: data.condoAddress,
      } : null;

      const client = data.clientFirstName ? {
        firstName: data.clientFirstName,
        lastName: data.clientLastName,
        email: data.clientEmail,
        phone: data.clientPhone,
      } : null;

      const externalAgency = data.agencyId ? {
        id: data.agencyId,
        name: data.agencyName,
        logoUrl: data.agencyLogo,
      } : null;

      const creatorUser = data.creatorId ? {
        id: data.creatorId,
        firstName: data.creatorFirstName,
        lastName: data.creatorLastName,
        profilePictureUrl: data.creatorProfilePic,
      } : null;

      // Pre-fill data for tenant forms: Get latest completed offer from this client
      let prefillData = null;
      if (recipientType === 'tenant' && data.externalClientId) {
        const latestOffer = await storage.getLatestOfferForPrefill(data.externalClientId);
        
        if (latestOffer) {
          prefillData = {
            fullName: latestOffer.nombreCompleto || '',
            nationality: latestOffer.nacionalidad || '',
            age: latestOffer.edad || undefined,
            jobPosition: latestOffer.trabajoPosicion || '',
            companyName: latestOffer.companiaTrabaja || '',
            monthlyIncome: latestOffer.ingresoMensualPromedio || '',
            numberOfTenants: latestOffer.numeroInquilinos || undefined,
            hasPets: latestOffer.tieneMascotas === 'Sí' ? 'yes' : latestOffer.tieneMascotas === 'No' ? 'no' : undefined,
            email: latestOffer.clientEmail || client?.email || '',
            whatsapp: latestOffer.clientPhone || client?.phone || '',
            checkInDate: latestOffer.fechaIngreso || '',
            timeInTulum: latestOffer.tiempoResidenciaTulum || '',
          };
        }
      }
      
      // Pre-fill data for owner forms: Get owner info from external_unit_owners
      if (recipientType === 'owner' && data.externalUnitOwnerId) {
        const owner = await storage.getOwnerForPrefill(data.externalUnitOwnerId);
        
        if (owner) {
          prefillData = {
            fullName: owner.ownerName || '',
            email: owner.ownerEmail || '',
            phoneNumber: owner.ownerPhone || '',
            whatsappNumber: owner.ownerPhone || '',
          };
        }
      }
      
      // Support for internal system flow if propertyId exists
      const isExternalFlow = !!data.externalUnitId;
      if (!isExternalFlow && data.propertyId) {
        const property = await storage.getProperty(data.propertyId);
        if (!property) {
          return res.status(404).json({ message: "Propiedad no encontrada" });
        }

        return res.json({
          valid: true,
          isExternal: false,
          recipientType,
          property,
          expiresAt: data.expiresAt,
        });
      }
      
      res.json({
        valid: true,
        isExternal: true,
        recipientType,
        unit,
        condominium,
        client,
        externalAgency,
        creatorUser,
        prefillData,
        expiresAt: data.expiresAt,
      });
    } catch (error) {
      console.error("Error validating rental form token:", error);
      res.status(500).json({ message: "Error al validar token" });
    }
  });

  // Helper function to create rental contract when both tenant and owner forms are complete
  async function createDualFormContractIfReady(rentalFormGroupId: string, agencyId: string, createdBy: string) {
    try {
      // Get all tokens in this rental form group
      const groupTokens = await db.query.tenantRentalFormTokens.findMany({
        where: eq(tenantRentalFormTokens.rentalFormGroupId, rentalFormGroupId),
      });

      // Check if we have both tenant and owner forms
      const tenantToken = groupTokens.find(t => t.recipientType === 'tenant');
      const ownerToken = groupTokens.find(t => t.recipientType === 'owner');

      if (!tenantToken || !ownerToken) {
        console.log('Missing tenant or owner token in group:', rentalFormGroupId);
        return null;
      }

      // Check if both are completed
      if (!tenantToken.isUsed || !ownerToken.isUsed) {
        console.log('Not all forms completed yet in group:', rentalFormGroupId);
        return null;
      }

      // IDEMPOTENCY CHECK: Verify if contract already exists for this rental group
      const existingContracts = await db
        .select()
        .from(externalRentalContracts)
        .where(eq(externalRentalContracts.rentalFormGroupId, rentalFormGroupId))
        .limit(1);

      if (existingContracts.length > 0) {
        console.log('Contract already exists for rental form group:', rentalFormGroupId, '- Contract ID:', existingContracts[0].id);
        return { ...existingContracts[0], alreadyExisted: true };
      }

      // Get the completed form data
      const [tenantFormData] = await db
        .select()
        .from(tenantRentalForms)
        .where(eq(tenantRentalForms.tokenId, tenantToken.id))
        .limit(1);

      const [ownerFormData] = await db
        .select()
        .from(ownerRentalFormData)
        .where(eq(ownerRentalFormData.tokenId, ownerToken.id))
        .limit(1);

      if (!tenantFormData || !ownerFormData) {
        console.log('Missing form data in group:', rentalFormGroupId);
        return null;
      }

      // Verify we have required data
      if (!ownerToken.externalUnitId) {
        console.log('Missing external unit ID in owner token');
        return null;
      }

      // Validate required owner form fields
      if (!ownerFormData.agreedRent || !ownerFormData.rentMonths || !ownerFormData.rentStartDate) {
        console.log('Missing required owner form fields (agreedRent, rentMonths, or rentStartDate)');
        return null;
      }

      // Validate numeric values
      const agreedRent = Number(ownerFormData.agreedRent);
      const rentMonths = Number(ownerFormData.rentMonths);
      if (!Number.isFinite(agreedRent) || agreedRent <= 0) {
        console.log('Invalid agreedRent value:', ownerFormData.agreedRent);
        return null;
      }
      if (!Number.isInteger(rentMonths) || rentMonths <= 0) {
        console.log('Invalid rentMonths value:', ownerFormData.rentMonths);
        return null;
      }

      // Calculate end date
      const startDate = new Date(ownerFormData.rentStartDate);
      const endDate = new Date(startDate);
      endDate.setMonth(endDate.getMonth() + rentMonths);

      // Create rental contract combining data from both forms
      // Wrapped in try-catch to handle concurrent insertions (UNIQUE constraint on rentalFormGroupId)
      try {
        const contract = await storage.createExternalRentalContract({
          agencyId,
          unitId: ownerToken.externalUnitId,
          clientId: tenantToken.externalClientId || null,
          rentalFormGroupId,
          tenantName: tenantFormData.fullName,
          tenantEmail: tenantFormData.email || null,
          tenantPhone: tenantFormData.phoneNumber || null,
          monthlyRent: agreedRent.toString(),
          currency: 'MXN',
          securityDeposit: ownerFormData.agreedDeposit ? Number(ownerFormData.agreedDeposit).toString() : null,
          rentalPurpose: 'living',
          leaseDurationMonths: rentMonths,
          startDate,
          endDate,
          status: 'active',
          hasPet: tenantFormData.hasPet || false,
          petName: tenantFormData.petName || null,
          petPhotoUrl: tenantFormData.petPhotoUrl || null,
          createdBy,
        });

        console.log('Created rental contract from dual forms:', contract.id);
        return contract;
      } catch (insertError: any) {
        // If insertion failed due to THIS SPECIFIC unique constraint violation, fetch existing contract
        // Check for PostgreSQL unique violation error code AND verify it's our specific constraint
        if (insertError.code === '23505' && 
            (insertError.constraint === 'unique_rental_form_group_id' || 
             insertError.detail?.includes('rental_form_group_id'))) {
          console.log('Contract already created by concurrent submission, fetching existing contract for group:', rentalFormGroupId);
          const [existingContract] = await db
            .select()
            .from(externalRentalContracts)
            .where(eq(externalRentalContracts.rentalFormGroupId, rentalFormGroupId))
            .limit(1);
          
          if (existingContract) {
            return { ...existingContract, alreadyExisted: true };
          }
          // If we couldn't find the contract even after unique violation, something is wrong
          console.error('Unique constraint violation but contract not found for group:', rentalFormGroupId);
        }
        // If it's a different error, re-throw it
        throw insertError;
      }
    } catch (error) {
      console.error('Error creating dual form contract:', error);
      return null;
    }
  }

  // Submit rental form via token (public route)
  app.post("/api/rental-form-tokens/:token/submit", async (req, res) => {
    try {
      const { token } = req.params;
      const formData = req.body;

      const [rentalFormToken] = await db
        .select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.token, token))
        .limit(1);

      if (!rentalFormToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      if (new Date() > new Date(rentalFormToken.expiresAt)) {
        return res.status(400).json({ message: "Este enlace ha expirado" });
      }

      if (rentalFormToken.isUsed) {
        return res.status(400).json({ message: "Este enlace ya ha sido utilizado" });
      }

      // Transform date string to Date object if present
      const transformedData: any = { ...formData };
      if (transformedData.checkInDate && typeof transformedData.checkInDate === 'string') {
        // Parse date string as UTC noon to avoid timezone shift issues
        // Input format: "YYYY-MM-DD" -> Parse as "YYYY-MM-DD 12:00:00 UTC"
        const dateParts = transformedData.checkInDate.split('-');
        if (dateParts.length === 3) {
          transformedData.checkInDate = new Date(Date.UTC(
            parseInt(dateParts[0]), // year
            parseInt(dateParts[1]) - 1, // month (0-indexed)
            parseInt(dateParts[2]), // day
            12, 0, 0 // noon UTC to avoid day boundary issues
          ));
        }
      }

      // Validate integer fields to prevent out-of-range errors
      if (transformedData.age !== undefined && transformedData.age !== null) {
        const age = Number(transformedData.age);
        if (!Number.isFinite(age) || age < 18 || age > 150) {
          return res.status(400).json({ message: "Edad debe estar entre 18 y 150 años" });
        }
        transformedData.age = Math.floor(age); // Ensure integer
      }
      
      if (transformedData.numberOfTenants !== undefined && transformedData.numberOfTenants !== null) {
        const numberOfTenants = Number(transformedData.numberOfTenants);
        if (!Number.isFinite(numberOfTenants) || numberOfTenants < 1 || numberOfTenants > 20) {
          return res.status(400).json({ message: "Número de inquilinos debe estar entre 1 y 20" });
        }
        transformedData.numberOfTenants = Math.floor(numberOfTenants); // Ensure integer
      }
      
      if (transformedData.guarantorAge !== undefined && transformedData.guarantorAge !== null) {
        const guarantorAge = Number(transformedData.guarantorAge);
        if (!Number.isFinite(guarantorAge) || guarantorAge < 18 || guarantorAge > 150) {
          return res.status(400).json({ message: "Edad del garante debe estar entre 18 y 150 años" });
        }
        transformedData.guarantorAge = Math.floor(guarantorAge); // Ensure integer
      }

      // Extract documents object before cleaning
      const documents = transformedData.documents || {};
      delete transformedData.documents; // Remove from transformedData to avoid nesting issues
      
      // Filter out undefined values to prevent Drizzle/Postgres errors
      const cleanedData: any = {};
      for (const [key, value] of Object.entries(transformedData)) {
        if (value !== undefined && value !== '') {
          cleanedData[key] = value;
        }
      }

      // Map document URLs to database fields
      const documentFields: any = {};
      if (documents.tenantIdDocument) {
        documentFields.tenantIdDocument = documents.tenantIdDocument;
      }
      if (documents.tenantProofOfAddress) {
        documentFields.tenantProofOfAddress = documents.tenantProofOfAddress;
      }
      if (documents.tenantProofOfIncome && documents.tenantProofOfIncome.length > 0) {
        documentFields.tenantProofOfIncome = documents.tenantProofOfIncome;
      }
      if (documents.guarantorIdDocument) {
        documentFields.guarantorIdDocument = documents.guarantorIdDocument;
      }
      if (documents.guarantorProofOfAddress) {
        documentFields.guarantorProofOfAddress = documents.guarantorProofOfAddress;
      }
      if (documents.guarantorProofOfIncome && documents.guarantorProofOfIncome.length > 0) {
        documentFields.guarantorProofOfIncome = documents.guarantorProofOfIncome;
      }

      // Create tenant rental form
      // Use the correct property field depending on internal vs external system
      const rentalFormData: any = {
        tokenId: rentalFormToken.id,
        leadId: rentalFormToken.leadId,
        ...cleanedData,
        ...documentFields, // Include document URLs
        status: 'pendiente',
      };
      
      // Set property or external unit ID based on token
      if (rentalFormToken.externalUnitId) {
        rentalFormData.externalUnitId = rentalFormToken.externalUnitId;
      } else if (rentalFormToken.propertyId) {
        rentalFormData.propertyId = rentalFormToken.propertyId;
      }
      
      const [rentalForm] = await db
        .insert(tenantRentalForms)
        .values(rentalFormData)
        .returning();

      // Mark token as used
      await db
        .update(tenantRentalFormTokens)
        .set({ 
          isUsed: true,
          usedAt: new Date(),
        })
        .where(eq(tenantRentalFormTokens.id, rentalFormToken.id));

      // Check if this is part of a dual-form group and create contract if both are complete
      let contractId = null;
      if (rentalFormToken.rentalFormGroupId) {
        // Get agency ID - for external system
        if (rentalFormToken.externalUnitId) {
          const unit = await storage.getExternalUnit(rentalFormToken.externalUnitId);
          if (unit) {
            const contract = await createDualFormContractIfReady(
              rentalFormToken.rentalFormGroupId,
              unit.agencyId,
              rentalFormToken.createdBy
            );
            if (contract) {
              contractId = contract.id;
              console.log('Rental contract created after tenant form submission:', contractId);
            }
          }
        }
      }

      // Note: Lead status remains "en_negociacion" after form submission
      // Admin will review the form and then proceed to contract elaboration

      res.json({
        success: true,
        message: "Formato de renta enviado exitosamente",
        formId: rentalForm.id,
        contractId, // Include contract ID if created
      });
    } catch (error) {
      console.error("Error submitting rental form:", error);
      res.status(500).json({ message: "Error al enviar formato de renta" });
    }
  });

  // Configure multer for tenant document uploads
  const tenantDocumentStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'attached_assets/tenant_documents/');
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = crypto.randomBytes(4).toString('hex');
      const ext = path.extname(file.originalname);
      const baseName = path.basename(file.originalname, ext).toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20);
      cb(null, `tenant_doc_${uniqueSuffix}${ext}`);
    }
  });

  const uploadTenantDocuments = multer({
    storage: tenantDocumentStorage,
    limits: {
      fileSize: 10 * 1024 * 1024 // 10MB limit for documents
    },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'application/pdf'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Tipo de archivo no permitido. Solo JPG, PNG, WEBP y PDF.'));
      }
    }
  });

  // Upload tenant documents via token (public route)
  app.post("/api/rental-form-tokens/:token/upload-documents", uploadTenantDocuments.array('documents', 10), async (req: any, res) => {
    try {
      const { token } = req.params;
      const { documentType } = req.body; // 'tenantId', 'tenantProofOfAddress', 'tenantProofOfIncome', 'guarantorId', 'guarantorProofOfAddress', 'guarantorProofOfIncome'
      
      // Validate token exists
      const [rentalFormToken] = await db
        .select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.token, token))
        .limit(1);

      if (!rentalFormToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      // Verify this is a tenant token
      if (rentalFormToken.recipientType !== 'tenant') {
        return res.status(400).json({ message: "Este token no es para formulario de inquilino" });
      }

      // Check if expired
      if (new Date() > new Date(rentalFormToken.expiresAt)) {
        return res.status(410).json({ message: "Este enlace ha expirado" });
      }

      if (!req.files || req.files.length === 0) {
        return res.status(400).json({ message: "No se subieron archivos" });
      }

      if (!documentType) {
        return res.status(400).json({ message: "Tipo de documento es requerido" });
      }

      // Validate document type
      const validDocumentTypes = [
        'tenantId',
        'tenantProofOfAddress',
        'tenantProofOfIncome',
        'guarantorId',
        'guarantorProofOfAddress',
        'guarantorProofOfIncome'
      ];

      if (!validDocumentTypes.includes(documentType)) {
        return res.status(400).json({ message: "Tipo de documento inválido" });
      }

      // Generate URLs for uploaded files
      const documentUrls = (req.files as Express.Multer.File[]).map(file => {
        return `/attached_assets/tenant_documents/${file.filename}`;
      });

      res.json({ 
        message: "Documentos subidos exitosamente",
        documentType,
        urls: documentUrls 
      });
    } catch (error) {
      console.error("Error uploading tenant documents:", error);
      res.status(500).json({ message: "Error al subir documentos" });
    }
  });

  // Configure multer for owner document uploads
  const ownerDocumentStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'attached_assets/owner_documents/');
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = crypto.randomBytes(4).toString('hex');
      const ext = path.extname(file.originalname);
      const baseName = path.basename(file.originalname, ext).toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20);
      cb(null, `owner_doc_${uniqueSuffix}${ext}`);
    }
  });

  const uploadOwnerDocuments = multer({
    storage: ownerDocumentStorage,
    limits: {
      fileSize: 10 * 1024 * 1024 // 10MB limit for documents
    },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'application/pdf'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Tipo de archivo no permitido. Solo JPG, PNG, WEBP y PDF.'));
      }
    }
  });

  // Upload owner documents via token (public route)
  app.post("/api/owner-rental-form-tokens/:token/upload-documents", uploadOwnerDocuments.array('documents', 10), async (req: any, res) => {
    try {
      const { token } = req.params;
      const { documentType } = req.body; // 'idDocument', 'constitutiveAct', 'propertyDocuments', 'serviceReceipts', 'noDebtProof', etc.
      console.log("[Owner Upload] Token:", token);
      console.log("[Owner Upload] documentType:", documentType);
      console.log("[Owner Upload] Files received:", req.files?.length || 0);
      
      // Validate token exists
      const [rentalFormToken] = await db
        .select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.token, token))
        .limit(1);

      if (!rentalFormToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      // Verify this is an owner token
      if (rentalFormToken.recipientType !== 'owner') {
        return res.status(400).json({ message: "Este token no es para formulario de propietario" });
      }

      // Check if expired
      if (new Date() > new Date(rentalFormToken.expiresAt)) {
        return res.status(410).json({ message: "Este enlace ha expirado" });
      }

      if (!req.files || req.files.length === 0) {
        return res.status(400).json({ message: "No se subieron archivos" });
      }

      if (!documentType) {
        return res.status(400).json({ message: "Tipo de documento es requerido" });
      }

      // Validate document type
      const validDocumentTypes = [
        'idDocument',
        'constitutiveAct',
        'propertyDocuments',
        'serviceReceipts',
        'noDebtProof',
        'servicesFormat',
        'internalRules',
        'condoRegulations'
      ];

      if (!validDocumentTypes.includes(documentType)) {
        return res.status(400).json({ message: "Tipo de documento inválido" });
      }

      // Generate URLs for uploaded files
      const documentUrls = (req.files as Express.Multer.File[]).map(file => {
        return `/attached_assets/owner_documents/${file.filename}`;
      });

      res.json({ 
        message: "Documentos subidos exitosamente",
        documentType,
        urls: documentUrls 
      });
    } catch (error) {
      console.error("Error uploading owner documents:", error);
      res.status(500).json({ message: "Error al subir documentos" });
    }
  });

  // Submit owner rental form via token (public route)
  app.post("/api/owner-rental-form-tokens/:token/submit", async (req, res) => {
    try {
      const { token } = req.params;
      const formData = req.body;

      const [rentalFormToken] = await db
        .select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.token, token))
        .limit(1);

      if (!rentalFormToken) {
        return res.status(404).json({ message: "Token no encontrado" });
      }

      // Verify this is an owner token
      if (rentalFormToken.recipientType !== 'owner') {
        return res.status(400).json({ message: "Este token no es para formulario de propietario" });
      }

      if (new Date() > new Date(rentalFormToken.expiresAt)) {
        return res.status(400).json({ message: "Este enlace ha expirado" });
      }

      if (rentalFormToken.isUsed) {
        return res.status(400).json({ message: "Este enlace ya ha sido utilizado" });
      }

      // Validate with Zod schema
      const validationResult = insertOwnerRentalFormDataSchema.safeParse({
        tokenId: rentalFormToken.id,
        externalUnitId: rentalFormToken.externalUnitId || undefined,
        rentalFormGroupId: rentalFormToken.rentalFormGroupId || undefined,
        ...formData,
      });

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos del formulario inválidos",
          errors: validationResult.error.errors 
        });
      }

      const sanitizedData = validationResult.data;

      // Create owner rental form
      const [ownerForm] = await db
        .insert(ownerRentalFormData)
        .values({
          ...sanitizedData,
          status: 'submitted',
        })
        .returning();

      // Mark token as used
      await db
        .update(tenantRentalFormTokens)
        .set({ 
          isUsed: true,
          usedAt: new Date(),
        })
        .where(eq(tenantRentalFormTokens.id, rentalFormToken.id));

      // Check if this is part of a dual-form group and create contract if both are complete
      let contractId = null;
      if (rentalFormToken.rentalFormGroupId && rentalFormToken.externalUnitId) {
        const unit = await storage.getExternalUnit(rentalFormToken.externalUnitId);
        if (unit) {
          const contract = await createDualFormContractIfReady(
            rentalFormToken.rentalFormGroupId,
            unit.agencyId,
            rentalFormToken.createdBy
          );
          if (contract) {
            contractId = contract.id;
            console.log('Rental contract created after owner form submission:', contractId);
          }
        }
      }

      res.json({
        success: true,
        message: "Formato de propietario enviado exitosamente",
        formId: ownerForm.id,
        contractId, // Include contract ID if created
      });
    } catch (error) {
      console.error("Error submitting owner rental form:", error);
      res.status(500).json({ message: "Error al enviar formato de propietario" });
    }
  });

  // Send rental form link via email
  app.post("/api/rental-form-tokens/:id/send-email", isAuthenticated, requireRole(["admin", "master", "admin_jr", "seller", "external_agency_admin", "external_agency_accounting", "external_agency_seller"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { clientEmail, clientName } = req.body;

      if (!clientEmail || !clientName) {
        return res.status(400).json({ message: "Email y nombre del cliente son requeridos" });
      }

      // Get rental form token
      const [rentalFormToken] = await db
        .select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.id, id))
        .limit(1);

      if (!rentalFormToken) {
        return res.status(404).json({ message: "Token de formato de renta no encontrado" });
      }

      // Get property info
      const property = await storage.getProperty(rentalFormToken.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      // Build rental form link
      const baseUrl = process.env.NODE_ENV === 'production' 
        ? `https://${process.env.REPLIT_DOMAINS?.split(',')[0] || 'app.replit.dev'}`
        : 'http://localhost:5000';
      const rentalFormLink = `${baseUrl}/rental-form/${rentalFormToken.token}`;

      // TODO: Send email using Resend integration
      // For now, just return success
      console.log(`Would send rental form link email to ${clientEmail}`);

      await createAuditLog(
        req,
        "create",
        "rental_form_token_email",
        rentalFormToken.id,
        `Email enviado a ${clientEmail} con link de formato de renta para ${property.title}`
      );

      res.json({ 
        message: "Email enviado exitosamente",
        rentalFormLink 
      });
    } catch (error: any) {
      console.error("Error sending rental form link email:", error);
      res.status(500).json({ message: error.message || "Error al enviar email" });
    }
  });

  // Get all rental form tokens (admins only)
  app.get("/api/rental-form-tokens", isAuthenticated, requireRole(["admin", "master", "admin_jr"]), async (req, res) => {
    try {
      const { status } = req.query;

      let query = db
        .select()
        .from(tenantRentalFormTokens)
        .orderBy(desc(tenantRentalFormTokens.createdAt));

      if (status === "used") {
        query = query.where(eq(tenantRentalFormTokens.isUsed, true));
      } else if (status === "unused") {
        query = query.where(eq(tenantRentalFormTokens.isUsed, false));
      }

      const tokens = await query;

      // Enrich with property and creator info
      const enrichedTokens = await Promise.all(
        tokens.map(async (token) => {
          const property = await storage.getProperty(token.propertyId);
          const creator = await storage.getUser(token.createdBy);
          return {
            ...token,
            property,
            creator,
          };
        })
      );

      res.json(enrichedTokens);
    } catch (error) {
      console.error("Error fetching rental form tokens:", error);
      res.status(500).json({ message: "Error al obtener tokens de formato de renta" });
    }
  });

  // Get all rental form submissions (admins only)
  app.get("/api/rental-forms", isAuthenticated, requireRole(["admin", "master", "admin_jr"]), async (req, res) => {
    try {
      const { status } = req.query;

      let query = db
        .select()
        .from(tenantRentalForms)
        .orderBy(desc(tenantRentalForms.createdAt));

      if (status && status !== "all") {
        query = query.where(eq(tenantRentalForms.status, status as string));
      }

      const forms = await query;

      // Enrich with property info
      const enrichedForms = await Promise.all(
        forms.map(async (form) => {
          const property = await storage.getProperty(form.propertyId);
          const lead = form.leadId ? await storage.getLead(form.leadId) : null;
          return {
            ...form,
            property,
            lead,
          };
        })
      );

      res.json(enrichedForms);
    } catch (error) {
      console.error("Error fetching rental forms:", error);
      res.status(500).json({ message: "Error al obtener formularios de renta" });
    }
  });

  // Review rental form (approve/reject)
  app.patch("/api/rental-forms/:id/review", isAuthenticated, requireRole(["admin", "master", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status, adminNotes } = req.body;
      const userId = req.user.claims.sub;

      if (!["aprobado", "rechazado", "en_revision"].includes(status)) {
        return res.status(400).json({ message: "Estado inválido" });
      }

      const [rentalForm] = await db
        .select()
        .from(tenantRentalForms)
        .where(eq(tenantRentalForms.id, id))
        .limit(1);

      if (!rentalForm) {
        return res.status(404).json({ message: "Formulario no encontrado" });
      }

      // Update rental form
      await db
        .update(tenantRentalForms)
        .set({
          status,
          reviewedBy: userId,
          reviewedAt: new Date(),
          adminNotes: adminNotes || null,
          updatedAt: new Date(),
        })
        .where(eq(tenantRentalForms.id, id));

      // Note: Lead status remains "en_negociacion" after approval
      // Status will change to "contrato_firmado" when contract is actually signed

      await createAuditLog(
        req,
        "update",
        "rental_form",
        id,
        `Formulario de renta ${status}: ${rentalForm.fullName}`
      );

      res.json({ message: "Formulario actualizado exitosamente" });
    } catch (error) {
      console.error("Error reviewing rental form:", error);
      res.status(500).json({ message: "Error al revisar formulario" });
    }
  });

  // Contract Legal Documents routes
  app.get("/api/contracts/:contractId/legal-documents", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      // Get contract to verify access
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const user = await storage.getUser(userId);
      const property = await storage.getProperty(contract.propertyId);
      
      // Verify user has access (tenant, owner, admin, or lawyer)
      const isAuthorized = 
        contract.tenantId === userId ||
        property?.ownerId === userId ||
        ["master", "admin", "admin_jr", "abogado"].includes(user?.role || "");

      if (!isAuthorized) {
        return res.status(403).json({ message: "No autorizado" });
      }

      const documents = await storage.getContractLegalDocuments(contractId);
      res.json(documents);
    } catch (error) {
      console.error("Error fetching legal documents:", error);
      res.status(500).json({ message: "Error al obtener documentos legales" });
    }
  });

  app.post("/api/contracts/:contractId/legal-documents", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const user = await storage.getUser(userId);
      // Only lawyers can upload legal documents
      if (user?.role !== "abogado") {
        return res.status(403).json({ message: "Solo abogados pueden subir documentos legales" });
      }

      const validationResult = insertContractLegalDocumentSchema.safeParse({
        ...req.body,
        rentalContractId: contractId,
        uploadedById: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.flatten() 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);
      const document = await storage.createContractLegalDocument(sanitizedData);

      await createAuditLog(
        req,
        "create",
        "contract_legal_document",
        document.id,
        `Documento legal subido para contrato ${contractId}`
      );

      res.json(document);
    } catch (error) {
      console.error("Error creating legal document:", error);
      res.status(500).json({ message: "Error al crear documento legal" });
    }
  });

  app.patch("/api/legal-documents/:documentId", isAuthenticated, async (req: any, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user.claims.sub;
      
      const document = await storage.getContractLegalDocument(documentId);
      if (!document) {
        return res.status(404).json({ message: "Documento no encontrado" });
      }

      const user = await storage.getUser(userId);
      // Only the lawyer who uploaded or admins can update
      if (document.uploadedById !== userId && !["master", "admin"].includes(user?.role || "")) {
        return res.status(403).json({ message: "No autorizado" });
      }

      // Use dedicated update schema that excludes rentalContractId and uploadedById
      const validationResult = updateContractLegalDocumentSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.flatten() 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);
      
      // Force immutable fields to their original values to prevent reassignment
      const safeUpdate = {
        ...sanitizedData,
        rentalContractId: document.rentalContractId,
        uploadedById: document.uploadedById,
      };
      
      const updatedDocument = await storage.updateContractLegalDocument(documentId, safeUpdate);

      await createAuditLog(
        req,
        "update",
        "contract_legal_document",
        documentId,
        "Documento legal actualizado"
      );

      res.json(updatedDocument);
    } catch (error) {
      console.error("Error updating legal document:", error);
      res.status(500).json({ message: "Error al actualizar documento" });
    }
  });

  // Contract Term Discussions routes
  app.get("/api/legal-documents/:documentId/discussions", isAuthenticated, async (req: any, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user.claims.sub;
      
      const document = await storage.getContractLegalDocument(documentId);
      if (!document) {
        return res.status(404).json({ message: "Documento no encontrado" });
      }

      const contract = await storage.getRentalContract(document.rentalContractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const user = await storage.getUser(userId);
      const property = await storage.getProperty(contract.propertyId);
      
      // Verify access
      const isAuthorized = 
        contract.tenantId === userId ||
        property?.ownerId === userId ||
        ["master", "admin", "admin_jr", "abogado"].includes(user?.role || "");

      if (!isAuthorized) {
        return res.status(403).json({ message: "No autorizado" });
      }

      const discussions = await storage.getContractTermDiscussions(documentId);
      res.json(discussions);
    } catch (error) {
      console.error("Error fetching discussions:", error);
      res.status(500).json({ message: "Error al obtener discusiones" });
    }
  });

  app.post("/api/legal-documents/:documentId/discussions", isAuthenticated, async (req: any, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user.claims.sub;
      
      const document = await storage.getContractLegalDocument(documentId);
      if (!document) {
        return res.status(404).json({ message: "Documento no encontrado" });
      }

      const validationResult = insertContractTermDiscussionSchema.safeParse({
        ...req.body,
        legalDocumentId: documentId,
        userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.flatten() 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);
      const discussion = await storage.createContractTermDiscussion(sanitizedData);

      await createAuditLog(
        req,
        "create",
        "contract_term_discussion",
        discussion.id,
        `Discusión creada en documento ${documentId}`
      );

      res.json(discussion);
    } catch (error) {
      console.error("Error creating discussion:", error);
      res.status(500).json({ message: "Error al crear discusión" });
    }
  });

  app.patch("/api/discussions/:discussionId/resolve", isAuthenticated, async (req: any, res) => {
    try {
      const { discussionId } = req.params;
      const userId = req.user.claims.sub;
      
      const user = await storage.getUser(userId);
      // Only lawyers and admins can resolve discussions
      if (!["abogado", "master", "admin"].includes(user?.role || "")) {
        return res.status(403).json({ message: "No autorizado para resolver discusiones" });
      }

      const discussion = await storage.resolveContractTermDiscussion(discussionId, userId);

      await createAuditLog(
        req,
        "update",
        "contract_term_discussion",
        discussionId,
        "Discusión resuelta"
      );

      res.json(discussion);
    } catch (error) {
      console.error("Error resolving discussion:", error);
      res.status(500).json({ message: "Error al resolver discusión" });
    }
  });

  // Contract Approvals routes
  app.get("/api/legal-documents/:documentId/approvals", isAuthenticated, async (req: any, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user.claims.sub;
      
      const document = await storage.getContractLegalDocument(documentId);
      if (!document) {
        return res.status(404).json({ message: "Documento no encontrado" });
      }

      const contract = await storage.getRentalContract(document.rentalContractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const user = await storage.getUser(userId);
      const property = await storage.getProperty(contract.propertyId);
      
      // Verify access
      const isAuthorized = 
        contract.tenantId === userId ||
        property?.ownerId === userId ||
        ["master", "admin", "admin_jr", "abogado"].includes(user?.role || "");

      if (!isAuthorized) {
        return res.status(403).json({ message: "No autorizado" });
      }

      const approvals = await storage.getContractApprovals(documentId);
      res.json(approvals);
    } catch (error) {
      console.error("Error fetching approvals:", error);
      res.status(500).json({ message: "Error al obtener aprobaciones" });
    }
  });

  app.post("/api/legal-documents/:documentId/approve", isAuthenticated, async (req: any, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user.claims.sub;
      
      const document = await storage.getContractLegalDocument(documentId);
      if (!document) {
        return res.status(404).json({ message: "Documento no encontrado" });
      }

      const contract = await storage.getRentalContract(document.rentalContractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const property = await storage.getProperty(contract.propertyId);
      
      // Determine user role
      let userRole = "other";
      if (contract.tenantId === userId) userRole = "tenant";
      else if (property?.ownerId === userId) userRole = "owner";

      if (!["tenant", "owner"].includes(userRole)) {
        return res.status(403).json({ message: "Solo inquilinos y propietarios pueden aprobar" });
      }

      const validationResult = insertContractApprovalSchema.safeParse({
        ...req.body,
        legalDocumentId: documentId,
        userId,
        userRole,
      });

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.flatten() 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);
      const approval = await storage.createContractApproval(sanitizedData);

      // Check if both parties have approved
      const allApprovals = await storage.getContractApprovals(documentId);
      const tenantApproval = allApprovals.find(a => a.userRole === "tenant" && a.approved);
      const ownerApproval = allApprovals.find(a => a.userRole === "owner" && a.approved);

      if (tenantApproval && ownerApproval) {
        // Both approved - update document status
        await storage.updateContractLegalDocument(documentId, { status: "approved" });
        
        // Update contract to firmado status
        await storage.updateRentalContractStatus(contract.id, 'firmado');

        // Notify parties about approval
        await storage.createNotification({
          userId: contract.tenantId,
          title: "Contrato Aprobado",
          message: `El contrato legal ha sido aprobado por ambas partes.`,
          category: "contract",
          relatedEntityType: "rental_contract",
          relatedEntityId: contract.id,
        });

        if (property?.ownerId) {
          await storage.createNotification({
            userId: property.ownerId,
            title: "Contrato Aprobado",
            message: `El contrato legal ha sido aprobado por ambas partes.`,
            category: "contract",
            relatedEntityType: "rental_contract",
            relatedEntityId: contract.id,
          });
        }
      }

      await createAuditLog(
        req,
        "create",
        "contract_approval",
        approval.id,
        `Aprobación registrada para documento ${documentId}`
      );

      res.json(approval);
    } catch (error) {
      console.error("Error creating approval:", error);
      res.status(500).json({ message: "Error al crear aprobación" });
    }
  });

  // Check-in Appointment routes
  app.get("/api/contracts/:contractId/check-in", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const user = await storage.getUser(userId);
      const property = await storage.getProperty(contract.propertyId);
      
      // Verify access
      const isAuthorized = 
        contract.tenantId === userId ||
        property?.ownerId === userId ||
        ["master", "admin", "admin_jr"].includes(user?.role || "");

      if (!isAuthorized) {
        return res.status(403).json({ message: "No autorizado" });
      }

      const appointments = await storage.getCheckInAppointments({ rentalContractId: contractId });
      res.json(appointments[0] || null);
    } catch (error) {
      console.error("Error fetching check-in appointment:", error);
      res.status(500).json({ message: "Error al obtener cita de check-in" });
    }
  });

  app.post("/api/contracts/:contractId/check-in", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const user = await storage.getUser(userId);
      // Only admins can schedule check-in appointments
      if (!["master", "admin", "admin_jr"].includes(user?.role || "")) {
        return res.status(403).json({ message: "Solo administradores pueden programar check-in" });
      }

      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const property = await storage.getProperty(contract.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Propiedad no encontrada" });
      }

      const validationResult = insertCheckInAppointmentSchema.safeParse({
        ...req.body,
        rentalContractId: contractId,
        propertyId: contract.propertyId,
        tenantId: contract.tenantId,
        ownerId: property.ownerId,
      });

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.flatten() 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);
      const appointment = await storage.createCheckInAppointment(sanitizedData);

      // Notify parties
      await storage.createNotification({
        userId: contract.tenantId,
        title: "Cita de Check-in Programada",
        message: `Se ha programado tu cita de check-in para ${new Date(appointment.scheduledDate).toLocaleString()}.`,
        category: "appointment",
        relatedEntityType: "check_in_appointment",
        relatedEntityId: appointment.id,
      });

      if (property.ownerId) {
        await storage.createNotification({
          userId: property.ownerId,
          title: "Cita de Check-in Programada",
          message: `Se ha programado la cita de check-in para ${new Date(appointment.scheduledDate).toLocaleString()}.`,
          category: "appointment",
          relatedEntityType: "check_in_appointment",
          relatedEntityId: appointment.id,
        });
      }

      await createAuditLog(
        req,
        "create",
        "check_in_appointment",
        appointment.id,
        `Cita de check-in programada para contrato ${contractId}`
      );

      res.json(appointment);
    } catch (error) {
      console.error("Error creating check-in appointment:", error);
      res.status(500).json({ message: "Error al crear cita de check-in" });
    }
  });

  app.patch("/api/check-in/:appointmentId/complete", isAuthenticated, async (req: any, res) => {
    try {
      const { appointmentId } = req.params;
      const userId = req.user.claims.sub;
      
      const user = await storage.getUser(userId);
      if (!["master", "admin", "admin_jr"].includes(user?.role || "")) {
        return res.status(403).json({ message: "Solo administradores pueden completar check-in" });
      }

      const appointment = await storage.completeCheckInAppointment(appointmentId);
      
      // Update contract to check_in status
      await storage.updateRentalContractStatus(appointment.rentalContractId, 'check_in');

      await createAuditLog(
        req,
        "update",
        "check_in_appointment",
        appointmentId,
        "Cita de check-in completada"
      );

      res.json(appointment);
    } catch (error) {
      console.error("Error completing check-in:", error);
      res.status(500).json({ message: "Error al completar check-in" });
    }
  });

  // Contract Signed Documents routes
  app.get("/api/contracts/:contractId/signed-documents", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const contract = await storage.getRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contrato no encontrado" });
      }

      const user = await storage.getUser(userId);
      const property = await storage.getProperty(contract.propertyId);
      
      // Verify access
      const isAuthorized = 
        contract.tenantId === userId ||
        property?.ownerId === userId ||
        ["master", "admin", "admin_jr"].includes(user?.role || "");

      if (!isAuthorized) {
        return res.status(403).json({ message: "No autorizado" });
      }

      const documents = await storage.getContractSignedDocuments(contractId);
      res.json(documents);
    } catch (error) {
      console.error("Error fetching signed documents:", error);
      res.status(500).json({ message: "Error al obtener documentos firmados" });
    }
  });

  app.post("/api/contracts/:contractId/signed-documents", isAuthenticated, async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user.claims.sub;
      
      const user = await storage.getUser(userId);
      // Only admins can upload signed documents
      if (!["master", "admin", "admin_jr"].includes(user?.role || "")) {
        return res.status(403).json({ message: "Solo administradores pueden subir documentos firmados" });
      }

      const validationResult = insertContractSignedDocumentSchema.safeParse({
        ...req.body,
        rentalContractId: contractId,
        uploadedById: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos", 
          errors: validationResult.error.flatten() 
        });
      }

      const sanitizedData = sanitizeObject(validationResult.data);
      const document = await storage.createContractSignedDocument(sanitizedData);

      await createAuditLog(
        req,
        "create",
        "contract_signed_document",
        document.id,
        `Documento firmado subido para contrato ${contractId}`
      );

      res.json(document);
    } catch (error) {
      console.error("Error uploading signed document:", error);
      res.status(500).json({ message: "Error al subir documento firmado" });
    }
  });

  // Rental Application routes (Rental Process Kanban)
  app.get("/api/rental-applications/eligible-applicants", isAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.query;
      
      if (!propertyId) {
        return res.status(400).json({ message: "propertyId is required" });
      }

      const completedAppointments = await storage.getAppointments({
        propertyId: propertyId as string,
        status: "completed",
      });

      const clientIds = [...new Set(completedAppointments.map(apt => apt.clientId))];
      
      const eligibleUsers = await Promise.all(
        clientIds.map(clientId => storage.getUser(clientId))
      );

      const validUsers = eligibleUsers.filter(user => user !== undefined);

      res.json(validUsers);
    } catch (error) {
      console.error("Error fetching eligible applicants:", error);
      res.status(500).json({ message: "Failed to fetch eligible applicants" });
    }
  });

  app.get("/api/rental-applications", isAuthenticated, async (req, res) => {
    try {
      const { status, propertyId, applicantId } = req.query;
      const filters: any = {};
      if (status) filters.status = status;
      if (propertyId) filters.propertyId = propertyId;
      if (applicantId) filters.applicantId = applicantId;

      const applications = await storage.getRentalApplications(filters);
      res.json(applications);
    } catch (error) {
      console.error("Error fetching rental applications:", error);
      res.status(500).json({ message: "Failed to fetch rental applications" });
    }
  });

  app.get("/api/rental-applications/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const application = await storage.getRentalApplication(id);
      if (!application) {
        return res.status(404).json({ message: "Rental application not found" });
      }
      res.json(application);
    } catch (error) {
      console.error("Error fetching rental application:", error);
      res.status(500).json({ message: "Failed to fetch rental application" });
    }
  });

  app.post("/api/rental-applications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Determine applicantId: admins/masters can specify, others use their own ID
      let applicantId = userId;
      if (req.body.applicantId && req.body.applicantId !== userId) {
        if (user && ["master", "admin", "admin_jr"].includes(user.role)) {
          applicantId = req.body.applicantId;
        }
        // Non-admins cannot specify different applicantId, silently use their own
      }
      
      const applicationData = insertRentalApplicationSchema.parse({
        ...req.body,
        applicantId,
      });

      const application = await storage.createRentalApplication(applicationData);
      
      // Log rental application creation
      await createAuditLog(
        req,
        "create",
        "rental_application",
        application.id,
        `Solicitud de renta creada - Estado: ${application.status}`
      );
      
      res.status(201).json(application);
    } catch (error: any) {
      console.error("Error creating rental application:", error);
      res.status(400).json({ message: error.message || "Failed to create rental application" });
    }
  });

  app.patch("/api/rental-applications/:id", isAuthenticated, requireResourceOwnership('rental-application'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const application = await storage.updateRentalApplication(id, req.body);
      
      // Log rental application update
      await createAuditLog(
        req,
        "update",
        "rental_application",
        id,
        `Solicitud de renta actualizada - Estado: ${application.status}`
      );
      
      res.json(application);
    } catch (error) {
      console.error("Error updating rental application:", error);
      res.status(500).json({ message: "Failed to update rental application" });
    }
  });

  app.patch("/api/rental-applications/:id/status", isAuthenticated, requireResourceOwnership('rental-application'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;
      
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      const application = await storage.updateRentalApplicationStatus(id, status);
      
      // Log status change
      await createAuditLog(
        req,
        "update",
        "rental_application",
        id,
        `Estado de solicitud cambiado a: ${status}`
      );
      
      res.json(application);
    } catch (error) {
      console.error("Error updating rental application status:", error);
      res.status(500).json({ message: "Failed to update rental application status" });
    }
  });

  app.delete("/api/rental-applications/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["master", "admin", "admin_jr"].includes(user.role)) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const application = await storage.getRentalApplication(id);
      if (!application) {
        return res.status(404).json({ message: "Rental application not found" });
      }

      // Log deletion
      await createAuditLog(
        req,
        "delete",
        "rental_application",
        id,
        `Solicitud de renta eliminada - Estado: ${application.status}`
      );

      await storage.deleteRentalApplication(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting rental application:", error);
      res.status(500).json({ message: "Failed to delete rental application" });
    }
  });

  // Rental Contract routes
  app.get("/api/rental-contracts", isAuthenticated, async (req, res) => {
    try {
      const { status, propertyId, tenantId, sellerId } = req.query;
      const filters: any = {};
      if (status) filters.status = status;
      if (propertyId) filters.propertyId = propertyId;
      if (tenantId) filters.tenantId = tenantId;
      if (sellerId) filters.sellerId = sellerId;

      const contracts = await storage.getRentalContracts(filters);
      res.json(contracts);
    } catch (error) {
      console.error("Error fetching rental contracts:", error);
      res.status(500).json({ message: "Failed to fetch rental contracts" });
    }
  });

  app.get("/api/rental-contracts/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const contract = await storage.getRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Rental contract not found" });
      }
      res.json(contract);
    } catch (error) {
      console.error("Error fetching rental contract:", error);
      res.status(500).json({ message: "Failed to fetch rental contract" });
    }
  });

  app.post("/api/rental-contracts/calculate-commission", isAuthenticated, async (req, res) => {
    try {
      const { monthlyRent, leaseDurationMonths, propertyId } = req.body;
      
      if (!monthlyRent || !leaseDurationMonths) {
        return res.status(400).json({ message: "monthlyRent and leaseDurationMonths are required" });
      }

      let hasReferral = false;
      let referralPercent = 20;

      if (propertyId) {
        const property = await storage.getProperty(propertyId);
        if (property?.referralPartnerId) {
          hasReferral = true;
          referralPercent = parseFloat(property.referralPercent || "20");
        }
      }

      const commissions = calculateRentalCommissions({
        monthlyRent: parseFloat(monthlyRent),
        leaseDurationMonths: parseInt(leaseDurationMonths),
        hasReferral,
        referralPercent,
      });

      res.json(commissions);
    } catch (error) {
      console.error("Error calculating commission:", error);
      res.status(500).json({ message: "Failed to calculate commission" });
    }
  });

  app.post("/api/rental-contracts", isAuthenticated, async (req: any, res) => {
    try {
      const { propertyId, monthlyRent, leaseDurationMonths, ...otherData } = req.body;

      const property = await storage.getProperty(propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      // Check if owner accepted rental terms during property submission
      const ownerSubmission = await storage.getPropertySubmissionDraftByProperty(propertyId);
      let ownerTermsSignedAt = null;
      
      // If submission draft has termsAcceptance, use it to pre-fill owner terms signature
      if (ownerSubmission?.termsAcceptance) {
        const terms = ownerSubmission.termsAcceptance as any;
        
        // Only use if all terms were properly accepted
        if (terms.acceptedTerms && terms.confirmedAccuracy && terms.acceptedCommission && terms.acceptedAt) {
          ownerTermsSignedAt = new Date(terms.acceptedAt);
        }
        // Note: If terms incomplete, we continue without pre-filling (backward compatible with legacy data)
      }

      const hasReferral = !!property.referralPartnerId;
      const referralPercent = parseFloat(property.referralPercent || "20");

      const commissions = calculateRentalCommissions({
        monthlyRent: parseFloat(monthlyRent),
        leaseDurationMonths: parseInt(leaseDurationMonths),
        hasReferral,
        referralPercent,
      });

      const contractData = insertRentalContractSchema.parse({
        ...otherData,
        propertyId,
        ownerId: property.ownerId,
        monthlyRent: monthlyRent.toString(),
        leaseDurationMonths: parseInt(leaseDurationMonths),
        totalCommissionMonths: commissions.totalCommissionMonths.toString(),
        totalCommissionAmount: commissions.totalCommissionAmount.toString(),
        sellerCommissionPercent: commissions.sellerCommissionPercent.toString(),
        referralCommissionPercent: commissions.referralCommissionPercent.toString(),
        homesappCommissionPercent: commissions.homesappCommissionPercent.toString(),
        sellerCommissionAmount: commissions.sellerCommissionAmount.toString(),
        referralCommissionAmount: commissions.referralCommissionAmount.toString(),
        homesappCommissionAmount: commissions.homesappCommissionAmount.toString(),
        referralPartnerId: property.referralPartnerId || null,
        ownerTermsSignedAt, // Auto-fill from submission draft acceptance
      });

      const contract = await storage.createRentalContract(contractData);

      await createAuditLog(
        req,
        "create",
        "rental_contract",
        contract.id,
        `Contrato de renta creado - Estado: ${contract.status}, Renta: $${monthlyRent}`
      );

      // Calculate rental health score automatically
      try {
        await storage.calculateRentalHealthScore(contract.id);
        
        // Create workflow event
        await storage.createWorkflowEvent({
          eventType: "contract_created",
          entityType: "contract",
          entityId: contract.id,
          userId: req.user.claims.sub,
          metadata: { propertyId, status: contract.status, monthlyRent: monthlyRent.toString() },
        });
      } catch (error) {
        console.error("Error in contract creation automation:", error);
      }

      res.status(201).json(contract);
    } catch (error) {
      console.error("Error creating rental contract:", error);
      res.status(400).json({ message: error.message || "Failed to create rental contract" });
    }
  });

  app.patch("/api/rental-contracts/:id", isAuthenticated, requireResourceOwnership('rental-contract'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const contract = await storage.updateRentalContract(id, req.body);

      await createAuditLog(
        req,
        "update",
        "rental_contract",
        id,
        `Contrato de renta actualizado - Estado: ${contract.status}`
      );

      // Recalculate rental health score
      try {
        await storage.calculateRentalHealthScore(id);
        
        // Create workflow event
        await storage.createWorkflowEvent({
          eventType: "contract_updated",
          entityType: "contract",
          entityId: id,
          userId: req.user.claims.sub,
          metadata: { updates: Object.keys(req.body) },
        });
      } catch (error) {
        console.error("Error in contract update automation:", error);
      }

      res.json(contract);
    } catch (error) {
      console.error("Error updating rental contract:", error);
      res.status(500).json({ message: "Failed to update rental contract" });
    }
  });

  app.patch("/api/rental-contracts/:id/status", isAuthenticated, requireResourceOwnership('rental-contract'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;

      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      const additionalData: any = {};
      const now = new Date();

      if (status === "apartado") {
        additionalData.apartadoDate = now;
      } else if (status === "firmado") {
        additionalData.contractSignedDate = now;
      } else if (status === "check_in") {
        additionalData.checkInDate = now;
        additionalData.payoutReleasedAt = now;
      }

      const contract = await storage.updateRentalContractStatus(id, status, additionalData);

      await createAuditLog(
        req,
        "update",
        "rental_contract",
        id,
        `Estado de contrato cambiado a: ${status}`
      );

      // Recalculate rental health score and create alerts
      try {
        const healthScore = await storage.calculateRentalHealthScore(id);
        
        // Create workflow event
        await storage.createWorkflowEvent({
          eventType: "contract_status_changed",
          entityType: "contract",
          entityId: id,
          userId: req.user.claims.sub,
          metadata: { newStatus: status },
        });

        // Create alerts based on health score
        if (healthScore.status === "critical" || healthScore.status === "poor") {
          await storage.createSystemAlert({
            userId: req.user.claims.sub,
            alertType: "rental_health_low",
            priority: healthScore.status === "critical" ? "high" : "medium",
            title: `Salud de Contrato ${healthScore.status === "critical" ? "Crítica" : "Baja"}`,
            message: `El contrato de renta requiere atención: score ${healthScore.score}/100`,
            relatedEntityType: "contract",
            relatedEntityId: id,
          });
        }

        // Alert for contracts near expiry
        if (healthScore.isNearExpiry && status === "check_in") {
          await storage.createSystemAlert({
            userId: req.user.claims.sub,
            alertType: "contract_expiring_soon",
            priority: "high",
            title: "Contrato próximo a vencer",
            message: `El contrato de renta vence pronto. Considerar renovación.`,
            relatedEntityType: "contract",
            relatedEntityId: id,
          });
        }
      } catch (error) {
        console.error("Error in contract status automation:", error);
      }

      res.json(contract);
    } catch (error) {
      console.error("Error updating rental contract status:", error);
      res.status(500).json({ message: "Failed to update rental contract status" });
    }
  });

  app.delete("/api/rental-contracts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);

      if (!user || !["master", "admin", "admin_jr"].includes(user.role)) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const contract = await storage.getRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Rental contract not found" });
      }

      await createAuditLog(
        req,
        "delete",
        "rental_contract",
        id,
        `Contrato de renta eliminado - Estado: ${contract.status}`
      );

      await storage.deleteRentalContract(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting rental contract:", error);
      res.status(500).json({ message: "Failed to delete rental contract" });
    }
  });

  // Active Rentals routes (for clients/tenants)
  app.get("/api/rentals/active", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get active rental contracts where user is tenant
      const activeRentals = await storage.getActiveRentalsByTenant(userId);
      
      // Filter sensitive fields before sending to client
      const filteredRentals = activeRentals.map(rental => ({
        id: rental.id,
        propertyId: rental.propertyId,
        rentalType: rental.leaseDurationMonths && rental.leaseDurationMonths <= 6 ? 'short_term' : 'long_term',
        monthlyRent: rental.monthlyRent,
        depositAmount: rental.securityDeposit,
        contractStartDate: rental.startDate,
        contractEndDate: rental.endDate,
        checkInDate: rental.startDate,
        status: rental.status,
        // Property information
        propertyTitle: rental.propertyTitle,
        propertyType: rental.propertyType,
        unitType: rental.unitType,
        condominiumId: rental.condominiumId,
        condoName: rental.condoName,
        unitNumber: rental.unitNumber,
        // Do not expose ownerId, sellerId, or internal notes
      }));
      
      res.json(filteredRentals);
    } catch (error) {
      console.error("Error fetching active rentals:", error);
      res.status(500).json({ message: "Failed to fetch active rentals" });
    }
  });

  // Client Dashboard Active Rentals endpoint
  app.get("/api/client/active-rentals", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get active rental contracts where user is tenant
      const activeRentals = await storage.getActiveRentalsByTenant(userId);
      res.json(activeRentals);
    } catch (error) {
      console.error("Error fetching client active rentals:", error);
      res.status(500).json({ message: "Failed to fetch active rentals" });
    }
  });

  // Client Dashboard Maintenance Requests endpoint
  app.get("/api/client/maintenance-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get all active rental contracts for this tenant
      const activeRentals = await storage.getActiveRentalsByTenant(userId);
      
      // Get maintenance requests for all active rentals
      const allRequests = [];
      for (const rental of activeRentals) {
        const requests = await storage.getTenantMaintenanceRequests(rental.id);
        allRequests.push(...requests);
      }
      
      res.json(allRequests);
    } catch (error) {
      console.error("Error fetching client maintenance requests:", error);
      res.status(500).json({ message: "Failed to fetch maintenance requests" });
    }
  });

  // Rental Opportunity Request routes
  // Get visited properties for client (completed or past appointments)
  app.get("/api/client/visited-properties", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || user.role !== "cliente") {
        return res.status(403).json({ message: "Solo los clientes pueden ver propiedades visitadas" });
      }
      
      const visitedProperties = await storage.getVisitedPropertiesByClient(userId);
      res.json(visitedProperties);
    } catch (error) {
      console.error("Error fetching visited properties:", error);
      res.status(500).json({ message: "Failed to fetch visited properties" });
    }
  });

  // Create rental opportunity request
  app.post("/api/rental-opportunity-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || user.role !== "cliente") {
        return res.status(403).json({ message: "Solo los clientes pueden solicitar oportunidades de renta" });
      }

      // Check if user already has a pending or approved request for this property
      const existingRequests = await storage.getRentalOpportunityRequestsByClient(userId);
      const propertyId = req.body.propertyId;
      
      const existingRequest = existingRequests.find(
        req => req.propertyId === propertyId && (req.status === 'pending' || req.status === 'approved')
      );
      
      if (existingRequest) {
        return res.status(409).json({ 
          message: existingRequest.status === 'approved' 
            ? "Ya tienes una solicitud aprobada para esta propiedad" 
            : "Ya tienes una solicitud pendiente para esta propiedad" 
        });
      }

      const request = await storage.createRentalOpportunityRequest({
        userId,
        propertyId,
        appointmentId: req.body.appointmentId,
        status: 'pending',
      });

      // Get property details for notification
      const property = await storage.getProperty(propertyId);
      
      // Notify all admins about the new request
      const admins = await storage.getUsersByRole("admin");
      const notificationPromises = admins.map(admin => 
        storage.createNotification({
          userId: admin.id,
          type: "opportunity",
          title: "Nueva Solicitud de Oportunidad de Renta",
          message: `${user.name} ha solicitado crear una oferta de renta para ${property?.title || 'una propiedad'}`,
          relatedEntityType: "rental_opportunity_request",
          relatedEntityId: request.id,
          priority: "medium",
        })
      );
      await Promise.all(notificationPromises);

      // Log the request creation
      await createAuditLog(
        req,
        "create",
        "rental_opportunity_request",
        request.id,
        `Solicitud de oportunidad de renta creada para propiedad ${propertyId}`
      );

      res.status(201).json(request);
    } catch (error) {
      console.error("Error creating rental opportunity request:", error);
      res.status(500).json({ message: "Failed to create rental opportunity request" });
    }
  });

  // Get rental opportunity requests for current client
  app.get("/api/rental-opportunity-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || user.role !== "cliente") {
        return res.status(403).json({ message: "Solo los clientes pueden ver sus solicitudes" });
      }
      
      const requests = await storage.getRentalOpportunityRequestsByClient(userId);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching rental opportunity requests:", error);
      res.status(500).json({ message: "Failed to fetch rental opportunity requests" });
    }
  });

  app.get("/api/rentals/:id/payments", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user has access to this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.tenantId !== userId && rental.ownerId !== userId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const payments = await storage.getRentalPayments(id);
      res.json(payments);
    } catch (error) {
      console.error("Error fetching rental payments:", error);
      res.status(500).json({ message: "Failed to fetch rental payments" });
    }
  });

  // Register payment with proof endpoint (authorization check first)
  app.post("/api/rentals/payments/:paymentId/register", isAuthenticated, async (req: any, res, next) => {
    try {
      const { paymentId } = req.params;
      const userId = req.user.claims.sub;
      
      // Get payment details and verify authorization BEFORE file upload
      const payment = await storage.getRentalPayment(paymentId);
      if (!payment) {
        return res.status(404).json({ message: "Payment not found" });
      }
      
      // Verify user is the tenant
      if (payment.tenantId !== userId) {
        return res.status(403).json({ message: "Only tenant can register payment" });
      }
      
      // Store payment in request for later use
      (req as any).validatedPayment = payment;
      
      // Now proceed with file upload
      uploadPaymentProof.single('proof')(req, res, async (err: any) => {
        if (err) {
          return res.status(400).json({ message: err.message || "File upload failed" });
        }
        
        // Require payment proof file
        if (!req.file) {
          return res.status(400).json({ message: "Payment proof is required" });
        }
        
        const paymentProofUrl = `/attached_assets/payment_proofs/${req.file.filename}`;
        
        // Update payment with proof and status
        const updatedPayment = await storage.updateRentalPayment(paymentId, {
          paymentDate: new Date(),
          paymentProof: paymentProofUrl,
          status: "paid",
          notes: req.body.notes || null,
        });
        
        // Get rental contract for notification
        const rental = await storage.getRentalContract(payment.rentalContractId);
        if (rental) {
          // Notify owner about payment
          await storage.createNotification({
            userId: rental.ownerId,
            type: "payment_received",
            title: "Pago registrado",
            message: `Tu inquilino ha registrado un pago de $${payment.amount}`,
            relatedEntityType: "rental_payment",
            relatedEntityId: paymentId,
          });
        }
        
        res.json(updatedPayment);
      });
    } catch (error: any) {
      console.error("Error registering payment:", error);
      res.status(500).json({ message: error.message || "Failed to register payment" });
    }
  });

  // Owner approves a payment
  app.post("/api/rentals/payments/:paymentId/approve", isAuthenticated, async (req: any, res) => {
    try {
      const { paymentId } = req.params;
      const userId = req.user.claims.sub;
      
      // Get payment details
      const payment = await storage.getRentalPayment(paymentId);
      if (!payment) {
        return res.status(404).json({ message: "Payment not found" });
      }
      
      // Get rental contract to verify user is owner
      const rental = await storage.getRentalContract(payment.rentalContractId);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.ownerId !== userId) {
        return res.status(403).json({ message: "Only owner can approve payments" });
      }
      
      // Approve the payment
      const approvedPayment = await storage.approveRentalPayment(paymentId, userId);
      
      // Notify tenant
      await storage.createNotification({
        userId: rental.tenantId,
        type: "payment_approved",
        title: "Pago aprobado",
        message: `El propietario ha aprobado tu pago de ${payment.serviceType === 'rent' ? 'renta' : payment.serviceType}`,
        relatedEntityType: "rental_payment",
        relatedEntityId: paymentId,
      });
      
      res.json(approvedPayment);
    } catch (error: any) {
      console.error("Error approving payment:", error);
      res.status(500).json({ message: error.message || "Failed to approve payment" });
    }
  });

  // Get pending payments for owner to approve
  app.get("/api/owner/pending-payments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (user?.role !== 'owner' && user?.role !== 'admin' && user?.role !== 'master') {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const payments = await storage.getPendingPaymentsByOwner(userId);
      res.json(payments);
    } catch (error: any) {
      console.error("Error fetching pending payments:", error);
      res.status(500).json({ message: error.message || "Failed to fetch pending payments" });
    }
  });

  app.post("/api/rentals/:id/maintenance-request", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user is tenant of this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.tenantId !== userId) {
        return res.status(403).json({ message: "Only tenant can create maintenance requests" });
      }
      
      const requestData = insertTenantMaintenanceRequestSchema.parse({
        ...req.body,
        rentalContractId: id,
        tenantId: userId,
        ownerId: rental.ownerId,
        propertyId: rental.propertyId,
      });
      
      const maintenanceRequest = await storage.createTenantMaintenanceRequest(requestData);
      
      // Create notification for owner
      await storage.createNotification({
        userId: rental.ownerId,
        type: "maintenance_request",
        title: "Nueva solicitud de mantenimiento",
        message: `Tu inquilino ha enviado una solicitud de mantenimiento: ${req.body.title}`,
        relatedEntityType: "maintenance_request",
        relatedEntityId: maintenanceRequest.id,
      });
      
      res.status(201).json(maintenanceRequest);
    } catch (error: any) {
      console.error("Error creating maintenance request:", error);
      res.status(400).json({ message: error.message || "Failed to create maintenance request" });
    }
  });

  app.get("/api/rentals/:id/maintenance-requests", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user has access to this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.tenantId !== userId && rental.ownerId !== userId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const requests = await storage.getTenantMaintenanceRequests(id);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching maintenance requests:", error);
      res.status(500).json({ message: "Failed to fetch maintenance requests" });
    }
  });

  // Get or create chat conversation for a rental
  app.get("/api/rentals/:id/chat-conversation", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user has access to this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      // Get maintenance staff assigned to the property
      const propertyStaff = await storage.getPropertyStaff(rental.propertyId);
      const maintenanceStaff = propertyStaff.filter(s => s.role === 'maintenance' && s.active);
      const maintenanceStaffIds = maintenanceStaff.map(s => s.staffId);
      
      // Check if user has access (tenant, owner, or maintenance staff)
      const isTenant = rental.tenantId === userId;
      const isOwner = rental.ownerId === userId;
      const isMaintenanceStaff = maintenanceStaffIds.includes(userId);
      
      if (!isTenant && !isOwner && !isMaintenanceStaff) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Check if conversation already exists
      let conversation = await storage.getChatConversationByRentalContractId(id);
      
      if (!conversation) {
        // Create new conversation
        const property = await storage.getProperty(rental.propertyId);
        const title = property 
          ? `Chat - ${property.title || 'Propiedad'}`
          : 'Chat - Renta Activa';
        
        conversation = await storage.createChatConversation({
          type: 'rental' as any,
          title,
          rentalContractId: id,
          createdById: userId,
        });
        
        // Add participants (tenant, owner, and maintenance staff)
        await storage.addChatParticipant({
          conversationId: conversation.id,
          userId: rental.tenantId,
        });
        
        await storage.addChatParticipant({
          conversationId: conversation.id,
          userId: rental.ownerId,
        });
        
        // Add maintenance staff as participants
        for (const staffId of maintenanceStaffIds) {
          await storage.addChatParticipant({
            conversationId: conversation.id,
            userId: staffId,
          });
        }
      } else {
        // Conversation exists - ensure all required participants are added
        const existingParticipants = await storage.getChatParticipants(conversation.id);
        const existingParticipantIds = existingParticipants.map(p => p.userId);
        
        // Collect all required participants
        const requiredParticipants = [
          rental.tenantId,
          rental.ownerId,
          ...maintenanceStaffIds
        ];
        
        // Add any missing participants
        for (const participantId of requiredParticipants) {
          if (!existingParticipantIds.includes(participantId)) {
            await storage.addChatParticipant({
              conversationId: conversation.id,
              userId: participantId,
            });
          }
        }
      }
      
      res.json(conversation);
    } catch (error: any) {
      console.error("Error getting/creating rental chat conversation:", error);
      res.status(500).json({ message: error.message || "Failed to get chat conversation" });
    }
  });

  // Owner Active Rentals routes
  app.get("/api/owner/active-rentals", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const rentals = await storage.getActiveRentalsByOwner(userId);
      res.json(rentals);
    } catch (error) {
      console.error("Error fetching owner active rentals:", error);
      res.status(500).json({ message: "Failed to fetch active rentals" });
    }
  });

  app.get("/api/owner/rentals/:id/inventory", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user is the owner of this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.ownerId !== userId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const inventory = await storage.getPropertyDeliveryInventory(id);
      res.json(inventory || null);
    } catch (error) {
      console.error("Error fetching inventory:", error);
      res.status(500).json({ message: "Failed to fetch inventory" });
    }
  });

  app.post("/api/owner/rentals/:id/inventory", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user is the owner of this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.ownerId !== userId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Validate request body with Zod partial schema for updates
      const updateSchema = insertPropertyDeliveryInventorySchema.partial();
      const validatedData = updateSchema.parse(req.body);
      
      // Check if inventory already exists
      const existing = await storage.getPropertyDeliveryInventory(id);
      
      let inventory;
      if (existing) {
        // Update existing inventory
        inventory = await storage.updatePropertyDeliveryInventory(existing.id, validatedData);
      } else {
        // Create new inventory
        const inventoryData = {
          ...validatedData,
          rentalContractId: id,
          propertyId: rental.propertyId,
          ownerId: userId,
          tenantId: rental.tenantId,
        };
        inventory = await storage.createPropertyDeliveryInventory(inventoryData);
      }
      
      res.json(inventory);
    } catch (error: any) {
      console.error("Error saving inventory:", error);
      res.status(400).json({ message: error.message || "Failed to save inventory" });
    }
  });

  app.get("/api/owner/rentals/:id/move-in-form", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user is the owner of this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.ownerId !== userId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const form = await storage.getTenantMoveInForm(id);
      res.json(form || null);
    } catch (error) {
      console.error("Error fetching move-in form:", error);
      res.status(500).json({ message: "Failed to fetch move-in form" });
    }
  });

  app.post("/api/owner/rentals/:id/move-in-form", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user is the owner of this rental
      const rental = await storage.getRentalContract(id);
      if (!rental) {
        return res.status(404).json({ message: "Rental not found" });
      }
      
      if (rental.ownerId !== userId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Validate request body with Zod partial schema for updates
      const updateSchema = insertTenantMoveInFormSchema.partial();
      const validatedData = updateSchema.parse(req.body);
      
      // Check if form already exists
      const existing = await storage.getTenantMoveInForm(id);
      
      let form;
      if (existing) {
        // Update existing form
        form = await storage.updateTenantMoveInForm(existing.id, validatedData);
      } else {
        // Create new form
        const formData = {
          ...validatedData,
          rentalContractId: id,
          tenantId: rental.tenantId,
        };
        form = await storage.createTenantMoveInForm(formData);
      }
      
      res.json(form);
    } catch (error: any) {
      console.error("Error saving move-in form:", error);
      res.status(400).json({ message: error.message || "Failed to save move-in form" });
    }
  });

  // Permission routes
  app.get("/api/users/:id/permissions", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const { id } = req.params;
      const permissions = await storage.getUserPermissions(id);
      res.json(permissions);
    } catch (error) {
      console.error("Error fetching permissions:", error);
      res.status(500).json({ message: "Failed to fetch permissions" });
    }
  });

  app.post("/api/permissions", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const permissionData = insertPermissionSchema.parse(req.body);
      const permission = await storage.addPermission(permissionData);
      res.status(201).json(permission);
    } catch (error: any) {
      console.error("Error adding permission:", error);
      res.status(400).json({ message: error.message || "Failed to add permission" });
    }
  });

  app.delete("/api/permissions", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      // Validate request body with Zod
      const removePermissionSchema = z.object({
        userId: z.string().min(1, "El ID del usuario es requerido"),
        permission: z.string().min(1, "El permiso es requerido")
      });
      
      const validationResult = removePermissionSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Datos inválidos",
          errors: validationResult.error.errors 
        });
      }
      
      const { userId, permission } = validationResult.data;
      await storage.removePermission(userId, permission);
      res.status(204).send();
    } catch (error) {
      console.error("Error removing permission:", error);
      res.status(500).json({ message: "Failed to remove permission" });
    }
  });

  // Budget routes
  app.get("/api/budgets", isAuthenticated, async (req, res) => {
    try {
      const { propertyId, staffId, status } = req.query;
      const filters: any = {};
      if (propertyId) filters.propertyId = propertyId;
      if (staffId) filters.staffId = staffId;
      if (status) filters.status = status;

      const budgets = await storage.getBudgets(filters);
      res.json(budgets);
    } catch (error) {
      console.error("Error fetching budgets:", error);
      res.status(500).json({ message: "Failed to fetch budgets" });
    }
  });

  app.get("/api/budgets/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const budget = await storage.getBudget(id);
      if (!budget) {
        return res.status(404).json({ message: "Budget not found" });
      }
      res.json(budget);
    } catch (error) {
      console.error("Error fetching budget:", error);
      res.status(500).json({ message: "Failed to fetch budget" });
    }
  });

  app.post("/api/budgets", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["master", "admin", "admin_jr", "management", "provider"].includes(user.role)) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const budgetData = insertBudgetSchema.parse({
        ...req.body,
        staffId: req.body.staffId || userId,
      });
      
      const budget = await storage.createBudget(budgetData);
      res.status(201).json(budget);
    } catch (error: any) {
      console.error("Error creating budget:", error);
      res.status(400).json({ message: error.message || "Failed to create budget" });
    }
  });

  app.patch("/api/budgets/:id", isAuthenticated, requireResourceOwnership('budget', 'staffId'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const budget = await storage.getBudget(id);

      if (!budget) {
        return res.status(404).json({ message: "Budget not found" });
      }

      if (!user || (budget.staffId !== userId && !["master", "admin", "admin_jr"].includes(user.role))) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const updatedBudget = await storage.updateBudget(id, req.body);
      res.json(updatedBudget);
    } catch (error) {
      console.error("Error updating budget:", error);
      res.status(500).json({ message: "Failed to update budget" });
    }
  });

  app.delete("/api/budgets/:id", isAuthenticated, requireResourceOwnership('budget', 'staffId'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const budget = await storage.getBudget(id);

      if (!budget) {
        return res.status(404).json({ message: "Budget not found" });
      }

      if (!user || (budget.staffId !== userId && !["master", "admin"].includes(user.role))) {
        return res.status(403).json({ message: "Forbidden" });
      }

      await storage.deleteBudget(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting budget:", error);
      res.status(500).json({ message: "Failed to delete budget" });
    }
  });

  // Task routes
  app.get("/api/tasks/stats", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const allTasks = await storage.getTasks({});
      const now = new Date();
      
      const stats = {
        total: allTasks.length,
        pending: allTasks.filter(t => t.status === "pending").length,
        inProgress: allTasks.filter(t => t.status === "in-progress").length,
        completed: allTasks.filter(t => t.status === "completed").length,
        overdue: allTasks.filter(t => {
          if (!t.dueDate || t.status === "completed" || t.status === "cancelled") return false;
          return new Date(t.dueDate) < now;
        }).length,
      };
      
      res.json(stats);
    } catch (error) {
      console.error("Error fetching task stats:", error);
      res.status(500).json({ message: "Failed to fetch task stats" });
    }
  });

  app.get("/api/tasks", isAuthenticated, async (req, res) => {
    try {
      const { propertyId, assignedToId, status, priority, search } = req.query;
      const filters: any = {};
      if (propertyId) filters.propertyId = propertyId;
      if (assignedToId) filters.assignedToId = assignedToId;
      if (status) filters.status = status;
      if (priority) filters.priority = priority;
      if (search) filters.search = search;

      const tasks = await storage.getTasks(filters);
      res.json(tasks);
    } catch (error) {
      console.error("Error fetching tasks:", error);
      res.status(500).json({ message: "Failed to fetch tasks" });
    }
  });

  app.get("/api/tasks/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const task = await storage.getTask(id);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      res.json(task);
    } catch (error) {
      console.error("Error fetching task:", error);
      res.status(500).json({ message: "Failed to fetch task" });
    }
  });

  app.post("/api/tasks", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user || !["master", "admin", "admin_jr", "management"].includes(user.role)) {
        return res.status(403).json({ message: "Forbidden" });
      }

      // Clean special values
      const cleanedBody = {
        ...req.body,
        budgetId: req.body.budgetId === "none" ? undefined : req.body.budgetId,
      };

      const taskData = insertTaskSchema.parse(cleanedBody);
      const task = await storage.createTask(taskData);
      
      // Log task creation
      await createAuditLog(
        req,
        "create",
        "task",
        task.id,
        `Tarea creada: ${task.title}`
      );
      
      res.status(201).json(task);
    } catch (error: any) {
      console.error("Error creating task:", error);
      res.status(400).json({ message: error.message || "Failed to create task" });
    }
  });

  app.patch("/api/tasks/:id", isAuthenticated, requireResourceOwnership('task', 'assignedToId'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const task = await storage.getTask(id);

      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }

      if (!user || (task.assignedToId !== userId && !["master", "admin", "admin_jr", "management"].includes(user.role))) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const updatedTask = await storage.updateTask(id, req.body);
      
      // Log task update
      await createAuditLog(
        req,
        "update",
        "task",
        id,
        `Tarea actualizada: ${updatedTask.title} - Estado: ${updatedTask.status}`
      );
      
      res.json(updatedTask);
    } catch (error) {
      console.error("Error updating task:", error);
      res.status(500).json({ message: "Failed to update task" });
    }
  });

  app.delete("/api/tasks/:id", isAuthenticated, requireResourceOwnership('task', 'assignedToId'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const task = await storage.getTask(id);

      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }

      if (!user || !["master", "admin", "management"].includes(user.role)) {
        return res.status(403).json({ message: "Forbidden" });
      }

      // Log task deletion (before deletion to capture details)
      await createAuditLog(
        req,
        "delete",
        "task",
        id,
        `Tarea eliminada: ${task.title}`
      );

      await storage.deleteTask(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting task:", error);
      res.status(500).json({ message: "Failed to delete task" });
    }
  });

  // Work report routes
  app.get("/api/work-reports", isAuthenticated, async (req, res) => {
    try {
      const { taskId, staffId } = req.query;
      const filters: any = {};
      if (taskId) filters.taskId = taskId;
      if (staffId) filters.staffId = staffId;

      const reports = await storage.getWorkReports(filters);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching work reports:", error);
      res.status(500).json({ message: "Failed to fetch work reports" });
    }
  });

  app.get("/api/work-reports/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const report = await storage.getWorkReport(id);
      if (!report) {
        return res.status(404).json({ message: "Work report not found" });
      }
      res.json(report);
    } catch (error) {
      console.error("Error fetching work report:", error);
      res.status(500).json({ message: "Failed to fetch work report" });
    }
  });

  app.post("/api/work-reports", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const reportData = insertWorkReportSchema.parse({
        ...req.body,
        staffId: req.body.staffId || userId,
      });

      const report = await storage.createWorkReport(reportData);
      res.status(201).json(report);
    } catch (error: any) {
      console.error("Error creating work report:", error);
      res.status(400).json({ message: error.message || "Failed to create work report" });
    }
  });

  // Audit log routes
  app.get("/api/audit-logs", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const { userId, entityType, entityId, action, limit } = req.query;
      const filters: any = {};
      if (userId) filters.userId = userId;
      if (entityType) filters.entityType = entityType;
      if (entityId) filters.entityId = entityId;
      if (action) filters.action = action;
      if (limit) filters.limit = parseInt(limit as string);

      const logs = await storage.getAuditLogs(filters);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  app.get("/api/audit-logs/user/:userId", isAuthenticated, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { limit } = req.query;
      const currentUserId = req.user.claims.sub;
      const currentUser = await storage.getUser(currentUserId);

      // Users can view their own audit logs, admins can view any user's logs
      if (userId !== currentUserId && !["master", "admin"].includes(currentUser?.role || "")) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const logs = await storage.getUserAuditHistory(userId, limit ? parseInt(limit as string) : 100);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching user audit history:", error);
      res.status(500).json({ message: "Failed to fetch user audit history" });
    }
  });

  app.post("/api/audit-logs", isAuthenticated, async (req: any, res) => {
    try {
      const logData = insertAuditLogSchema.parse(req.body);
      const log = await storage.createAuditLog(logData);
      res.status(201).json(log);
    } catch (error: any) {
      console.error("Error creating audit log:", error);
      res.status(400).json({ message: error.message || "Failed to create audit log" });
    }
  });

  // Notification routes
  app.get("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notifications = await storage.getNotifications(userId);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.post("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const notificationData = insertNotificationSchema.parse(req.body);
      const notification = await storage.createNotification(notificationData);
      res.status(201).json(notification);
    } catch (error: any) {
      console.error("Error creating notification:", error);
      res.status(400).json({ message: error.message || "Failed to create notification" });
    }
  });

  app.patch("/api/notifications/:id/read", isAuthenticated, requireResourceOwnership('notification', 'userId'), async (req, res) => {
    try {
      const { id } = req.params;
      const notification = await storage.markNotificationAsRead(id);
      res.json(notification);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  app.post("/api/notifications/mark-all-read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await storage.markAllNotificationsAsRead(userId);
      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });

  app.patch("/api/notifications/:id/unread", isAuthenticated, requireResourceOwnership('notification', 'userId'), async (req, res) => {
    try {
      const { id } = req.params;
      const notification = await storage.markNotificationAsUnread(id);
      res.json(notification);
    } catch (error) {
      console.error("Error marking notification as unread:", error);
      res.status(500).json({ message: "Failed to mark notification as unread" });
    }
  });

  app.delete("/api/notifications/:id", isAuthenticated, requireResourceOwnership('notification', 'userId'), async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteNotification(id);
      res.json({ message: "Notification deleted successfully" });
    } catch (error) {
      console.error("Error deleting notification:", error);
      res.status(500).json({ message: "Failed to delete notification" });
    }
  });

  // Chat routes
  app.get("/api/chat/conversations", isAuthenticated, async (req: any, res) => {
    try {
      const { type } = req.query;
      const userId = req.user.claims.sub;
      const conversations = await storage.getChatConversations({ type: type as string, userId });
      res.json(conversations);
    } catch (error) {
      console.error("Error fetching chat conversations:", error);
      res.status(500).json({ message: "Failed to fetch chat conversations" });
    }
  });

  app.get("/api/chat/conversations/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const conversation = await storage.getChatConversation(id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      res.json(conversation);
    } catch (error) {
      console.error("Error fetching chat conversation:", error);
      res.status(500).json({ message: "Failed to fetch chat conversation" });
    }
  });

  app.post("/api/chat/conversations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const currentUser = await storage.getUser(userId);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const conversationData = insertChatConversationSchema.parse(req.body);
      
      // Get and validate participants from request
      const participantUserIds = req.body.participants?.map((p: { userId: string }) => p.userId) || [];
      
      if (participantUserIds.length === 0) {
        return res.status(400).json({ message: "Conversations must have participants" });
      }
      
      // Fetch all participants to verify their roles
      const participantUsers = await Promise.all(
        participantUserIds.map((uid: string) => storage.getUser(uid))
      );
      
      const validParticipants = participantUsers.filter(u => u !== null);
      
      if (validParticipants.length !== participantUserIds.length) {
        return res.status(400).json({ message: "One or more participants not found" });
      }
      
      // Chat restriction 0: Sellers can only chat with leads whose email is verified
      if (conversationData.type === "lead") {
        const sellerParticipants = validParticipants.filter(p => p!.role === "seller");
        
        if (sellerParticipants.length > 0 && conversationData.leadId) {
          // Verify the lead's email is verified
          const lead = await storage.getLead(conversationData.leadId);
          if (!lead) {
            return res.status(404).json({ message: "Lead no encontrado" });
          }
          
          if (!lead.emailVerified) {
            return res.status(403).json({ 
              message: "No puedes chatear con este lead hasta que verifique su correo electrónico" 
            });
          }
        }
      }

      // Chat restriction 1: Owners can only chat with clients after rental completion
      if (conversationData.type === "rental") {
        const ownerParticipants = validParticipants.filter(p => p!.role === "owner");
        const clientParticipants = validParticipants.filter(p => p!.role === "cliente");
        
        // If both owner and client are participants, verify active rental
        if (ownerParticipants.length > 0 && clientParticipants.length > 0) {
          // Rental conversations must have a propertyId
          if (!conversationData.propertyId) {
            return res.status(400).json({ 
              message: "Rental conversations require a property ID" 
            });
          }
          
          // Get the property to find its owner
          const property = await storage.getProperty(conversationData.propertyId);
          if (!property) {
            return res.status(404).json({ message: "Property not found" });
          }
          
          // Verify one of the owner participants is the property owner
          const isPropertyOwnerInConversation = ownerParticipants.some(p => p!.id === property.ownerId);
          if (!isPropertyOwnerInConversation) {
            return res.status(403).json({ 
              message: "Rental conversations must include the property owner" 
            });
          }
          
          // Check if there's an active rental application between the property owner and any client
          const rentalApps = await storage.getRentalApplications({ propertyId: conversationData.propertyId });
          const clientIds = clientParticipants.map(p => p!.id);
          const hasActiveRental = rentalApps.some(
            app => clientIds.includes(app.clientId) && app.status === "activo"
          );
          
          if (!hasActiveRental) {
            return res.status(403).json({ 
              message: "Los propietarios solo pueden chatear con clientes después de completar el proceso de renta" 
            });
          }
        }
      }
      
      // Chat restriction 2: Appointment conversations require concierge involvement
      if (conversationData.type === "appointment") {
        const ownerParticipants = validParticipants.filter(p => p!.role === "owner");
        const clientParticipants = validParticipants.filter(p => p!.role === "cliente");
        const conciergeParticipants = validParticipants.filter(p => p!.role === "concierge");
        
        // If both owner and client are participants, ensure a concierge is also present
        if (ownerParticipants.length > 0 && clientParticipants.length > 0) {
          if (conciergeParticipants.length === 0) {
            return res.status(403).json({ 
              message: "Las conversaciones de citas entre propietarios y clientes requieren la participación de un conserje" 
            });
          }
        }
      }
      
      const conversation = await storage.createChatConversation(conversationData);
      res.status(201).json(conversation);
    } catch (error: any) {
      console.error("Error creating chat conversation:", error);
      res.status(400).json({ message: error.message || "Failed to create chat conversation" });
    }
  });

  app.get("/api/chat/conversations/:id/messages", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const messages = await storage.getChatMessages(id);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching chat messages:", error);
      res.status(500).json({ message: "Failed to fetch chat messages" });
    }
  });

  app.post("/api/chat/messages", isAuthenticated, async (req: any, res) => {
    try {
      const sanitizedBody = {
        ...req.body,
        content: sanitizeText(req.body.content),
      };
      const messageData = insertChatMessageSchema.parse(sanitizedBody);
      const message = await storage.createChatMessage(messageData);
      
      // Broadcast message to all connected clients in this conversation
      const conversationId = messageData.conversationId;
      if (wsClients.has(conversationId)) {
        const clients = wsClients.get(conversationId)!;
        const messagePayload = JSON.stringify({
          type: 'new_message',
          conversationId,
          message
        });
        
        clients.forEach((client) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(messagePayload);
          }
        });
      }
      
      res.status(201).json(message);
    } catch (error: any) {
      console.error("Error creating chat message:", error);
      res.status(400).json({ message: error.message || "Failed to create chat message" });
    }
  });

  app.post("/api/chat/participants", isAuthenticated, async (req: any, res) => {
    try {
      const participantData = insertChatParticipantSchema.parse(req.body);
      const participant = await storage.addChatParticipant(participantData);
      res.status(201).json(participant);
    } catch (error: any) {
      console.error("Error adding chat participant:", error);
      res.status(400).json({ message: error.message || "Failed to add chat participant" });
    }
  });

  app.get("/api/chat/conversations/:id/participants", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const participants = await storage.getChatParticipants(id);
      res.json(participants);
    } catch (error) {
      console.error("Error fetching chat participants:", error);
      res.status(500).json({ message: "Failed to fetch chat participants" });
    }
  });

  app.patch("/api/chat/conversations/:id/mark-read", isAuthenticated, requireResourceOwnership('conversation'), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      const conversation = await storage.getChatConversation(id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      
      const updated = await storage.markConversationAsRead(id, userId);
      if (!updated) {
        return res.status(403).json({ message: "You are not a participant in this conversation" });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking conversation as read:", error);
      res.status(500).json({ message: "Failed to mark conversation as read" });
    }
  });

  // Appointment chat routes
  app.post("/api/chat/appointment/:appointmentId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { appointmentId } = req.params;

      // Get the appointment with all details
      const appointment = await storage.getAppointment(appointmentId);
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      // Get the property to check ownership
      const property = await storage.getProperty(appointment.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      // Security: User must be the property owner OR the assigned concierge
      const isOwner = property.ownerId === userId;
      const isConcierge = appointment.conciergeId === userId;
      
      if (!isOwner && !isConcierge) {
        return res.status(403).json({ message: "You do not have access to this appointment chat" });
      }

      // Check if conversation already exists for this appointment
      const existingConversation = await storage.getChatConversationByAppointmentId(appointmentId);
      
      if (existingConversation) {
        // Return existing conversation
        return res.json(existingConversation);
      }

      // Create new appointment chat conversation
      const propertyDisplay = property.customListingTitle || 
        (property.condoId ? `${property.condoName || 'Propiedad'} ${property.unitNumber || ''}` : property.title || 'Propiedad');
      
      const appointmentDate = format(new Date(appointment.date), "dd MMM yyyy HH:mm", { locale: es });
      
      const conversation = await storage.createChatConversation({
        type: "appointment",
        title: `Visita: ${propertyDisplay} - ${appointmentDate}`,
        createdById: userId,
        isBot: false,
        appointmentId: appointmentId,
      });

      // Add both property owner and concierge as participants
      await storage.addChatParticipant({
        conversationId: conversation.id,
        userId: property.ownerId,
      });

      if (appointment.conciergeId) {
        await storage.addChatParticipant({
          conversationId: conversation.id,
          userId: appointment.conciergeId,
        });
      }

      // Create initial system message
      const initialMessage = await storage.createChatMessage({
        conversationId: conversation.id,
        senderId: userId,
        message: `Chat de visita creado. Propiedad: ${propertyDisplay}. Fecha: ${appointmentDate}.`,
        isBot: false,
      });

      res.status(201).json({
        ...conversation,
        initialMessage
      });
    } catch (error: any) {
      console.error("Error creating/getting appointment chat:", error);
      res.status(500).json({ message: error.message || "Failed to create appointment chat" });
    }
  });

  // Chatbot routes
  app.post("/api/chat/chatbot/start", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get chatbot config
      const config = await storage.getChatbotConfig();
      
      if (!config) {
        return res.status(500).json({ message: "Chatbot configuration not found" });
      }

      // Check if chatbot is active
      if (!config.isActive) {
        return res.status(503).json({ message: "El asistente virtual no está disponible en este momento" });
      }

      // Create chatbot conversation
      const conversation = await storage.createChatConversation({
        type: "appointment",
        title: `Chat con ${config.name || 'Asistente Virtual'} - ${user.firstName || user.email}`,
        createdById: userId,
        isBot: true,
      });

      // Add user as participant
      await storage.addChatParticipant({
        conversationId: conversation.id,
        userId: userId,
      });

      // Send welcome message
      const welcomeMessage = await storage.createChatMessage({
        conversationId: conversation.id,
        senderId: userId,
        message: config.welcomeMessage,
        isBot: true,
      });

      res.status(201).json({
        ...conversation,
        welcomeMessage
      });
    } catch (error: any) {
      console.error("Error starting chatbot conversation:", error);
      res.status(500).json({ message: error.message || "Failed to start chatbot conversation" });
    }
  });

  app.post("/api/chat/chatbot/message", chatbotLimiter, isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { conversationId, message } = req.body;

      if (!conversationId || !message) {
        return res.status(400).json({ message: "Missing conversationId or message" });
      }

      // Get user info
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get chatbot config
      const config = await storage.getChatbotConfig();
      if (!config) {
        return res.status(500).json({ message: "Chatbot configuration not found" });
      }

      // Check if chatbot is active
      if (!config.isActive) {
        return res.status(503).json({ message: "El asistente virtual no está disponible en este momento" });
      }

      // Get user's presentation cards
      const presentationCardsData = await storage.getPresentationCards(userId);

      // Get available properties
      const allProperties = await storage.getProperties({ active: true });

      // Get conversation history
      const messages = await storage.getChatMessages(conversationId);
      const conversationHistory = messages.map(msg => ({
        role: msg.isBot ? 'assistant' as const : 'user' as const,
        content: msg.message
      }));

      // Process message with chatbot
      const chatbotResponse = await processChatbotMessage(
        message,
        {
          user,
          presentationCards: presentationCardsData,
          availableProperties: allProperties,
          config
        },
        conversationHistory
      );

      // Save user message
      const userMessage = await storage.createChatMessage({
        conversationId,
        senderId: userId,
        message,
        isBot: false,
      });

      // Save chatbot response
      const botMessage = await storage.createChatMessage({
        conversationId,
        senderId: userId,
        message: chatbotResponse.message,
        isBot: true,
      });

      // If chatbot suggested properties, create auto-suggestions
      if (chatbotResponse.suggestedProperties && chatbotResponse.suggestedProperties.length > 0 && presentationCardsData.length > 0) {
        const activeCard = presentationCardsData.find(card => card.isActive);
        if (activeCard) {
          for (const property of chatbotResponse.suggestedProperties) {
            // Check if suggestion already exists
            const existingSuggestions = await db
              .select()
              .from(autoSuggestions)
              .where(
                and(
                  eq(autoSuggestions.propertyId, property.id),
                  eq(autoSuggestions.presentationCardId, activeCard.id)
                )
              );

            if (existingSuggestions.length === 0) {
              await db.insert(autoSuggestions).values({
                propertyId: property.id,
                clientId: userId,
                presentationCardId: activeCard.id,
                matchScore: 80, // Default score from chatbot
                matchReasons: ["Sugerido por asistente virtual"],
              });
            }
          }
        }
      }

      // Broadcast messages to WebSocket clients
      if (wsClients.has(conversationId)) {
        const clients = wsClients.get(conversationId)!;
        clients.forEach((client) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'new_message',
              conversationId,
              message: botMessage
            }));
          }
        });
      }

      res.json({
        userMessage,
        botMessage: {
          ...botMessage,
          suggestedProperties: chatbotResponse.suggestedProperties
        }
      });
    } catch (error: any) {
      console.error("Error processing chatbot message:", error);
      res.status(500).json({ message: error.message || "Failed to process chatbot message" });
    }
  });

  // Generate property recommendations using chatbot AI
  app.post("/api/chatbot/generate-recommendations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { presentationCardId } = req.body;

      if (!presentationCardId) {
        return res.status(400).json({ message: "Missing presentationCardId" });
      }

      // Get presentation card
      const [card] = await db
        .select()
        .from(presentationCards)
        .where(eq(presentationCards.id, presentationCardId));

      if (!card) {
        return res.status(404).json({ message: "Presentation card not found" });
      }

      if (card.clientId !== userId) {
        return res.status(403).json({ message: "Unauthorized" });
      }

      // Get available properties
      const allProperties = await storage.getProperties({ active: true });

      // Generate recommendations using AI
      const recommendations = await generatePropertyRecommendations(card, allProperties);

      // Save recommendations to database
      for (const rec of recommendations) {
        // Check if suggestion already exists
        const existingSuggestions = await db
          .select()
          .from(autoSuggestions)
          .where(
            and(
              eq(autoSuggestions.propertyId, rec.propertyId),
              eq(autoSuggestions.presentationCardId, presentationCardId)
            )
          );

        if (existingSuggestions.length === 0) {
          await db.insert(autoSuggestions).values({
            propertyId: rec.propertyId,
            clientId: userId,
            presentationCardId,
            matchScore: rec.matchScore,
            matchReasons: rec.matchReasons,
          });
        }
      }

      res.json({ recommendations });
    } catch (error: any) {
      console.error("Error generating recommendations:", error);
      res.status(500).json({ message: error.message || "Failed to generate recommendations" });
    }
  });

  // Chatbot status route (public for clients)
  app.get("/api/chatbot/status", isAuthenticated, async (req: any, res) => {
    try {
      const config = await storage.getChatbotConfig();
      
      if (!config) {
        return res.status(404).json({ message: "Chatbot configuration not found" });
      }

      // Only return public status information
      res.json({
        isActive: config.isActive,
        name: config.name,
      });
    } catch (error: any) {
      console.error("Error fetching chatbot status:", error);
      res.status(500).json({ message: error.message || "Failed to fetch chatbot status" });
    }
  });

  // Chatbot Configuration routes (admin only)
  app.get("/api/chatbot/config", isAuthenticated, async (req: any, res) => {
    try {
      const userRole = req.user.role;
      
      // Only admin and master can access chatbot config
      if (userRole !== "admin" && userRole !== "master") {
        return res.status(403).json({ message: "Unauthorized" });
      }

      const config = await storage.getChatbotConfig();
      
      if (!config) {
        return res.status(404).json({ message: "Chatbot configuration not found" });
      }

      res.json(config);
    } catch (error: any) {
      console.error("Error fetching chatbot config:", error);
      res.status(500).json({ message: error.message || "Failed to fetch chatbot configuration" });
    }
  });

  app.put("/api/chatbot/config", isAuthenticated, async (req: any, res) => {
    try {
      const userRole = req.user.role;
      const userId = req.user.claims.sub;
      
      // Only admin and master can update chatbot config
      if (userRole !== "admin" && userRole !== "master") {
        return res.status(403).json({ message: "Unauthorized" });
      }

      const updates = req.body;
      
      // Add updatedBy field
      updates.updatedBy = userId;

      const updatedConfig = await storage.updateChatbotConfig(updates);

      res.json(updatedConfig);
    } catch (error: any) {
      console.error("Error updating chatbot config:", error);
      res.status(500).json({ message: error.message || "Failed to update chatbot configuration" });
    }
  });

  // Feedback routes
  app.get("/api/feedback", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { type, status } = req.query;
      const filters: any = {};
      
      if (type) filters.type = type;
      if (status) filters.status = status;
      
      const feedbackList = await storage.getAllFeedback(filters);
      res.json(feedbackList);
    } catch (error: any) {
      console.error("Error fetching feedback:", error);
      res.status(500).json({ message: "Failed to fetch feedback" });
    }
  });

  app.get("/api/feedback/my-feedback", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }
      
      const feedbackList = await storage.getAllFeedback({ userId });
      res.json(feedbackList);
    } catch (error: any) {
      console.error("Error fetching user feedback:", error);
      res.status(500).json({ message: "Failed to fetch user feedback" });
    }
  });

  app.post("/api/feedback", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Usuario no autenticado" });
      }

      const sanitizedBody = {
        ...req.body,
        title: sanitizeText(req.body.title),
        description: sanitizeHtml(req.body.description),
      };

      const validationResult = insertFeedbackSchema.safeParse(sanitizedBody);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Datos inválidos",
          errors: validationResult.error.errors,
        });
      }

      const newFeedback = await storage.createFeedback({
        ...validationResult.data,
        userId,
      });

      await createAuditLog(
        req,
        "create",
        "feedback",
        newFeedback.id,
        `Feedback creado: ${newFeedback.type} - ${newFeedback.title}`
      );

      res.status(201).json(newFeedback);
    } catch (error: any) {
      console.error("Error creating feedback:", error);
      res.status(500).json({ message: "Failed to create feedback" });
    }
  });

  app.patch("/api/feedback/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      const validationResult = updateFeedbackSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Datos inválidos",
          errors: validationResult.error.errors,
        });
      }

      const updatedFeedback = await storage.updateFeedback(id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "feedback",
        id,
        `Feedback actualizado a: ${updatedFeedback.status}`
      );

      res.json(updatedFeedback);
    } catch (error: any) {
      console.error("Error updating feedback:", error);
      res.status(500).json({ message: "Failed to update feedback" });
    }
  });

  // Error Log routes - Automatic error tracking
  app.post("/api/error-logs", async (req: any, res) => {
    try {
      // Allow unauthenticated error logging for critical errors
      const userId = req.user?.claims?.sub || null;
      const user = userId ? await storage.getUser(userId) : null;

      const errorData = {
        ...req.body,
        userId,
        userEmail: user?.email || req.body.userEmail,
        userRole: user?.role || req.body.userRole,
        userAgent: req.headers['user-agent'] || '',
      };

      // Validate error data with Zod
      const validationResult = insertErrorLogSchema.safeParse(errorData);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Datos inválidos",
          errors: validationResult.error.errors,
        });
      }

      const newErrorLog = await storage.createErrorLog(validationResult.data);

      // Notify all admins about new errors
      const admins = await storage.getUsersByRole("admin");
      const masters = await storage.getUsersByRole("master");
      const adminJrs = await storage.getUsersByRole("admin_jr");
      const allAdmins = [...admins, ...masters, ...adminJrs];

      for (const admin of allAdmins) {
        await storage.createNotification({
          userId: admin.id,
          type: "system",
          title: "Nuevo Error en la Aplicación",
          message: `${errorData.errorType}: ${errorData.errorMessage.substring(0, 100)}...`,
          relatedEntityType: "error_log",
          relatedEntityId: newErrorLog.id,
          priority: "high",
        });
      }

      res.status(201).json(newErrorLog);
    } catch (error: any) {
      console.error("Error creating error log:", error);
      res.status(500).json({ message: "Failed to create error log" });
    }
  });

  app.get("/api/error-logs", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { status, errorType, userId } = req.query;
      const filters: any = {};
      
      if (status) filters.status = status;
      if (errorType) filters.errorType = errorType;
      if (userId) filters.userId = userId;
      
      const errorLogs = await storage.getAllErrorLogs(filters);
      res.json(errorLogs);
    } catch (error: any) {
      console.error("Error fetching error logs:", error);
      res.status(500).json({ message: "Failed to fetch error logs" });
    }
  });

  app.patch("/api/error-logs/:id", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      const updates: any = { ...req.body };
      
      // Set assignedTo if changing to investigating status
      if (updates.status === "investigating" && !updates.assignedTo) {
        updates.assignedTo = userId;
      }
      
      // Set resolvedAt if changing to resolved status
      if (updates.status === "resolved" && !updates.resolvedAt) {
        updates.resolvedAt = new Date();
      }

      const updatedErrorLog = await storage.updateErrorLog(id, updates);

      await createAuditLog(
        req,
        "update",
        "error_log",
        id,
        `Error log actualizado a: ${updatedErrorLog.status}`
      );

      res.json(updatedErrorLog);
    } catch (error: any) {
      console.error("Error updating error log:", error);
      res.status(500).json({ message: "Failed to update error log" });
    }
  });

  // ============================================================================
  // INCOME MANAGEMENT SYSTEM ROUTES
  // ============================================================================

  // Rental Commission Config endpoints (Admin only)
  app.get("/api/income/commission-configs", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { propertyId, userId } = req.query;
      const configs = await storage.getRentalCommissionConfigs({
        propertyId: propertyId as string,
        userId: userId as string,
      });
      res.json(configs);
    } catch (error: any) {
      console.error("Error fetching commission configs:", error);
      res.status(500).json({ message: "Failed to fetch commission configs" });
    }
  });

  app.get("/api/income/commission-configs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const config = await storage.getRentalCommissionConfig(req.params.id);
      if (!config) {
        return res.status(404).json({ message: "Commission config not found" });
      }
      res.json(config);
    } catch (error: any) {
      console.error("Error fetching commission config:", error);
      res.status(500).json({ message: "Failed to fetch commission config" });
    }
  });

  app.post("/api/income/commission-configs", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const validationResult = insertRentalCommissionConfigSchema.safeParse({
        ...req.body,
        createdBy: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const config = await storage.createRentalCommissionConfig(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "rental_commission_config",
        config.id,
        `Created commission config`
      );

      res.status(201).json(config);
    } catch (error: any) {
      console.error("Error creating commission config:", error);
      res.status(500).json({ message: "Failed to create commission config" });
    }
  });

  app.put("/api/income/commission-configs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const validationResult = insertRentalCommissionConfigSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const updated = await storage.updateRentalCommissionConfig(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "rental_commission_config",
        req.params.id,
        `Updated commission config`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating commission config:", error);
      res.status(500).json({ message: "Failed to update commission config" });
    }
  });

  app.delete("/api/income/commission-configs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      await storage.deleteRentalCommissionConfig(req.params.id);

      await createAuditLog(
        req,
        "delete",
        "rental_commission_config",
        req.params.id,
        `Deleted commission config`
      );

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting commission config:", error);
      res.status(500).json({ message: "Failed to delete commission config" });
    }
  });

  // Accountant Assignment endpoints (Admin only)
  app.get("/api/income/assignments", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { accountantId, assignmentType, propertyId, userId } = req.query;
      const assignments = await storage.getAccountantAssignments({
        accountantId: accountantId as string,
        assignmentType: assignmentType as string,
        propertyId: propertyId as string,
        userId: userId as string,
      });
      res.json(assignments);
    } catch (error: any) {
      console.error("Error fetching accountant assignments:", error);
      res.status(500).json({ message: "Failed to fetch accountant assignments" });
    }
  });

  app.get("/api/income/my-assignments", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const assignments = await storage.getAccountantActiveAssignments(userId);
      res.json(assignments);
    } catch (error: any) {
      console.error("Error fetching my assignments:", error);
      res.status(500).json({ message: "Failed to fetch assignments" });
    }
  });

  app.post("/api/income/assignments", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const validationResult = insertAccountantAssignmentSchema.safeParse({
        ...req.body,
        createdBy: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const assignment = await storage.createAccountantAssignment(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "accountant_assignment",
        assignment.id,
        `Created accountant assignment for ${assignment.accountantId}`
      );

      res.status(201).json(assignment);
    } catch (error: any) {
      console.error("Error creating accountant assignment:", error);
      res.status(500).json({ message: "Failed to create accountant assignment" });
    }
  });

  app.put("/api/income/assignments/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const validationResult = insertAccountantAssignmentSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const updated = await storage.updateAccountantAssignment(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "accountant_assignment",
        req.params.id,
        `Updated accountant assignment`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating accountant assignment:", error);
      res.status(500).json({ message: "Failed to update accountant assignment" });
    }
  });

  app.delete("/api/income/assignments/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      await storage.deleteAccountantAssignment(req.params.id);

      await createAuditLog(
        req,
        "delete",
        "accountant_assignment",
        req.params.id,
        `Deleted accountant assignment`
      );

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting accountant assignment:", error);
      res.status(500).json({ message: "Failed to delete accountant assignment" });
    }
  });

  // Payout Batch endpoints
  app.get("/api/income/batches", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const { status, createdBy } = req.query;
      const batches = await storage.getPayoutBatches({
        status: status as string,
        createdBy: createdBy as string,
      });
      res.json(batches);
    } catch (error: any) {
      console.error("Error fetching payout batches:", error);
      res.status(500).json({ message: "Failed to fetch payout batches" });
    }
  });

  app.get("/api/income/batches/:id", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const batch = await storage.getPayoutBatch(req.params.id);
      if (!batch) {
        return res.status(404).json({ message: "Payout batch not found" });
      }
      res.json(batch);
    } catch (error: any) {
      console.error("Error fetching payout batch:", error);
      res.status(500).json({ message: "Failed to fetch payout batch" });
    }
  });

  app.post("/api/income/batches", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const batchNumber = await storage.generatePayoutBatchNumber();

      const validationResult = insertPayoutBatchSchema.safeParse({
        ...req.body,
        batchNumber,
        createdBy: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const batch = await storage.createPayoutBatch(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "payout_batch",
        batch.id,
        `Created payout batch ${batch.batchNumber}`
      );

      res.status(201).json(batch);
    } catch (error: any) {
      console.error("Error creating payout batch:", error);
      res.status(500).json({ message: "Failed to create payout batch" });
    }
  });

  app.put("/api/income/batches/:id", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const validationResult = insertPayoutBatchSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const updated = await storage.updatePayoutBatch(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "payout_batch",
        req.params.id,
        `Updated payout batch ${updated.batchNumber}`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating payout batch:", error);
      res.status(500).json({ message: "Failed to update payout batch" });
    }
  });

  app.post("/api/income/batches/:id/status", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { status, notes } = req.body;
      const userId = (req.user as any).claims.sub;

      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      const updated = await storage.updatePayoutBatchStatus(req.params.id, status, userId, notes);

      await createAuditLog(
        req,
        "update",
        "payout_batch",
        req.params.id,
        `Changed payout batch status to ${status}`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating payout batch status:", error);
      res.status(500).json({ message: "Failed to update payout batch status" });
    }
  });

  // Income Transaction endpoints
  app.get("/api/income/transactions", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const dbUser = (req as any).dbUser;
      
      const { beneficiaryId, category, status, propertyId, payoutBatchId, fromDate, toDate } = req.query;

      // Apply accountant scope filtering if user is accountant
      const filters: any = {
        beneficiaryId: beneficiaryId as string,
        category: category as string,
        excludeCategories: excludeCategories ? (excludeCategories as string).split(",") : undefined,
        status: status as string,
        propertyId: propertyId as string,
        payoutBatchId: payoutBatchId as string,
        fromDate: fromDate ? new Date(fromDate as string) : undefined,
        toDate: toDate ? new Date(toDate as string) : undefined,
      };

      // If user is accountant (not admin), apply scope filtering
      if (dbUser.role === "accountant") {
        filters.accountantId = userId;
      }

      const transactions = await storage.getIncomeTransactions(filters);
      res.json(transactions);
    } catch (error: any) {
      console.error("Error fetching income transactions:", error);
      res.status(500).json({ message: "Failed to fetch income transactions" });
    }
  });

  app.get("/api/income/transactions/:id", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const transaction = await storage.getIncomeTransaction(req.params.id);
      if (!transaction) {
        return res.status(404).json({ message: "Income transaction not found" });
      }
      res.json(transaction);
    } catch (error: any) {
      console.error("Error fetching income transaction:", error);
      res.status(500).json({ message: "Failed to fetch income transaction" });
    }
  });

  app.post("/api/income/transactions", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const validationResult = insertIncomeTransactionSchema.safeParse({
        ...req.body,
        createdBy: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const transaction = await storage.createIncomeTransaction(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "income_transaction",
        transaction.id,
        `Created income transaction for ${transaction.beneficiaryId}`
      );

      res.status(201).json(transaction);
    } catch (error: any) {
      console.error("Error creating income transaction:", error);
      res.status(500).json({ message: "Failed to create income transaction" });
    }
  });

  app.put("/api/income/transactions/:id", isAuthenticated, requireAccountantOrAdmin, async (req, res) => {
    try {
      const validationResult = insertIncomeTransactionSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const updated = await storage.updateIncomeTransaction(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "income_transaction",
        req.params.id,
        `Updated income transaction`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating income transaction:", error);
      res.status(500).json({ message: "Failed to update income transaction" });
    }
  });

  app.post("/api/income/transactions/:id/status", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { status, notes, rejectionReason } = req.body;
      const userId = (req.user as any).claims.sub;

      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      if (status === "paid") {
        const transaction = await storage.getIncomeTransaction(req.params.id);
        if (!transaction) {
          return res.status(404).json({ message: "Transaction not found" });
        }

        const beneficiary = await storage.getUser(transaction.beneficiaryId);
        if (!beneficiary) {
          return res.status(404).json({ message: "Beneficiary not found" });
        }

        if (beneficiary.role === "seller") {
          if (!beneficiary.commissionTermsAccepted) {
            return res.status(400).json({ 
              message: "El vendedor debe aceptar los términos y condiciones de comisiones antes de recibir pagos",
              error: "TERMS_NOT_ACCEPTED"
            });
          }

          if (beneficiary.documentApprovalStatus !== "approved") {
            return res.status(400).json({ 
              message: "El vendedor debe tener un documento de identificación aprobado antes de recibir pagos",
              error: "DOCUMENT_NOT_APPROVED",
              documentStatus: beneficiary.documentApprovalStatus || "none"
            });
          }
        }
      }

      const updated = await storage.updateIncomeTransactionStatus(
        req.params.id,
        status,
        userId,
        notes,
        rejectionReason
      );

      await createAuditLog(
        req,
        "update",
        "income_transaction",
        req.params.id,
        `Changed income transaction status to ${status}`
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating income transaction status:", error);
      res.status(500).json({ message: "Failed to update income transaction status" });
    }
  });

  // Get my income transactions (for clients and owners)
  app.get("/api/income/my-transactions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      const { category, status, fromDate, toDate } = req.query;

      const transactions = await storage.getIncomeTransactions({
        beneficiaryId: userId,
        category: category as string,
        excludeCategories: excludeCategories ? (excludeCategories as string).split(",") : undefined,
        status: status as string,
        fromDate: fromDate ? new Date(fromDate as string) : undefined,
        toDate: toDate ? new Date(toDate as string) : undefined,
      });

      res.json(transactions);
    } catch (error: any) {
      console.error("Error fetching user income transactions:", error);
      res.status(500).json({ message: "Failed to fetch income transactions" });
    }
  });

  // Get my income summary (for clients and owners)
  app.get("/api/income/my-summary", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      const transactions = await storage.getIncomeTransactions({
        beneficiaryId: userId,
      });

      const totalEarnings = transactions.reduce((sum, t) => sum + t.amount, 0);
      const paidAmount = transactions
        .filter(t => t.status === "paid")
        .reduce((sum, t) => sum + t.amount, 0);
      const pendingAmount = transactions
        .filter(t => t.status === "pending")
        .reduce((sum, t) => sum + t.amount, 0);

      const byCategory = transactions.reduce((acc, t) => {
        if (!acc[t.category]) {
          acc[t.category] = { count: 0, total: 0 };
        }
        acc[t.category].count++;
        acc[t.category].total += t.amount;
        return acc;
      }, {} as Record<string, { count: number; total: number }>);

      res.json({
        totalEarnings,
        paidAmount,
        pendingAmount,
        transactionCount: transactions.length,
        byCategory,
      });
    } catch (error: any) {
      console.error("Error fetching user income summary:", error);
      res.status(500).json({ message: "Failed to fetch income summary" });
    }
  });

  // Income Reports endpoint (Admin only)
  app.get("/api/income/reports", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { beneficiaryId, propertyId, category, status, fromDate, toDate, groupBy } = req.query;

      const reports = await storage.getIncomeReports({
        beneficiaryId: beneficiaryId as string,
        propertyId: propertyId as string,
        category: category as string,
        excludeCategories: excludeCategories ? (excludeCategories as string).split(",") : undefined,
        status: status as string,
        fromDate: fromDate ? new Date(fromDate as string) : undefined,
        toDate: toDate ? new Date(toDate as string) : undefined,
        groupBy: groupBy as any,
      });

      res.json(reports);
    } catch (error: any) {
      console.error("Error fetching income reports:", error);
      res.status(500).json({ message: "Failed to fetch income reports" });
    }
  });

  // Changelog routes (Admin only)
  app.get("/api/changelogs", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const changelogs = await storage.getAllChangelogs();
      res.json(changelogs);
    } catch (error: any) {
      console.error("Error fetching changelogs:", error);
      res.status(500).json({ message: "Failed to fetch changelogs" });
    }
  });

  app.get("/api/changelogs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const changelog = await storage.getChangelog(req.params.id);
      if (!changelog) {
        return res.status(404).json({ message: "Changelog not found" });
      }
      res.json(changelog);
    } catch (error: any) {
      console.error("Error fetching changelog:", error);
      res.status(500).json({ message: "Failed to fetch changelog" });
    }
  });

  app.post("/api/changelogs", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const validationResult = insertChangelogSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid changelog data", 
          errors: validationResult.error.errors 
        });
      }

      const changelog = await storage.createChangelog(validationResult.data);

      await logAuditAction(
        req,
        "create",
        "changelog",
        changelog.id,
        `Created changelog: ${changelog.title}`
      );

      res.status(201).json(changelog);
    } catch (error: any) {
      console.error("Error creating changelog:", error);
      res.status(500).json({ message: "Failed to create changelog" });
    }
  });

  app.patch("/api/changelogs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const changelog = await storage.updateChangelog(req.params.id, req.body);

      await logAuditAction(
        req,
        "update",
        "changelog",
        changelog.id,
        `Updated changelog: ${changelog.title}`
      );

      res.json(changelog);
    } catch (error: any) {
      console.error("Error updating changelog:", error);
      res.status(500).json({ message: "Failed to update changelog" });
    }
  });

  app.delete("/api/changelogs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      await storage.deleteChangelog(req.params.id);

      await logAuditAction(
        req,
        "delete",
        "changelog",
        req.params.id,
        "Deleted changelog"
      );

      res.json({ message: "Changelog deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting changelog:", error);
      res.status(500).json({ message: "Failed to delete changelog" });
    }
  });

  // SLA Configuration routes
  app.get("/api/sla-configs", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { isActive } = req.query;
      const configs = await storage.getSlaConfigurations({
        isActive: isActive === "true" ? true : isActive === "false" ? false : undefined
      });
      res.json(configs);
    } catch (error: any) {
      console.error("Error fetching SLA configurations:", error);
      res.status(500).json({ message: "Failed to fetch SLA configurations" });
    }
  });

  app.get("/api/sla-configs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const config = await storage.getSlaConfiguration(req.params.id);
      if (!config) {
        return res.status(404).json({ message: "SLA configuration not found" });
      }
      res.json(config);
    } catch (error: any) {
      console.error("Error fetching SLA configuration:", error);
      res.status(500).json({ message: "Failed to fetch SLA configuration" });
    }
  });

  app.get("/api/sla-configs/process/:processName", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const config = await storage.getSlaConfigurationByProcess(req.params.processName);
      if (!config) {
        return res.status(404).json({ message: "SLA configuration not found for this process" });
      }
      res.json(config);
    } catch (error: any) {
      console.error("Error fetching SLA configuration:", error);
      res.status(500).json({ message: "Failed to fetch SLA configuration" });
    }
  });

  app.post("/api/sla-configs", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const validationResult = insertSlaConfigurationSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid SLA configuration data", 
          errors: validationResult.error.errors 
        });
      }

      const config = await storage.createSlaConfiguration(validationResult.data);

      await logAuditAction(
        req,
        "create",
        "sla_configuration",
        config.id,
        `Created SLA configuration for ${config.processName}`
      );

      res.status(201).json(config);
    } catch (error: any) {
      console.error("Error creating SLA configuration:", error);
      res.status(500).json({ message: "Failed to create SLA configuration" });
    }
  });

  app.patch("/api/sla-configs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const config = await storage.updateSlaConfiguration(req.params.id, req.body);

      await logAuditAction(
        req,
        "update",
        "sla_configuration",
        config.id,
        `Updated SLA configuration for ${config.processName}`
      );

      res.json(config);
    } catch (error: any) {
      console.error("Error updating SLA configuration:", error);
      res.status(500).json({ message: "Failed to update SLA configuration" });
    }
  });

  app.delete("/api/sla-configs/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      await storage.deleteSlaConfiguration(req.params.id);

      await logAuditAction(
        req,
        "delete",
        "sla_configuration",
        req.params.id,
        "Deleted SLA configuration"
      );

      res.json({ message: "SLA configuration deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting SLA configuration:", error);
      res.status(500).json({ message: "Failed to delete SLA configuration" });
    }
  });

  // Lead Scoring Rules routes
  app.get("/api/lead-scoring-rules", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { isActive } = req.query;
      const rules = await storage.getLeadScoringRules({
        isActive: isActive === "true" ? true : isActive === "false" ? false : undefined
      });
      res.json(rules);
    } catch (error: any) {
      console.error("Error fetching lead scoring rules:", error);
      res.status(500).json({ message: "Failed to fetch lead scoring rules" });
    }
  });

  app.post("/api/lead-scoring-rules", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const validationResult = insertLeadScoringRuleSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid lead scoring rule data", 
          errors: validationResult.error.errors 
        });
      }

      const rule = await storage.createLeadScoringRule(validationResult.data);

      await logAuditAction(
        req,
        "create",
        "lead_scoring_rule",
        rule.id,
        `Created lead scoring rule: ${rule.name}`
      );

      res.status(201).json(rule);
    } catch (error: any) {
      console.error("Error creating lead scoring rule:", error);
      res.status(500).json({ message: "Failed to create lead scoring rule" });
    }
  });

  app.patch("/api/lead-scoring-rules/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const rule = await storage.updateLeadScoringRule(req.params.id, req.body);

      await logAuditAction(
        req,
        "update",
        "lead_scoring_rule",
        rule.id,
        `Updated lead scoring rule: ${rule.name}`
      );

      res.json(rule);
    } catch (error: any) {
      console.error("Error updating lead scoring rule:", error);
      res.status(500).json({ message: "Failed to update lead scoring rule" });
    }
  });

  app.delete("/api/lead-scoring-rules/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      await storage.deleteLeadScoringRule(req.params.id);

      await logAuditAction(
        req,
        "delete",
        "lead_scoring_rule",
        req.params.id,
        "Deleted lead scoring rule"
      );

      res.json({ message: "Lead scoring rule deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting lead scoring rule:", error);
      res.status(500).json({ message: "Failed to delete lead scoring rule" });
    }
  });

  // Lead Score routes
  app.get("/api/leads/:leadId/score", isAuthenticated, async (req, res) => {
    try {
      const score = await storage.getLeadScore(req.params.leadId);
      if (!score) {
        return res.status(404).json({ message: "Lead score not found" });
      }
      res.json(score);
    } catch (error: any) {
      console.error("Error fetching lead score:", error);
      res.status(500).json({ message: "Failed to fetch lead score" });
    }
  });

  app.post("/api/leads/:leadId/calculate-score", isAuthenticated, async (req, res) => {
    try {
      const score = await storage.calculateLeadScore(req.params.leadId);
      res.json(score);
    } catch (error: any) {
      console.error("Error calculating lead score:", error);
      res.status(500).json({ message: "Failed to calculate lead score" });
    }
  });

  // Contract Checklist Template routes
  app.get("/api/contract-checklist-templates", isAuthenticated, async (req, res) => {
    try {
      const { contractType, isActive } = req.query;
      const templates = await storage.getContractChecklistTemplates({
        contractType: contractType as string,
        isActive: isActive === "true" ? true : isActive === "false" ? false : undefined
      });
      res.json(templates);
    } catch (error: any) {
      console.error("Error fetching contract checklist templates:", error);
      res.status(500).json({ message: "Failed to fetch contract checklist templates" });
    }
  });

  app.get("/api/contract-checklist-templates/:id", isAuthenticated, async (req, res) => {
    try {
      const template = await storage.getContractChecklistTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ message: "Contract checklist template not found" });
      }
      res.json(template);
    } catch (error: any) {
      console.error("Error fetching contract checklist template:", error);
      res.status(500).json({ message: "Failed to fetch contract checklist template" });
    }
  });

  app.post("/api/contract-checklist-templates", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const validationResult = insertContractChecklistTemplateSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid contract checklist template data", 
          errors: validationResult.error.errors 
        });
      }

      const template = await storage.createContractChecklistTemplate(validationResult.data);

      await logAuditAction(
        req,
        "create",
        "contract_checklist_template",
        template.id,
        `Created contract checklist template: ${template.name}`
      );

      res.status(201).json(template);
    } catch (error: any) {
      console.error("Error creating contract checklist template:", error);
      res.status(500).json({ message: "Failed to create contract checklist template" });
    }
  });

  app.patch("/api/contract-checklist-templates/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const template = await storage.updateContractChecklistTemplate(req.params.id, req.body);

      await logAuditAction(
        req,
        "update",
        "contract_checklist_template",
        template.id,
        `Updated contract checklist template: ${template.name}`
      );

      res.json(template);
    } catch (error: any) {
      console.error("Error updating contract checklist template:", error);
      res.status(500).json({ message: "Failed to update contract checklist template" });
    }
  });

  app.delete("/api/contract-checklist-templates/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      await storage.deleteContractChecklistTemplate(req.params.id);

      await logAuditAction(
        req,
        "delete",
        "contract_checklist_template",
        req.params.id,
        "Deleted contract checklist template"
      );

      res.json({ message: "Contract checklist template deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting contract checklist template:", error);
      res.status(500).json({ message: "Failed to delete contract checklist template" });
    }
  });

  // Contract Checklist Template Items routes
  app.get("/api/contract-checklist-templates/:templateId/items", isAuthenticated, async (req, res) => {
    try {
      const items = await storage.getContractChecklistTemplateItems(req.params.templateId);
      res.json(items);
    } catch (error: any) {
      console.error("Error fetching contract checklist template items:", error);
      res.status(500).json({ message: "Failed to fetch contract checklist template items" });
    }
  });

  app.post("/api/contract-checklist-template-items", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const validationResult = insertContractChecklistTemplateItemSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid contract checklist template item data", 
          errors: validationResult.error.errors 
        });
      }

      const item = await storage.createContractChecklistTemplateItem(validationResult.data);
      res.status(201).json(item);
    } catch (error: any) {
      console.error("Error creating contract checklist template item:", error);
      res.status(500).json({ message: "Failed to create contract checklist template item" });
    }
  });

  app.patch("/api/contract-checklist-template-items/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const item = await storage.updateContractChecklistTemplateItem(req.params.id, req.body);
      res.json(item);
    } catch (error: any) {
      console.error("Error updating contract checklist template item:", error);
      res.status(500).json({ message: "Failed to update contract checklist template item" });
    }
  });

  app.delete("/api/contract-checklist-template-items/:id", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      await storage.deleteContractChecklistTemplateItem(req.params.id);
      res.json({ message: "Contract checklist template item deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting contract checklist template item:", error);
      res.status(500).json({ message: "Failed to delete contract checklist template item" });
    }
  });

  // Contract Checklist Items routes (actual checklist items for contracts)
  app.get("/api/contracts/:contractId/checklist", isAuthenticated, async (req, res) => {
    try {
      const items = await storage.getContractChecklistItems(req.params.contractId);
      res.json(items);
    } catch (error: any) {
      console.error("Error fetching contract checklist items:", error);
      res.status(500).json({ message: "Failed to fetch contract checklist items" });
    }
  });

  app.post("/api/contracts/:contractId/checklist/initialize", isAuthenticated, async (req, res) => {
    try {
      const { templateId } = req.body;
      if (!templateId) {
        return res.status(400).json({ message: "Template ID is required" });
      }

      const items = await storage.initializeContractChecklist(req.params.contractId, templateId);

      await logAuditAction(
        req,
        "create",
        "contract_checklist",
        req.params.contractId,
        `Initialized contract checklist with template ${templateId}`
      );

      res.status(201).json(items);
    } catch (error: any) {
      console.error("Error initializing contract checklist:", error);
      res.status(500).json({ message: "Failed to initialize contract checklist" });
    }
  });

  app.patch("/api/contract-checklist-items/:id", isAuthenticated, requireResourceOwnership('checklist-item'), async (req, res) => {
    try {
      const item = await storage.updateContractChecklistItem(req.params.id, req.body);
      res.json(item);
    } catch (error: any) {
      console.error("Error updating contract checklist item:", error);
      res.status(500).json({ message: "Failed to update contract checklist item" });
    }
  });

  app.post("/api/contract-checklist-items/:id/complete", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      const { notes } = req.body;
      const item = await storage.completeContractChecklistItem(req.params.id, userId, notes);

      await logAuditAction(
        req,
        "update",
        "contract_checklist_item",
        item.id,
        `Completed checklist item: ${item.title}`
      );

      res.json(item);
    } catch (error: any) {
      console.error("Error completing contract checklist item:", error);
      res.status(500).json({ message: "Failed to complete contract checklist item" });
    }
  });

  // Rental Health Score routes
  app.get("/api/contracts/:contractId/health-score", isAuthenticated, async (req, res) => {
    try {
      const score = await storage.getRentalHealthScore(req.params.contractId);
      if (!score) {
        return res.status(404).json({ message: "Rental health score not found" });
      }
      res.json(score);
    } catch (error: any) {
      console.error("Error fetching rental health score:", error);
      res.status(500).json({ message: "Failed to fetch rental health score" });
    }
  });

  app.post("/api/contracts/:contractId/calculate-health-score", isAuthenticated, async (req, res) => {
    try {
      const score = await storage.calculateRentalHealthScore(req.params.contractId);
      res.json(score);
    } catch (error: any) {
      console.error("Error calculating rental health score:", error);
      res.status(500).json({ message: "Failed to calculate rental health score" });
    }
  });

  app.get("/api/rental-health-scores/status/:status", isAuthenticated, async (req, res) => {
    try {
      const scores = await storage.getRentalHealthScoresByStatus(req.params.status);
      res.json(scores);
    } catch (error: any) {
      console.error("Error fetching rental health scores by status:", error);
      res.status(500).json({ message: "Failed to fetch rental health scores" });
    }
  });

  // Workflow Event routes
  app.get("/api/workflow-events", isAuthenticated, requireFullAdmin, async (req, res) => {
    try {
      const { eventType, entityType, entityId } = req.query;
      const events = await storage.getWorkflowEvents({
        eventType: eventType as string,
        entityType: entityType as string,
        entityId: entityId as string
      });
      res.json(events);
    } catch (error: any) {
      console.error("Error fetching workflow events:", error);
      res.status(500).json({ message: "Failed to fetch workflow events" });
    }
  });

  app.post("/api/workflow-events", isAuthenticated, async (req, res) => {
    try {
      const validationResult = insertWorkflowEventSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid workflow event data", 
          errors: validationResult.error.errors 
        });
      }

      const event = await storage.createWorkflowEvent(validationResult.data);
      res.status(201).json(event);
    } catch (error: any) {
      console.error("Error creating workflow event:", error);
      res.status(500).json({ message: "Failed to create workflow event" });
    }
  });

  // System Alert routes
  app.get("/api/alerts", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { status, priority, alertType } = req.query;
      
      const alerts = await storage.getSystemAlerts({
        userId: userId || undefined,
        status: status as string,
        priority: priority as string,
        alertType: alertType as string
      });
      
      res.json(alerts);
    } catch (error: any) {
      console.error("Error fetching alerts:", error);
      res.status(500).json({ message: "Failed to fetch alerts" });
    }
  });

  app.get("/api/alerts/pending", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      const alerts = await storage.getUserPendingAlerts(userId);
      res.json(alerts);
    } catch (error: any) {
      console.error("Error fetching pending alerts:", error);
      res.status(500).json({ message: "Failed to fetch pending alerts" });
    }
  });

  app.post("/api/alerts", isAuthenticated, async (req, res) => {
    try {
      const validationResult = insertSystemAlertSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Invalid alert data", 
          errors: validationResult.error.errors 
        });
      }

      const alert = await storage.createSystemAlert(validationResult.data);
      res.status(201).json(alert);
    } catch (error: any) {
      console.error("Error creating alert:", error);
      res.status(500).json({ message: "Failed to create alert" });
    }
  });

  app.patch("/api/alerts/:id/acknowledge", isAuthenticated, requireResourceOwnership('alert', 'userId'), async (req, res) => {
    try {
      const alert = await storage.acknowledgeSystemAlert(req.params.id);
      res.json(alert);
    } catch (error: any) {
      console.error("Error acknowledging alert:", error);
      res.status(500).json({ message: "Failed to acknowledge alert" });
    }
  });

  app.patch("/api/alerts/:id/resolve", isAuthenticated, requireResourceOwnership('alert', 'userId'), async (req, res) => {
    try {
      const alert = await storage.resolveSystemAlert(req.params.id);
      res.json(alert);
    } catch (error: any) {
      console.error("Error resolving alert:", error);
      res.status(500).json({ message: "Failed to resolve alert" });
    }
  });

  app.patch("/api/alerts/:id/dismiss", isAuthenticated, requireResourceOwnership('alert', 'userId'), async (req, res) => {
    try {
      const alert = await storage.dismissSystemAlert(req.params.id);
      res.json(alert);
    } catch (error: any) {
      console.error("Error dismissing alert:", error);
      res.status(500).json({ message: "Failed to dismiss alert" });
    }
  });

  app.delete("/api/alerts/:id", isAuthenticated, requireResourceOwnership('alert', 'userId'), async (req, res) => {
    try {
      await storage.deleteSystemAlert(req.params.id);
      res.json({ message: "Alert deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting alert:", error);
      res.status(500).json({ message: "Failed to delete alert" });
    }
  });

  // Admin Rental Contracts with relations
  app.get("/api/admin/rental-contracts", isAuthenticated, requireRole(["master", "admin", "admin_jr"]), async (req, res) => {
    try {
      const { status } = req.query;
      const filters: any = {};
      if (status && status !== "all") filters.status = status;

      const contracts = await storage.getRentalContracts(filters);
      
      // Fetch related data for each contract
      const enrichedContracts = await Promise.all(
        contracts.map(async (contract) => {
          const [property, tenant, owner, seller] = await Promise.all([
            storage.getProperty(contract.propertyId),
            storage.getUser(contract.tenantId),
            storage.getUser(contract.ownerId),
            contract.sellerId ? storage.getUser(contract.sellerId) : null,
          ]);

          return {
            ...contract,
            property: property ? { title: property.title, address: property.address } : null,
            tenant: tenant ? { fullName: tenant.fullName, email: tenant.email } : null,
            owner: owner ? { fullName: owner.fullName, email: owner.email } : null,
            seller: seller ? { fullName: seller.fullName, email: seller.email } : null,
          };
        })
      );

      res.json(enrichedContracts);
    } catch (error: any) {
      console.error("Error fetching admin rental contracts:", error);
      res.status(500).json({ message: "Failed to fetch rental contracts" });
    }
  });

  // Admin Integrations Status endpoint
  app.get("/api/admin/integrations/status", isAuthenticated, requireRole(["master", "admin"]), async (req, res) => {
    try {
      const integrations = [];

      // OpenAI
      const openAIConfigured = !!process.env.OPENAI_API_KEY;
      integrations.push({
        id: "openai",
        name: "OpenAI (MARCO)",
        status: openAIConfigured ? "connected" : "disconnected",
        description: "Virtual assistant powered by GPT-5",
        configFields: ["OPENAI_API_KEY"]
      });

      // Gemini
      const geminiConfigured = !!process.env.GEMINI_API_KEY;
      integrations.push({
        id: "gemini",
        name: "Google Gemini",
        status: geminiConfigured ? "connected" : "disconnected",
        description: "AI-powered features",
        configFields: ["GEMINI_API_KEY"]
      });

      // Gmail (connector-based) - Primary email service
      let gmailStatus = "disconnected";
      let gmailConnectionUrl = "";
      try {
        const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;
        const xReplitToken = process.env.REPL_IDENTITY
          ? 'repl ' + process.env.REPL_IDENTITY
          : process.env.WEB_REPL_RENEWAL
          ? 'depl ' + process.env.WEB_REPL_RENEWAL
          : null;
        
        if (xReplitToken && hostname) {
          const connectorData = await fetch(
            'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=google-mail',
            {
              headers: {
                'Accept': 'application/json',
                'X_REPLIT_TOKEN': xReplitToken
              }
            }
          ).then(res => res.json());
          
          const accessToken = connectorData.items?.[0]?.settings?.access_token || connectorData.items?.[0]?.settings?.oauth?.credentials?.access_token;
          if (accessToken) {
            gmailStatus = "connected";
          }
          gmailConnectionUrl = connectorData.items?.[0]?.connector_url || "";
        }
      } catch (error) {
        console.error("Error checking Gmail status:", error);
      }

      integrations.push({
        id: "gmail",
        name: "Gmail API",
        status: gmailStatus,
        description: "Primary email delivery service for transactional emails",
        configFields: ["Replit Connector"],
        connectionUrl: gmailConnectionUrl,
        connectorId: "connection:conn_google-mail_01K6X65JFWT1MNBAXJ58YB90E7"
      });

      // Google Calendar (connector-based)
      let calendarStatus = "disconnected";
      let calendarConnectionUrl = "";
      try {
        const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;
        const xReplitToken = process.env.REPL_IDENTITY
          ? 'repl ' + process.env.REPL_IDENTITY
          : process.env.WEB_REPL_RENEWAL
          ? 'depl ' + process.env.WEB_REPL_RENEWAL
          : null;
        
        if (xReplitToken && hostname) {
          const connectorData = await fetch(
            'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=google-calendar',
            {
              headers: {
                'Accept': 'application/json',
                'X_REPLIT_TOKEN': xReplitToken
              }
            }
          ).then(res => res.json());
          
          const accessToken = connectorData.items?.[0]?.settings?.access_token || connectorData.items?.[0]?.settings?.oauth?.credentials?.access_token;
          if (accessToken) {
            calendarStatus = "connected";
          }
          calendarConnectionUrl = connectorData.items?.[0]?.connector_url || "";
        }
      } catch (error) {
        console.error("Error checking Google Calendar status:", error);
      }

      integrations.push({
        id: "google_calendar",
        name: "Google Calendar",
        status: calendarStatus,
        description: "Event scheduling and Google Meet integration for appointments",
        configFields: ["Replit Connector"],
        connectionUrl: calendarConnectionUrl,
        connectorId: "connection:conn_google-calendar_01K6PJRVNHMM6V7V8F6WMG47F5"
      });

      // PostgreSQL Database
      const databaseConfigured = !!process.env.DATABASE_URL;
      integrations.push({
        id: "database",
        name: "PostgreSQL Database",
        status: databaseConfigured ? "connected" : "disconnected",
        description: "Neon serverless database for data persistence",
        configFields: ["DATABASE_URL"],
        isBuiltIn: true
      });

      res.json({ integrations });
    } catch (error: any) {
      console.error("Error fetching integrations status:", error);
      res.status(500).json({ message: "Failed to fetch integrations status" });
    }
  });

  // ============================================================================
  // NEW BUSINESS MODEL IMPROVEMENTS & AI FEATURES
  // ============================================================================

  // Commission Advance endpoints
  app.get("/api/seller/commission-advances", isAuthenticated, requireRole(["seller", "admin", "master"]), async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      const advances = await storage.getCommissionAdvances({ sellerId: userId });
      res.json(advances);
    } catch (error: any) {
      console.error("Error fetching commission advances:", error);
      res.status(500).json({ message: "Failed to fetch commission advances" });
    }
  });

  app.post("/api/seller/commission-advances", isAuthenticated, requireRole(["seller"]), async (req, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const advance = await storage.createCommissionAdvance({
        sellerId: userId,
        amount: req.body.amount,
        reason: sanitizeText(req.body.reason),
        status: "pending"
      });
      res.json(advance);
    } catch (error: any) {
      console.error("Error creating commission advance:", error);
      res.status(500).json({ message: "Failed to create commission advance" });
    }
  });

  app.patch("/api/admin/commission-advances/:id/status", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      const advance = await storage.updateCommissionAdvanceStatus(
        req.params.id,
        req.body.status,
        userId,
        req.body.notes
      );
      res.json(advance);
    } catch (error: any) {
      console.error("Error updating commission advance:", error);
      res.status(500).json({ message: "Failed to update commission advance" });
    }
  });

  // Service Favorites endpoints
  app.post("/api/service-favorites", isAuthenticated, async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      const favorite = await storage.addServiceFavorite({
        userId,
        providerId: req.body.providerId
      });
      res.json(favorite);
    } catch (error: any) {
      console.error("Error adding service favorite:", error);
      res.status(500).json({ message: "Failed to add favorite" });
    }
  });

  app.delete("/api/service-favorites/:providerId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      await storage.removeServiceFavorite(userId, req.params.providerId);
      res.json({ message: "Favorite removed" });
    } catch (error: any) {
      console.error("Error removing service favorite:", error);
      res.status(500).json({ message: "Failed to remove favorite" });
    }
  });

  app.get("/api/service-favorites", isAuthenticated, async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      const favorites = await storage.getUserServiceFavorites(userId);
      res.json(favorites);
    } catch (error: any) {
      console.error("Error fetching service favorites:", error);
      res.status(500).json({ message: "Failed to fetch favorites" });
    }
  });

  // Predictive Analytics endpoints (OpenAI powered)
  app.post("/api/admin/predictive-analytics/rental-probability", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const property = await storage.getProperty(req.body.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      const analysis = await openAIService.analyzeRentalProbability(property);
      
      const analytic = await storage.createPredictiveAnalytic({
        propertyId: property.id,
        type: "rental_probability",
        prediction: analysis.prediction,
        confidence: analysis.confidence.toString(),
        recommendedAction: analysis.recommendedAction,
        factors: analysis.factors,
        validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
      });
      
      res.json(analytic);
    } catch (error: any) {
      console.error("Error analyzing rental probability:", error);
      res.status(500).json({ message: "Failed to analyze rental probability" });
    }
  });

  app.post("/api/admin/predictive-analytics/price-recommendation", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const property = await storage.getProperty(req.body.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      const analysis = await openAIService.analyzePriceRecommendation(property);
      
      const analytic = await storage.createPredictiveAnalytic({
        propertyId: property.id,
        type: "price_recommendation",
        prediction: analysis.prediction,
        confidence: analysis.confidence.toString(),
        recommendedAction: analysis.recommendedAction,
        factors: analysis.factors,
        validUntil: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      });
      
      res.json(analytic);
    } catch (error: any) {
      console.error("Error analyzing price recommendation:", error);
      res.status(500).json({ message: "Failed to analyze price recommendation" });
    }
  });

  app.get("/api/admin/predictive-analytics", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const analytics = await storage.getPredictiveAnalytics({
        propertyId: req.query.propertyId as string,
        type: req.query.type as string
      });
      res.json(analytics);
    } catch (error: any) {
      console.error("Error fetching predictive analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  // Legal Documents endpoints (OpenAI powered)
  app.post("/api/admin/legal-documents/generate-contract", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      const property = await storage.getProperty(req.body.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      const result = await openAIService.generateRentalContract(req.body.parties, {
        address: property.address,
        monthlyRent: req.body.monthlyRent,
        deposit: req.body.deposit
      });
      
      const document = await storage.createLegalDocument({
        type: "rental_contract",
        propertyId: property.id,
        parties: req.body.parties,
        content: result.content,
        metadata: result.metadata,
        generatedBy: userId,
        status: "draft"
      });
      
      res.json(document);
    } catch (error: any) {
      console.error("Error generating legal document:", error);
      res.status(500).json({ message: "Failed to generate legal document" });
    }
  });

  app.get("/api/legal-documents", isAuthenticated, async (req, res) => {
    try {
      const documents = await storage.getLegalDocuments({
        propertyId: req.query.propertyId as string,
        type: req.query.type as string,
        status: req.query.status as string
      });
      res.json(documents);
    } catch (error: any) {
      console.error("Error fetching legal documents:", error);
      res.status(500).json({ message: "Failed to fetch legal documents" });
    }
  });

  app.patch("/api/admin/legal-documents/:id/status", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const document = await storage.updateLegalDocumentStatus(req.params.id, req.body.status);
      res.json(document);
    } catch (error: any) {
      console.error("Error updating legal document:", error);
      res.status(500).json({ message: "Failed to update legal document" });
    }
  });

  // Tenant Screening endpoints (OpenAI powered)
  app.post("/api/admin/tenant-screening", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      
      const screening = await openAIService.screenTenant(req.body.applicationData);
      
      const result = await storage.createTenantScreening({
        applicationId: req.body.applicationId,
        applicantId: req.body.applicantId,
        propertyId: req.body.propertyId,
        status: "completed",
        riskScore: screening.riskScore.toString(),
        riskLevel: screening.riskLevel,
        aiAnalysis: screening.aiAnalysis,
        fraudDetection: screening.fraudDetection,
        incomeVerification: screening.incomeVerification,
        creditAnalysis: screening.creditAnalysis,
        rentalHistory: screening.rentalHistory,
        recommendations: screening.recommendations,
        flags: screening.flags,
        completedAt: new Date()
      });
      
      res.json(result);
    } catch (error: any) {
      console.error("Error screening tenant:", error);
      res.status(500).json({ message: "Failed to screen tenant" });
    }
  });

  app.get("/api/admin/tenant-screenings", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const screenings = await storage.getTenantScreenings({
        applicationId: req.query.applicationId as string,
        applicantId: req.query.applicantId as string,
        propertyId: req.query.propertyId as string,
        status: req.query.status as string
      });
      res.json(screenings);
    } catch (error: any) {
      console.error("Error fetching tenant screenings:", error);
      res.status(500).json({ message: "Failed to fetch tenant screenings" });
    }
  });

  // Marketing Campaigns endpoints
  app.get("/api/admin/marketing-campaigns", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const campaigns = await storage.getMarketingCampaigns({
        status: req.query.status as string,
        type: req.query.type as string
      });
      res.json(campaigns);
    } catch (error: any) {
      console.error("Error fetching marketing campaigns:", error);
      res.status(500).json({ message: "Failed to fetch campaigns" });
    }
  });

  app.post("/api/admin/marketing-campaigns", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      const campaign = await storage.createMarketingCampaign({
        name: sanitizeText(req.body.name),
        type: req.body.type,
        targetAudience: req.body.targetAudience,
        content: req.body.content,
        schedule: req.body.schedule,
        createdBy: userId
      });
      res.json(campaign);
    } catch (error: any) {
      console.error("Error creating marketing campaign:", error);
      res.status(500).json({ message: "Failed to create campaign" });
    }
  });

  app.patch("/api/admin/marketing-campaigns/:id/status", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const campaign = await storage.updateMarketingCampaignStatus(req.params.id, req.body.status);
      res.json(campaign);
    } catch (error: any) {
      console.error("Error updating campaign status:", error);
      res.status(500).json({ message: "Failed to update campaign" });
    }
  });

  app.get("/api/admin/marketing-campaigns/stats", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const campaigns = await storage.getMarketingCampaigns({});
      const stats = {
        total: campaigns.length,
        scheduled: campaigns.filter(c => c.status === "scheduled").length,
        sent: campaigns.filter(c => c.status === "sent").length,
        avgOpenRate: campaigns.length > 0 
          ? campaigns.reduce((sum, c) => sum + (c.openRate || 0), 0) / campaigns.length
          : 0
      };
      res.json(stats);
    } catch (error: any) {
      console.error("Error fetching campaign stats:", error);
      res.status(500).json({ message: "Failed to fetch campaign stats" });
    }
  });

  // Maintenance Schedules endpoints
  app.get("/api/owner/maintenance-schedules", isAuthenticated, requireRole(["owner", "admin", "master"]), async (req, res) => {
    try {
      const schedules = await storage.getMaintenanceSchedules({
        propertyId: req.query.propertyId as string,
        active: req.query.active === "true"
      });
      res.json(schedules);
    } catch (error: any) {
      console.error("Error fetching maintenance schedules:", error);
      res.status(500).json({ message: "Failed to fetch schedules" });
    }
  });

  app.post("/api/owner/maintenance-schedules", isAuthenticated, requireRole(["owner", "admin", "master"]), async (req, res) => {
    try {
      const schedule = await storage.createMaintenanceSchedule({
        propertyId: req.body.propertyId,
        title: sanitizeText(req.body.title),
        description: sanitizeText(req.body.description),
        frequency: req.body.frequency,
        nextDue: new Date(req.body.nextDue),
        estimatedCost: req.body.estimatedCost,
        assignedTo: req.body.assignedTo
      });
      res.json(schedule);
    } catch (error: any) {
      console.error("Error creating maintenance schedule:", error);
      res.status(500).json({ message: "Failed to create schedule" });
    }
  });

  app.patch("/api/owner/maintenance-schedules/:id", isAuthenticated, requireRole(["owner", "admin", "master"]), async (req, res) => {
    try {
      const schedule = await storage.updateMaintenanceSchedule(req.params.id, req.body);
      res.json(schedule);
    } catch (error: any) {
      console.error("Error updating maintenance schedule:", error);
      res.status(500).json({ message: "Failed to update schedule" });
    }
  });

  // ========================================
  // HOA (Homeowners Association) Module Routes
  // ========================================

  // Condominium Units
  app.get("/api/hoa/condominiums/:condominiumId/units", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const units = await storage.getCondominiumUnitsByCondominium(req.params.condominiumId);
      res.json(units);
    } catch (error: any) {
      console.error("Error fetching condominium units:", error);
      res.status(500).json({ message: "Failed to fetch units" });
    }
  });

  app.get("/api/hoa/my-units", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const units = await storage.getCondominiumUnitsByOwner(userId);
      res.json(units);
    } catch (error: any) {
      console.error("Error fetching my units:", error);
      res.status(500).json({ message: "Failed to fetch units" });
    }
  });

  app.get("/api/hoa/units/:id", isAuthenticated, async (req, res) => {
    try {
      const unit = await storage.getCondominiumUnit(req.params.id);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      res.json(unit);
    } catch (error: any) {
      console.error("Error fetching unit:", error);
      res.status(500).json({ message: "Failed to fetch unit" });
    }
  });

  app.post("/api/hoa/units", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const validationResult = insertCondominiumUnitSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const unit = await storage.createCondominiumUnit(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "condominium_unit",
        unit.id,
        `Created unit ${unit.unitNumber} in condominium ${unit.condominiumId}`
      );

      res.status(201).json(unit);
    } catch (error: any) {
      console.error("Error creating unit:", error);
      res.status(500).json({ message: "Failed to create unit" });
    }
  });

  app.patch("/api/hoa/units/:id", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const validationResult = insertCondominiumUnitSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const existingUnit = await storage.getCondominiumUnit(req.params.id);
      if (!existingUnit) {
        return res.status(404).json({ message: "Unit not found" });
      }

      const unit = await storage.updateCondominiumUnit(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "condominium_unit",
        req.params.id,
        `Updated unit ${unit.unitNumber}`
      );

      res.json(unit);
    } catch (error: any) {
      console.error("Error updating unit:", error);
      res.status(500).json({ message: "Failed to update unit" });
    }
  });

  app.delete("/api/hoa/units/:id", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      await storage.deleteCondominiumUnit(req.params.id);

      await createAuditLog(
        req,
        "delete",
        "condominium_unit",
        req.params.id,
        `Deleted unit`
      );

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting unit:", error);
      res.status(500).json({ message: "Failed to delete unit" });
    }
  });

  // Condominium Fees
  app.get("/api/hoa/units/:unitId/fees", isAuthenticated, async (req, res) => {
    try {
      const fees = await storage.getCondominiumFeesByUnit(req.params.unitId);
      res.json(fees);
    } catch (error: any) {
      console.error("Error fetching fees:", error);
      res.status(500).json({ message: "Failed to fetch fees" });
    }
  });

  app.get("/api/hoa/fees/status/:status", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const fees = await storage.getCondominiumFeesByStatus(req.params.status);
      res.json(fees);
    } catch (error: any) {
      console.error("Error fetching fees:", error);
      res.status(500).json({ message: "Failed to fetch fees" });
    }
  });

  app.post("/api/hoa/fees", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const userId = req.session.adminUser?.id || req.user?.claims?.sub;
      const validationResult = insertCondominiumFeeSchema.safeParse({
        ...req.body,
        createdById: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const fee = await storage.createCondominiumFee(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "condominium_fee",
        fee.id,
        `Created fee for unit ${fee.condominiumUnitId} - ${fee.month}/${fee.year}`
      );

      res.status(201).json(fee);
    } catch (error: any) {
      console.error("Error creating fee:", error);
      res.status(500).json({ message: "Failed to create fee" });
    }
  });

  app.patch("/api/hoa/fees/:id", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const validationResult = insertCondominiumFeeSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const existingFee = await storage.getCondominiumFee(req.params.id);
      if (!existingFee) {
        return res.status(404).json({ message: "Fee not found" });
      }

      const fee = await storage.updateCondominiumFee(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "condominium_fee",
        req.params.id,
        `Updated fee`
      );

      res.json(fee);
    } catch (error: any) {
      console.error("Error updating fee:", error);
      res.status(500).json({ message: "Failed to update fee" });
    }
  });

  app.patch("/api/hoa/fees/:id/status", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const { status } = req.body;
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      const fee = await storage.updateCondominiumFeeStatus(req.params.id, status);

      await createAuditLog(
        req,
        "update",
        "condominium_fee",
        req.params.id,
        `Updated fee status to ${status}`
      );

      res.json(fee);
    } catch (error: any) {
      console.error("Error updating fee status:", error);
      res.status(500).json({ message: "Failed to update fee status" });
    }
  });

  // Condominium Fee Payments
  app.get("/api/hoa/fees/:feeId/payments", isAuthenticated, async (req, res) => {
    try {
      const payments = await storage.getCondominiumFeePaymentsByFee(req.params.feeId);
      res.json(payments);
    } catch (error: any) {
      console.error("Error fetching payments:", error);
      res.status(500).json({ message: "Failed to fetch payments" });
    }
  });

  app.post("/api/hoa/fees/:feeId/payments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = insertCondominiumFeePaymentSchema.safeParse({
        ...req.body,
        condominiumFeeId: req.params.feeId,
        registeredById: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const payment = await storage.createCondominiumFeePayment(validationResult.data);

      // Update fee status to pagado
      await storage.updateCondominiumFeeStatus(req.params.feeId, "pagado");

      await createAuditLog(
        req,
        "create",
        "condominium_fee_payment",
        payment.id,
        `Registered payment for fee ${req.params.feeId}`
      );

      res.status(201).json(payment);
    } catch (error: any) {
      console.error("Error creating payment:", error);
      res.status(500).json({ message: "Failed to create payment" });
    }
  });

  // Condominium Issues
  app.get("/api/hoa/condominiums/:condominiumId/issues", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const issues = await storage.getCondominiumIssuesByCondominium(req.params.condominiumId);
      res.json(issues);
    } catch (error: any) {
      console.error("Error fetching issues:", error);
      res.status(500).json({ message: "Failed to fetch issues" });
    }
  });

  app.get("/api/hoa/my-issues", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const issues = await storage.getCondominiumIssuesByReporter(userId);
      res.json(issues);
    } catch (error: any) {
      console.error("Error fetching my issues:", error);
      res.status(500).json({ message: "Failed to fetch issues" });
    }
  });

  app.get("/api/hoa/issues/status/:status", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const issues = await storage.getCondominiumIssuesByStatus(req.params.status);
      res.json(issues);
    } catch (error: any) {
      console.error("Error fetching issues:", error);
      res.status(500).json({ message: "Failed to fetch issues" });
    }
  });

  app.get("/api/hoa/issues/:id", isAuthenticated, async (req, res) => {
    try {
      const issue = await storage.getCondominiumIssue(req.params.id);
      if (!issue) {
        return res.status(404).json({ message: "Issue not found" });
      }
      res.json(issue);
    } catch (error: any) {
      console.error("Error fetching issue:", error);
      res.status(500).json({ message: "Failed to fetch issue" });
    }
  });

  app.post("/api/hoa/issues", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = insertCondominiumIssueSchema.safeParse({
        ...req.body,
        reportedById: userId,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const issue = await storage.createCondominiumIssue(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "condominium_issue",
        issue.id,
        `Reported issue: ${issue.title}`
      );

      res.status(201).json(issue);
    } catch (error: any) {
      console.error("Error creating issue:", error);
      res.status(500).json({ message: "Failed to create issue" });
    }
  });

  app.patch("/api/hoa/issues/:id", isAuthenticated, async (req, res) => {
    try {
      const validationResult = insertCondominiumIssueSchema.partial().safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const existingIssue = await storage.getCondominiumIssue(req.params.id);
      if (!existingIssue) {
        return res.status(404).json({ message: "Issue not found" });
      }

      const issue = await storage.updateCondominiumIssue(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "condominium_issue",
        req.params.id,
        `Updated issue: ${issue.title}`
      );

      res.json(issue);
    } catch (error: any) {
      console.error("Error updating issue:", error);
      res.status(500).json({ message: "Failed to update issue" });
    }
  });

  app.patch("/api/hoa/issues/:id/status", isAuthenticated, requireRole(["admin", "master", "management"]), async (req, res) => {
    try {
      const { status } = req.body;
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      const existingIssue = await storage.getCondominiumIssue(req.params.id);
      if (!existingIssue) {
        return res.status(404).json({ message: "Issue not found" });
      }

      const issue = await storage.updateCondominiumIssueStatus(req.params.id, status);

      await createAuditLog(
        req,
        "update",
        "condominium_issue",
        req.params.id,
        `Updated issue status to ${status}`
      );

      res.json(issue);
    } catch (error: any) {
      console.error("Error updating issue status:", error);
      res.status(500).json({ message: "Failed to update issue status" });
    }
  });

  app.post("/api/hoa/issues/:id/resolve", isAuthenticated, requireRole(["admin", "master", "management"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { resolution } = req.body;

      if (!resolution) {
        return res.status(400).json({ message: "Resolution is required" });
      }

      const existingIssue = await storage.getCondominiumIssue(req.params.id);
      if (!existingIssue) {
        return res.status(404).json({ message: "Issue not found" });
      }

      const issue = await storage.resolveCondominiumIssue(req.params.id, userId, resolution);

      await createAuditLog(
        req,
        "update",
        "condominium_issue",
        req.params.id,
        `Resolved issue: ${issue.title}`
      );

      res.json(issue);
    } catch (error: any) {
      console.error("Error resolving issue:", error);
      res.status(500).json({ message: "Failed to resolve issue" });
    }
  });

  // ========================================
  // HOA Manager System Routes
  // ========================================

  // HOA Manager Assignment Routes

  // Request to become HOA manager for a condominium
  app.post("/api/hoa-manager/assignments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = insertHoaManagerAssignmentSchema.safeParse({
        ...req.body,
        managerId: userId,
        status: "pending",
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      // Check if there's already a pending or approved assignment
      const existingAssignments = await storage.getHoaManagerAssignmentsByCondominium(req.body.condominiumId);
      const hasPendingOrApproved = existingAssignments.some(a => a.managerId === userId && (a.status === 'pending' || a.status === 'approved'));
      
      if (hasPendingOrApproved) {
        return res.status(400).json({ message: "You already have a pending or approved assignment for this condominium" });
      }

      const assignment = await storage.createHoaManagerAssignment(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "hoa_manager_assignment",
        assignment.id,
        `Requested HOA manager assignment for condominium ${assignment.condominiumId}`
      );

      res.status(201).json(assignment);
    } catch (error: any) {
      console.error("Error creating HOA manager assignment:", error);
      res.status(500).json({ message: "Failed to create assignment" });
    }
  });

  // Get all assignments (admin only)
  app.get("/api/hoa-manager/assignments", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const status = req.query.status as string | undefined;
      const assignments = status 
        ? await storage.getHoaManagerAssignmentsByStatus(status)
        : await storage.getHoaManagerAssignmentsByStatus("pending");
      res.json(assignments);
    } catch (error: any) {
      console.error("Error fetching assignments:", error);
      res.status(500).json({ message: "Failed to fetch assignments" });
    }
  });

  // Get all assignments with user and condominium details (admin only)
  app.get("/api/hoa-manager/all-assignments", isAuthenticated, requireRole(["admin", "master"]), async (req, res) => {
    try {
      const allAssignments = await storage.getHoaManagerAssignmentsByStatus("pending");
      
      // Enrich with user and condominium details
      const enriched = await Promise.all(
        allAssignments.map(async (assignment) => {
          const manager = await storage.getUser(assignment.managerId);
          const condominium = await storage.getCondominium(assignment.condominiumId);
          
          return {
            ...assignment,
            manager: manager ? {
              id: manager.id,
              firstName: manager.firstName,
              lastName: manager.lastName,
              email: manager.email,
            } : undefined,
            condominium: condominium ? {
              id: condominium.id,
              name: condominium.name,
            } : undefined,
          };
        })
      );
      
      res.json(enriched);
    } catch (error: any) {
      console.error("Error fetching all assignments:", error);
      res.status(500).json({ message: "Failed to fetch all assignments" });
    }
  });

  // Get my assignments (HOA manager)
  app.get("/api/hoa-manager/my-assignments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const assignments = await storage.getHoaManagerAssignmentsByManager(userId);
      res.json(assignments);
    } catch (error: any) {
      console.error("Error fetching my assignments:", error);
      res.status(500).json({ message: "Failed to fetch assignments" });
    }
  });

  // Get assignment by condominium
  app.get("/api/hoa-manager/assignments/condominium/:condominiumId", isAuthenticated, async (req, res) => {
    try {
      const assignments = await storage.getHoaManagerAssignmentsByCondominium(req.params.condominiumId);
      res.json(assignments);
    } catch (error: any) {
      console.error("Error fetching assignments:", error);
      res.status(500).json({ message: "Failed to fetch assignments" });
    }
  });

  // Approve HOA manager assignment (admin only)
  app.post("/api/hoa-manager/assignments/:id/approve", isAuthenticated, requireRole(["admin", "master"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Approval reason is required" });
      }

      const assignment = await storage.approveHoaManagerAssignment(req.params.id, userId, reason);

      // Get condominium details for notification
      const condominium = await storage.getCondominium(assignment.condominiumId);

      // Notify the manager about approval
      await storage.createNotification({
        userId: assignment.managerId,
        type: "role_approved",
        title: "Solicitud de HOA Manager Aprobada",
        message: `Tu solicitud para administrar ${condominium?.name || 'el condominio'} ha sido aprobada. Motivo: ${reason}`,
        link: "/perfil"
      });

      await createAuditLog(
        req,
        "approve",
        "hoa_manager_assignment",
        req.params.id,
        `Approved HOA manager assignment for condominium ${assignment.condominiumId}: ${reason}`
      );

      res.json(assignment);
    } catch (error: any) {
      console.error("Error approving assignment:", error);
      res.status(500).json({ message: "Failed to approve assignment" });
    }
  });

  // Reject HOA manager assignment (admin only)
  app.post("/api/hoa-manager/assignments/:id/reject", isAuthenticated, requireRole(["admin", "master"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }

      const assignment = await storage.rejectHoaManagerAssignment(req.params.id, userId, reason);

      // Get condominium details for notification
      const condominium = await storage.getCondominium(assignment.condominiumId);

      // Notify the manager about rejection
      await storage.createNotification({
        userId: assignment.managerId,
        type: "role_rejected",
        title: "Solicitud de HOA Manager Rechazada",
        message: `Tu solicitud para administrar ${condominium?.name || 'el condominio'} ha sido rechazada. Motivo: ${reason}`,
        link: "/perfil"
      });

      await createAuditLog(
        req,
        "reject",
        "hoa_manager_assignment",
        req.params.id,
        `Rejected HOA manager assignment: ${reason}`
      );

      res.json(assignment);
    } catch (error: any) {
      console.error("Error rejecting assignment:", error);
      res.status(500).json({ message: "Failed to reject assignment" });
    }
  });

  // Suspend HOA manager assignment (admin only)
  app.post("/api/hoa-manager/assignments/:id/suspend", isAuthenticated, requireRole(["admin", "master"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Suspension reason is required" });
      }

      const assignment = await storage.suspendHoaManagerAssignment(req.params.id, userId, reason);

      await createAuditLog(
        req,
        "update",
        "hoa_manager_assignment",
        req.params.id,
        `Suspended HOA manager assignment: ${reason}`
      );

      res.json(assignment);
    } catch (error: any) {
      console.error("Error suspending assignment:", error);
      res.status(500).json({ message: "Failed to suspend assignment" });
    }
  });

  // HOA Announcement Routes

  // Get announcements for a condominium (only for owners/managers of that condominium or admins)
  app.get("/api/hoa-manager/condominiums/:condominiumId/announcements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const condominiumId = req.params.condominiumId;

      // Check if user is admin, or owner/manager of this condominium
      const user = await storage.getUser(userId);
      const isAdmin = user?.role === 'admin' || user?.role === 'master';
      
      if (!isAdmin) {
        // Check if user is an owner of a unit in this condominium or the HOA manager
        const units = await storage.getCondominiumUnitsByOwner(userId);
        const ownsUnitInCondo = units.some(u => u.condominiumId === condominiumId);
        const assignment = await storage.getApprovedHoaManagerByCondominium(condominiumId);
        const isHoaManager = assignment?.managerId === userId;

        if (!ownsUnitInCondo && !isHoaManager) {
          return res.status(403).json({ message: "Not authorized to view announcements for this condominium" });
        }
      }

      const announcements = await storage.getHoaAnnouncementsByCondominium(condominiumId);
      res.json(announcements);
    } catch (error: any) {
      console.error("Error fetching announcements:", error);
      res.status(500).json({ message: "Failed to fetch announcements" });
    }
  });

  // Get my announcements (HOA manager)
  app.get("/api/hoa-manager/my-announcements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const announcements = await storage.getHoaAnnouncementsByManager(userId);
      res.json(announcements);
    } catch (error: any) {
      console.error("Error fetching my announcements:", error);
      res.status(500).json({ message: "Failed to fetch announcements" });
    }
  });

  // Get unread announcements for owner
  app.get("/api/hoa-manager/my-unread-announcements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const announcements = await storage.getUnreadHoaAnnouncementsForOwner(userId);
      res.json(announcements);
    } catch (error: any) {
      console.error("Error fetching unread announcements:", error);
      res.status(500).json({ message: "Failed to fetch announcements" });
    }
  });

  // Create announcement (HOA manager only - must be approved for condominium)
  app.post("/api/hoa-manager/announcements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = insertHoaAnnouncementSchema.safeParse({
        ...req.body,
        managerId: userId,
        isActive: false,
      });

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      // Check if user is approved HOA manager for this condominium
      const approvedManager = await storage.getApprovedHoaManagerByCondominium(req.body.condominiumId);
      if (!approvedManager || approvedManager.managerId !== userId) {
        return res.status(403).json({ message: "You are not an approved HOA manager for this condominium" });
      }

      // Double-check assignment is not suspended
      if (approvedManager.status === 'suspended') {
        return res.status(403).json({ message: "Your HOA manager assignment is currently suspended" });
      }

      const announcement = await storage.createHoaAnnouncement(validationResult.data);

      await createAuditLog(
        req,
        "create",
        "hoa_announcement",
        announcement.id,
        `Created announcement: ${announcement.title}`
      );

      res.status(201).json(announcement);
    } catch (error: any) {
      console.error("Error creating announcement:", error);
      res.status(500).json({ message: "Failed to create announcement" });
    }
  });

  // Update announcement
  app.patch("/api/hoa-manager/announcements/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = insertHoaAnnouncementSchema.partial().safeParse(req.body);

      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid data",
          errors: validationResult.error.errors,
        });
      }

      const existingAnnouncement = await storage.getHoaAnnouncement(req.params.id);
      if (!existingAnnouncement) {
        return res.status(404).json({ message: "Announcement not found" });
      }

      // Only the manager who created it can update
      if (existingAnnouncement.managerId !== userId) {
        return res.status(403).json({ message: "Not authorized to update this announcement" });
      }

      // Verify manager is still approved and not suspended
      const approvedManager = await storage.getApprovedHoaManagerByCondominium(existingAnnouncement.condominiumId);
      if (!approvedManager || approvedManager.managerId !== userId) {
        return res.status(403).json({ message: "You are no longer an approved HOA manager for this condominium" });
      }

      if (approvedManager.status === 'suspended') {
        return res.status(403).json({ message: "Your HOA manager assignment is currently suspended" });
      }

      const announcement = await storage.updateHoaAnnouncement(req.params.id, validationResult.data);

      await createAuditLog(
        req,
        "update",
        "hoa_announcement",
        req.params.id,
        `Updated announcement: ${announcement.title}`
      );

      res.json(announcement);
    } catch (error: any) {
      console.error("Error updating announcement:", error);
      res.status(500).json({ message: "Failed to update announcement" });
    }
  });

  // Publish announcement
  app.post("/api/hoa-manager/announcements/:id/publish", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const existingAnnouncement = await storage.getHoaAnnouncement(req.params.id);
      
      if (!existingAnnouncement) {
        return res.status(404).json({ message: "Announcement not found" });
      }

      // Only the manager who created it can publish
      if (existingAnnouncement.managerId !== userId) {
        return res.status(403).json({ message: "Not authorized to publish this announcement" });
      }

      // Verify manager is still approved and not suspended
      const approvedManager = await storage.getApprovedHoaManagerByCondominium(existingAnnouncement.condominiumId);
      if (!approvedManager || approvedManager.managerId !== userId) {
        return res.status(403).json({ message: "You are no longer an approved HOA manager for this condominium" });
      }

      if (approvedManager.status === 'suspended') {
        return res.status(403).json({ message: "Your HOA manager assignment is currently suspended" });
      }

      const announcement = await storage.publishHoaAnnouncement(req.params.id);

      await createAuditLog(
        req,
        "update",
        "hoa_announcement",
        req.params.id,
        `Published announcement: ${announcement.title}`
      );

      res.json(announcement);
    } catch (error: any) {
      console.error("Error publishing announcement:", error);
      res.status(500).json({ message: "Failed to publish announcement" });
    }
  });

  // Delete announcement
  app.delete("/api/hoa-manager/announcements/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const existingAnnouncement = await storage.getHoaAnnouncement(req.params.id);
      
      if (!existingAnnouncement) {
        return res.status(404).json({ message: "Announcement not found" });
      }

      // Only the manager who created it can delete
      if (existingAnnouncement.managerId !== userId) {
        return res.status(403).json({ message: "Not authorized to delete this announcement" });
      }

      // Verify manager is still approved and not suspended
      const approvedManager = await storage.getApprovedHoaManagerByCondominium(existingAnnouncement.condominiumId);
      if (!approvedManager || approvedManager.managerId !== userId) {
        return res.status(403).json({ message: "You are no longer an approved HOA manager for this condominium" });
      }

      if (approvedManager.status === 'suspended') {
        return res.status(403).json({ message: "Your HOA manager assignment is currently suspended" });
      }

      await storage.deleteHoaAnnouncement(req.params.id);

      await createAuditLog(
        req,
        "delete",
        "hoa_announcement",
        req.params.id,
        `Deleted announcement: ${existingAnnouncement.title}`
      );

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting announcement:", error);
      res.status(500).json({ message: "Failed to delete announcement" });
    }
  });

  // Mark announcement as read (owner only - must own unit in condominium)
  app.post("/api/hoa-manager/announcements/:id/read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get announcement to verify condominium
      const announcement = await storage.getHoaAnnouncement(req.params.id);
      if (!announcement) {
        return res.status(404).json({ message: "Announcement not found" });
      }

      // Verify user owns a unit in this condominium
      const units = await storage.getCondominiumUnitsByOwner(userId);
      const ownsUnitInCondo = units.some(u => u.condominiumId === announcement.condominiumId);

      if (!ownsUnitInCondo) {
        return res.status(403).json({ message: "Not authorized to mark this announcement as read" });
      }

      const read = await storage.markHoaAnnouncementAsRead(req.params.id, userId);
      res.json(read);
    } catch (error: any) {
      console.error("Error marking announcement as read:", error);
      res.status(500).json({ message: "Failed to mark as read" });
    }
  });

  // Get announcement read status
  app.get("/api/hoa-manager/announcements/:id/reads", isAuthenticated, requireRole(["admin", "master", "hoa_manager"]), async (req, res) => {
    try {
      const reads = await storage.getHoaAnnouncementReads(req.params.id);
      res.json(reads);
    } catch (error: any) {
      console.error("Error fetching read status:", error);
      res.status(500).json({ message: "Failed to fetch read status" });
    }
  });

  // ========================================
  // Contact Import Routes (Admin Only)
  // ========================================

  // Parse CSV file and return parsed contacts with property matches
  app.post("/api/admin/contacts/parse-csv", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { csvData } = req.body;
      
      if (!csvData || !Array.isArray(csvData)) {
        return res.status(400).json({ message: "Datos CSV inválidos" });
      }

      const Papa = await import('papaparse');
      const { parseContactRow, isValidContact, normalizePhoneNumber } = await import('./utils/contactParser.js');

      // Parse CSV rows
      const parsedContacts = csvData.map((row: any) => parseContactRow(row));

      // Get all properties for matching
      const allProperties = await storage.getProperties({ includeInactive: true });

      // Match contacts with properties
      const contactsWithMatches = parsedContacts.map((contact: any) => {
        if (!contact.parseSuccess) {
          return {
            ...contact,
            matchedProperty: null,
            matchConfidence: 0,
          };
        }

        // Try to find matching property by condominium name + unit number
        const matches = allProperties.filter((prop: any) => {
          const condoNameMatch = prop.condoName?.toLowerCase().includes(contact.condominiumName.toLowerCase()) ||
                                contact.condominiumName.toLowerCase().includes(prop.condoName?.toLowerCase() || '');
          const unitMatch = prop.unitNumber?.toLowerCase() === contact.unitNumber.toLowerCase();
          
          return condoNameMatch && unitMatch;
        });

        let matchedProperty = null;
        let matchConfidence = 0;

        if (matches.length === 1) {
          matchedProperty = matches[0];
          matchConfidence = 100;
        } else if (matches.length > 1) {
          matchedProperty = matches[0];
          matchConfidence = 50; // Multiple matches, uncertain
        }

        return {
          ...contact,
          phoneNumber: contact.phoneNumber ? normalizePhoneNumber(contact.phoneNumber) : undefined,
          matchedProperty,
          matchConfidence,
        };
      });

      // Separate valid and invalid contacts
      const validContacts = contactsWithMatches.filter((c: any) => c.parseSuccess);
      const invalidContacts = contactsWithMatches.filter((c: any) => !c.parseSuccess);

      res.json({
        total: contactsWithMatches.length,
        valid: validContacts.length,
        invalid: invalidContacts.length,
        contacts: contactsWithMatches,
        summary: {
          autoMatched: validContacts.filter((c: any) => c.matchConfidence === 100).length,
          partialMatches: validContacts.filter((c: any) => c.matchConfidence > 0 && c.matchConfidence < 100).length,
          noMatches: validContacts.filter((c: any) => c.matchConfidence === 0).length,
        }
      });

      await createAuditLog(
        req,
        "create",
        "contact_import",
        "csv_parse",
        `Parsed ${contactsWithMatches.length} contacts from CSV`
      );

    } catch (error: any) {
      console.error("Error parsing CSV:", error);
      res.status(500).json({ message: error.message || "Error al procesar CSV" });
    }
  });

  // Batch update properties with owner contact data
  app.post("/api/admin/contacts/batch-update", isAuthenticated, requireRole(["master", "admin"]), async (req: any, res) => {
    try {
      const { updates } = req.body;
      
      if (!updates || !Array.isArray(updates)) {
        return res.status(400).json({ message: "Datos de actualización inválidos" });
      }

      const results = {
        success: 0,
        failed: 0,
        errors: [] as any[],
      };

      for (const update of updates) {
        try {
          const { propertyId, ownerFirstName, ownerLastName, ownerPhone, ownerEmail, referredByName, referredByLastName, referredByPhone, referredByEmail } = update;

          if (!propertyId) {
            results.failed++;
            results.errors.push({ update, error: "Missing property ID" });
            continue;
          }

          await storage.updateProperty(propertyId, {
            ownerFirstName,
            ownerLastName,
            ownerPhone,
            ownerEmail: ownerEmail || null,
            referredByName: referredByName || null,
            referredByLastName: referredByLastName || null,
            referredByPhone: referredByPhone || null,
            referredByEmail: referredByEmail || null,
          });

          results.success++;
        } catch (error: any) {
          results.failed++;
          results.errors.push({ update, error: error.message });
        }
      }

      await createAuditLog(
        req,
        "update",
        "contact_import",
        "batch_update",
        `Batch updated ${results.success} properties with owner contact data`
      );

      res.json(results);

    } catch (error: any) {
      console.error("Error batch updating contacts:", error);
      res.status(500).json({ message: error.message || "Error al actualizar contactos" });
    }
  });

  // =========================================
  // External Management System API Routes
  // =========================================

  // External agency role constants for consistent permissions
  // ADMIN_ONLY: Only master/admin can perform these operations (agency creation, deletion)
  const ADMIN_ONLY = ["master", "admin"];
  // EXTERNAL_ADMIN_ROLES: Admin operations within external agencies
  const EXTERNAL_ADMIN_ROLES = ["master", "admin", "external_agency_admin"];
  // EXTERNAL_ACCOUNTING_ROLES: Payment and accounting operations
  const EXTERNAL_ACCOUNTING_ROLES = ["master", "admin", "external_agency_admin", "external_agency_accounting"];
  // EXTERNAL_MAINTENANCE_ROLES: Property, contract, and maintenance operations
  const EXTERNAL_MAINTENANCE_ROLES = ["master", "admin", "external_agency_admin", "external_agency_maintenance"];
  // EXTERNAL_ALL_ROLES: Read-only access for all external agency users
  const EXTERNAL_ALL_ROLES = ["master", "admin", "external_agency_admin", "external_agency_accounting", "external_agency_maintenance", "external_agency_seller", "external_agency_concierge", "external_agency_lawyer"];
  // EXTERNAL_SELLER_ROLES: Operations for sellers including lead management and presentation cards
  const EXTERNAL_SELLER_ROLES = ["master", "admin", "external_agency_admin", "external_agency_seller"];

  // ==============================
  // EXTERNAL PUBLICATION REQUESTS
  // ==============================


  // Helper function to sync external unit to properties table
  async function syncExternalUnitToProperty(unit: any, userId: string, agencyId: string): Promise<string | null> {
    try {
      // Get condominium info for mapping
      let condominiumId: string | null = null;
      let condoName: string | null = null;
      
      if (unit.condominiumId) {
        const extCondo = await storage.getExternalCondominium(unit.condominiumId);
        if (extCondo) {
          condoName = extCondo.name;
          // Check if there's a linked main condominium with the same name
          const mainCondos = await db.select()
            .from(condominiums)
            .where(eq(condominiums.name, extCondo.name))
            .limit(1);
          
          if (mainCondos.length > 0) {
            condominiumId = mainCondos[0].id;
          } else {
            // Create a new condominium in the main system
            const [newCondo] = await db.insert(condominiums)
              .values({
                name: extCondo.name,
                location: extCondo.address || unit.zone || 'Tulum',
                address: extCondo.address || '',
                approvalStatus: 'approved',
                status: 'active',
                addedBy: userId,
              })
              .returning();
            condominiumId = newCondo.id;
          }
        }
      }

      // Get agency details
      const agency = await storage.getExternalAgency(agencyId);

      // Create property from external unit
      // Use the admin user as owner, fallback to first admin if not available
      let propertyOwnerId = userId;
      if (!propertyOwnerId) {
        // Find a system admin to use as owner
        const admins = await db.select().from(users).where(eq(users.role, 'admin')).limit(1);
        propertyOwnerId = admins[0]?.id || userId;
      }

      // If no condominium was linked, create a generic one for external properties
      if (!condominiumId) {
        const externalCondoName = 'Propiedades Externas';
        const [existingExtCondo] = await db.select()
          .from(condominiums)
          .where(eq(condominiums.name, externalCondoName))
          .limit(1);
        
        if (existingExtCondo) {
          condominiumId = existingExtCondo.id;
        } else {
          const [newExtCondo] = await db.insert(condominiums)
            .values({
              name: externalCondoName,
              location: 'Tulum',
              address: 'Multiple locations',
              approvalStatus: 'approved',
              status: 'active',
              addedBy: propertyOwnerId,
            })
            .returning();
          condominiumId = newExtCondo.id;
        }
      }

      // Transform includedServices to proper format
      const includedServicesData = unit.includedServices ? {
        water: unit.includedServices.water === true,
        electricity: unit.includedServices.electricity === true,
        internet: unit.includedServices.internet === true,
        gas: unit.includedServices.gas === true,
      } : null;

      // Transform accessInfo to proper format (use unattended with lockbox as default)
      let accessInfoData = null;
      if (unit.accessInfo) {
        if (unit.accessInfo.lockboxCode) {
          accessInfoData = {
            accessType: 'unattended' as const,
            method: 'lockbox' as const,
            lockboxCode: unit.accessInfo.lockboxCode || '',
            lockboxLocation: '',
          };
        } else if (unit.accessInfo.contactPerson) {
          accessInfoData = {
            accessType: 'attended' as const,
            contactPerson: unit.accessInfo.contactPerson || '',
            contactPhone: unit.accessInfo.contactPhone || '',
          };
        }
      }

      const propertyData = {
        title: unit.title || `${unit.unitNumber} - ${condoName || unit.zone || 'Property'}`,
        description: unit.description || '',
        price: unit.price ? String(unit.price) : "0",
        propertyType: unit.propertyType || 'departamento',
        bedrooms: unit.bedrooms || 0,
        bathrooms: unit.bathrooms ? String(unit.bathrooms) : "1",
        area: unit.area ? String(unit.area) : null,
        location: unit.address || unit.zone || 'Tulum',
        colonyName: unit.zone || null,
        status: 'rent' as const,
        unitType: 'private',
        condominiumId: condominiumId,
        condoName: condoName || null,
        unitNumber: unit.unitNumber,
        showCondoInListing: true,
        showUnitNumberInListing: true,
        primaryImages: unit.primaryImages || [],
        secondaryImages: unit.secondaryImages || [],
        videos: unit.videos || [],
        virtualTourUrl: unit.virtualTourUrl || null,
        googleMapsUrl: unit.googleMapsUrl || null,
        latitude: unit.latitude ? String(unit.latitude) : null,
        longitude: unit.longitude ? String(unit.longitude) : null,
        amenities: unit.amenities || [],
        includedServices: includedServicesData,
        accessInfo: accessInfoData,
        petFriendly: unit.petFriendly || false,
        ownerId: propertyOwnerId,
        approvalStatus: 'approved' as const,
        active: true,
        published: true,
        externalUnitId: unit.id,
        externalAgencyId: agency?.id || null,
        externalAgencyName: agency?.name || null,
        externalAgencyLogoUrl: agency?.agencyLogoUrl || null,
      };

      const property = await storage.createProperty(propertyData);
      return property.id;
    } catch (error) {
      console.error("Error syncing external unit to property:", error);
      return null;
    }
  }

  // GET /api/external-publication-requests - Admin: Get all publication requests
  app.get("/api/external-publication-requests", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { status } = req.query;
      
      let query = db.select({
        id: externalPublicationRequests.id,
        unitId: externalPublicationRequests.unitId,
        agencyId: externalPublicationRequests.agencyId,
        requestedBy: externalPublicationRequests.requestedBy,
        reviewedBy: externalPublicationRequests.reviewedBy,
        status: externalPublicationRequests.status,
        adminFeedback: externalPublicationRequests.adminFeedback,
        linkedPropertyId: externalPublicationRequests.linkedPropertyId,
        requestedAt: externalPublicationRequests.requestedAt,
        reviewedAt: externalPublicationRequests.reviewedAt,
        createdAt: externalPublicationRequests.createdAt,
        updatedAt: externalPublicationRequests.updatedAt,
        unitNumber: externalUnits.unitNumber,
        unitTitle: externalUnits.title,
        unitDescription: externalUnits.description,
        unitPrice: externalUnits.price,
        unitCurrency: externalUnits.currency,
        unitBedrooms: externalUnits.bedrooms,
        unitBathrooms: externalUnits.bathrooms,
        unitArea: externalUnits.area,
        unitPrimaryImages: externalUnits.primaryImages,
        unitAmenities: externalUnits.amenities,
        unitAddress: externalUnits.address,
        unitZone: externalUnits.zone,
        unitPropertyType: externalUnits.propertyType,
        condominiumId: externalUnits.condominiumId,
        agencyName: externalAgencies.name,
      })
      .from(externalPublicationRequests)
      .leftJoin(externalUnits, eq(externalPublicationRequests.unitId, externalUnits.id))
      .leftJoin(externalAgencies, eq(externalPublicationRequests.agencyId, externalAgencies.id))
      .orderBy(desc(externalPublicationRequests.requestedAt));

      if (status && status !== 'all') {
        query = query.where(eq(externalPublicationRequests.status, status as any));
      }

      const requests = await query;

      // Get condominium names
      const condoIds = [...new Set(requests.filter(r => r.condominiumId).map(r => r.condominiumId!))];
      let condoMap: Record<string, string> = {};
      if (condoIds.length > 0) {
        const condos = await db.select({ id: externalCondominiums.id, name: externalCondominiums.name })
          .from(externalCondominiums)
          .where(inArray(externalCondominiums.id, condoIds));
        condoMap = Object.fromEntries(condos.map(c => [c.id, c.name]));
      }

      const enrichedRequests = requests.map(r => ({
        id: r.id,
        unitId: r.unitId,
        agencyId: r.agencyId,
        requestedBy: r.requestedBy,
        reviewedBy: r.reviewedBy,
        status: r.status,
        adminFeedback: r.adminFeedback,
        linkedPropertyId: r.linkedPropertyId,
        requestedAt: r.requestedAt,
        reviewedAt: r.reviewedAt,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt,
        unit: {
          unitNumber: r.unitNumber,
          title: r.unitTitle,
          description: r.unitDescription,
          price: r.unitPrice,
          currency: r.unitCurrency,
          bedrooms: r.unitBedrooms,
          bathrooms: r.unitBathrooms,
          area: r.unitArea,
          primaryImages: r.unitPrimaryImages,
          amenities: r.unitAmenities,
          address: r.unitAddress,
          zone: r.unitZone,
          propertyType: r.unitPropertyType,
          condominium: r.condominiumId ? { name: condoMap[r.condominiumId] || null } : null,
        },
        agency: r.agencyName ? { name: r.agencyName } : null,
      }));

      res.json(enrichedRequests);
    } catch (error) {
      console.error("Error fetching publication requests:", error);
      res.status(500).json({ message: "Failed to fetch publication requests" });
    }
  });


  // GET /api/external-publication-requests/stats - Admin: Get publication request statistics
  // NOTE: This route MUST be before /:id route to avoid "stats" being interpreted as an ID
  app.get("/api/external-publication-requests/stats", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const [stats] = await db.select({
        total: sql<number>`count(*)`,
        pending: sql<number>`count(*) filter (where status = 'pending')`,
        approved: sql<number>`count(*) filter (where status = 'approved')`,
        rejected: sql<number>`count(*) filter (where status = 'rejected')`,
        withdrawn: sql<number>`count(*) filter (where status = 'withdrawn')`,
      }).from(externalPublicationRequests);

      res.json(stats);
    } catch (error) {
      console.error("Error fetching publication stats:", error);
      res.status(500).json({ message: "Failed to fetch statistics" });
    }
  });
  // GET /api/external-publication-requests/:id - Admin: Get single request with full details
  app.get("/api/external-publication-requests/:id", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { id } = req.params;

      const [request] = await db.select()
        .from(externalPublicationRequests)
        .where(eq(externalPublicationRequests.id, id));

      if (!request) {
        return res.status(404).json({ message: "Publication request not found" });
      }

      // Get full unit details
      const unit = await storage.getExternalUnit(request.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }

      // Get condominium if exists
      let condominium = null;
      if (unit.condominiumId) {
        condominium = await storage.getExternalCondominium(unit.condominiumId);
      }

      // Get agency
      const agency = await storage.getExternalAgency(request.agencyId);

      res.json({
        ...request,
        unit: {
          ...unit,
          condominium,
        },
        agency,
      });
    } catch (error) {
      console.error("Error fetching publication request:", error);
      res.status(500).json({ message: "Failed to fetch publication request" });
    }
  });

  // POST /api/external-publication-requests - External: Create publication request
  app.post("/api/external-publication-requests", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { unitId } = req.body;
      
      // Verify unit belongs to agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit || unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied to this unit" });
      }

      const userId = req.user?.claims?.sub || req.user?.id;
      
      // Check if agency has auto-approve enabled
      const agency = await storage.getExternalAgency(agencyId);
      const shouldAutoApprove = agency?.autoApprovePublications === true;

      // Check if there's already a pending request for this unit
      const [existingPending] = await db.select()
        .from(externalPublicationRequests)
        .where(and(
          eq(externalPublicationRequests.unitId, unitId),
          eq(externalPublicationRequests.status, 'pending')
        ));

      if (existingPending) {
        // If auto-approve is enabled, approve the existing pending request
        if (shouldAutoApprove) {
          await db.update(externalPublicationRequests)
            .set({
              status: 'approved',
              reviewedBy: userId,
              reviewedAt: new Date(),
              feedback: 'Auto-approved by agency configuration',
            })
            .where(eq(externalPublicationRequests.id, existingPending.id));
          
          // Sync to properties table
          await syncExternalUnitToProperty(unit, userId, agencyId);
          await storage.updateExternalUnit(unitId, { publishToMain: true, publishStatus: 'approved' });
          
          return res.status(200).json({ ...existingPending, status: 'approved', autoApproved: true });
        }
        // Otherwise return error that pending request exists
        return res.status(400).json({ message: "A pending request already exists for this unit. Please wait for admin approval." });
      }

      // Create the request with appropriate status
      const [request] = await db.insert(externalPublicationRequests)
        .values({
          unitId,
          agencyId,
          requestedBy: userId,
          status: shouldAutoApprove ? 'approved' : 'pending',
          reviewedBy: shouldAutoApprove ? userId : null,
          reviewedAt: shouldAutoApprove ? new Date() : null,
          feedback: shouldAutoApprove ? 'Auto-approved by agency configuration' : null,
        })
        .returning();

      if (shouldAutoApprove) {
        // Auto-approve: sync to properties table
        await syncExternalUnitToProperty(unit, userId, agencyId);
        await storage.updateExternalUnit(unitId, { publishToMain: true, publishStatus: 'approved' });
      } else {
        // Manual approval required
        await storage.updateExternalUnit(unitId, { publishToMain: true, publishStatus: 'pending' });
      }

      res.status(201).json({ ...request, autoApproved: shouldAutoApprove });
    } catch (error) {
      console.error("Error creating publication request:", error);
      res.status(500).json({ message: "Failed to create publication request" });
    }
  });

  // PATCH /api/external-publication-requests/:id/review - Admin: Approve or reject request
  app.patch("/api/external-publication-requests/:id/review", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { decision, feedback } = req.body;
      const userId = req.user?.claims?.sub || req.user?.id || req.session?.adminUser?.id;

      if (!['approved', 'rejected'].includes(decision)) {
        return res.status(400).json({ message: "Invalid decision. Must be 'approved' or 'rejected'" });
      }

      const [request] = await db.select()
        .from(externalPublicationRequests)
        .where(eq(externalPublicationRequests.id, id));

      if (!request) {
        return res.status(404).json({ message: "Publication request not found" });
      }

      if (request.status !== 'pending') {
        return res.status(400).json({ message: "Request has already been reviewed" });
      }

      // Get unit details for syncing
      const unit = await storage.getExternalUnit(request.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }

      let linkedPropertyId: string | null = null;

      // If approved, sync to properties table
      if (decision === 'approved') {
        // Get condominium info for mapping
        let condominiumId: string | null = null;
        let condoName: string | null = null;
        
        if (unit.condominiumId) {
          const extCondo = await storage.getExternalCondominium(unit.condominiumId);
          if (extCondo) {
            condoName = extCondo.name;
            // Check if there's a linked main condominium with the same name
            const mainCondos = await db.select()
              .from(condominiums)
              .where(eq(condominiums.name, extCondo.name))
              .limit(1);
            
            if (mainCondos.length > 0) {
              condominiumId = mainCondos[0].id;
            } else {
              // Create a new condominium in the main system
              const [newCondo] = await db.insert(condominiums)
                .values({
                  name: extCondo.name,
                  location: extCondo.address || unit.zone || 'Tulum',
                  address: extCondo.address || '',
                  approvalStatus: 'approved',
                  status: 'active',
                  addedBy: userId,
                })
                .returning();
              condominiumId = newCondo.id;
            }
          }
        }

        // Get agency details
        const agency = await storage.getExternalAgency(request.agencyId);

        // Create property from external unit
        // Use the admin user as owner, fallback to first admin if not available
        let propertyOwnerId = userId;
        if (!propertyOwnerId) {
          // Find a system admin to use as owner
          const admins = await db.select().from(users).where(eq(users.role, 'admin')).limit(1);
          propertyOwnerId = admins[0]?.id || userId;
        }

        // If no condominium was linked, create a generic one for external properties
        if (!condominiumId) {
          const externalCondoName = 'Propiedades Externas';
          const [existingExtCondo] = await db.select()
            .from(condominiums)
            .where(eq(condominiums.name, externalCondoName))
            .limit(1);
          
          if (existingExtCondo) {
            condominiumId = existingExtCondo.id;
          } else {
            const [newExtCondo] = await db.insert(condominiums)
              .values({
                name: externalCondoName,
                location: 'Tulum',
                address: 'Multiple locations',
                approvalStatus: 'approved',
                status: 'active',
                addedBy: propertyOwnerId,
              })
              .returning();
            condominiumId = newExtCondo.id;
          }
        }

        // Transform includedServices to proper format
        const includedServicesData = unit.includedServices ? {
          water: unit.includedServices.water === true,
          electricity: unit.includedServices.electricity === true,
          internet: unit.includedServices.internet === true,
          gas: unit.includedServices.gas === true,
        } : null;

        // Transform accessInfo to proper format (use unattended with lockbox as default)
        let accessInfoData = null;
        if (unit.accessInfo) {
          if (unit.accessInfo.lockboxCode) {
            accessInfoData = {
              accessType: 'unattended' as const,
              method: 'lockbox' as const,
              lockboxCode: unit.accessInfo.lockboxCode || '',
              lockboxLocation: '',
            };
          } else if (unit.accessInfo.contactPerson) {
            accessInfoData = {
              accessType: 'attended' as const,
              contactPerson: unit.accessInfo.contactPerson || '',
              contactPhone: unit.accessInfo.contactPhone || '',
            };
          }
        }

        const propertyData = {
          title: unit.title || `${unit.unitNumber} - ${condoName || unit.zone || 'Property'}`,
          description: unit.description || '',
          price: unit.price ? String(unit.price) : "0",
          propertyType: unit.propertyType || 'departamento',
          bedrooms: unit.bedrooms || 0,
          bathrooms: unit.bathrooms ? String(unit.bathrooms) : "1",
          area: unit.area ? String(unit.area) : null,
          location: unit.address || unit.zone || 'Tulum',
          colonyName: unit.zone || null,
          status: 'rent' as const,
          unitType: 'private',
          condominiumId: condominiumId,
          condoName: condoName || null,
          unitNumber: unit.unitNumber,
          showCondoInListing: true,
          showUnitNumberInListing: true,
          primaryImages: unit.primaryImages || [],
          secondaryImages: unit.secondaryImages || [],
          videos: unit.videos || [],
          virtualTourUrl: unit.virtualTourUrl || null,
          googleMapsUrl: unit.googleMapsUrl || null,
          latitude: unit.latitude ? String(unit.latitude) : null,
          longitude: unit.longitude ? String(unit.longitude) : null,
          amenities: unit.amenities || [],
          includedServices: includedServicesData,
          accessInfo: accessInfoData,
          petFriendly: unit.petFriendly || false,
          ownerId: propertyOwnerId,
          approvalStatus: 'approved' as const,
          active: true,
          published: true,
          externalUnitId: unit.id,
          externalAgencyId: agency?.id || null,
        };

        const property = await storage.createProperty(propertyData);
        linkedPropertyId = property.id;
      }

      // Update the request
      const [updatedRequest] = await db.update(externalPublicationRequests)
        .set({
          status: decision,
          reviewedBy: userId,
          reviewedAt: new Date(),
          adminFeedback: feedback || null,
          linkedPropertyId: linkedPropertyId,
          updatedAt: new Date(),
        })
        .where(eq(externalPublicationRequests.id, id))
        .returning();

      // Update unit publish status
      const newPublishStatus = decision === 'approved' ? 'approved' : 'rejected';
      await storage.updateExternalUnit(request.unitId, { 
        publishStatus: newPublishStatus,
        publishedAt: decision === 'approved' ? new Date() : null,
      });

      res.json(updatedRequest);
    } catch (error) {
      console.error("Error reviewing publication request:", error);
      res.status(500).json({ message: "Failed to review publication request" });
    }
  });

  // DELETE /api/external-publication-requests/:id - External: Withdraw publication request
  app.delete("/api/external-publication-requests/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const [request] = await db.select()
        .from(externalPublicationRequests)
        .where(eq(externalPublicationRequests.id, id));

      if (!request) {
        return res.status(404).json({ message: "Publication request not found" });
      }

      if (request.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      if (request.status !== 'pending') {
        return res.status(400).json({ message: "Can only withdraw pending requests" });
      }

      // Update to withdrawn status
      await db.update(externalPublicationRequests)
        .set({ status: 'withdrawn', updatedAt: new Date() })
        .where(eq(externalPublicationRequests.id, id));

      // Update unit
      await storage.updateExternalUnit(request.unitId, { publishToMain: false, publishStatus: 'draft' });

      res.json({ message: "Request withdrawn successfully" });
    } catch (error) {
      console.error("Error withdrawing publication request:", error);
      res.status(500).json({ message: "Failed to withdraw request" });
    }
  });

  // GET /api/external-publication-requests/by-unit/:unitId - Get request for a specific unit
  app.get("/api/external-publication-requests/by-unit/:unitId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      // Verify unit belongs to agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit || unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const requests = await db.select()
        .from(externalPublicationRequests)
        .where(eq(externalPublicationRequests.unitId, unitId))
        .orderBy(desc(externalPublicationRequests.requestedAt));

      res.json(requests);
    } catch (error) {
      console.error("Error fetching unit publication requests:", error);
      res.status(500).json({ message: "Failed to fetch publication requests" });
    }
  });

  // =========================================================================
  // FEATURED PROPERTIES ROUTES - Admin can manage up to 30 featured properties
  // =========================================================================

  // GET /api/featured-properties - Get all featured properties with unit details
  app.get("/api/featured-properties", async (req, res) => {
    try {
      // Get featured properties
      const featured = await db
        .select()
        .from(featuredProperties)
        .orderBy(asc(featuredProperties.sortOrder));
      
      // Fetch unit details for each featured property
      const result = await Promise.all(featured.map(async (fp) => {
        const unit = await storage.getExternalUnit(fp.unitId);
        let condominiumName = null;
        
        if (unit?.condominiumId) {
          const [condo] = await db.select({ name: externalCondominiums.name })
            .from(externalCondominiums)
            .where(eq(externalCondominiums.id, unit.condominiumId));
          condominiumName = condo?.name || null;
        }
        
        return {
          id: fp.id,
          unitId: fp.unitId,
          sortOrder: fp.sortOrder,
          addedBy: fp.addedBy,
          createdAt: fp.createdAt,
          // Unit details
          unitNumber: unit?.unitNumber || null,
          title: unit?.title || null,
          propertyType: unit?.propertyType || null,
          zone: unit?.zone || null,
          price: unit?.price || null,
          salePrice: unit?.salePrice || null,
          listingType: unit?.listingType || null,
          bedrooms: unit?.bedrooms || null,
          bathrooms: unit?.bathrooms || null,
          area: unit?.area || null,
          condominiumId: unit?.condominiumId || null,
          images: unit?.images || null,
          agencyId: unit?.agencyId || null,
          publishStatus: unit?.publishStatus || null,
          condominiumName,
        };
      }));

      res.json({ 
        data: result,
        count: result.length,
        maxLimit: 30,
        remainingSlots: Math.max(0, 30 - result.length)
      });
    } catch (error: any) {
      console.error("Error fetching featured properties:", error);
      res.status(500).json({ message: "Error fetching featured properties" });
    }
  });

  // POST /api/featured-properties - Add a property to featured (admin only)
  app.post("/api/featured-properties", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { unitId } = req.body;

      if (!unitId) {
        return res.status(400).json({ message: "unitId is required" });
      }

      // Check current count
      const [countResult] = await db
        .select({ count: sql<number>`count(*)` })
        .from(featuredProperties);
      const currentCount = Number(countResult?.count || 0);

      if (currentCount >= 30) {
        return res.status(400).json({ 
          message: "Maximum limit of 30 featured properties reached",
          code: "MAX_LIMIT_REACHED"
        });
      }

      // Check if unit is already featured
      const [existing] = await db.select()
        .from(featuredProperties)
        .where(eq(featuredProperties.unitId, unitId));

      if (existing) {
        return res.status(400).json({ 
          message: "This property is already featured",
          code: "ALREADY_FEATURED"
        });
      }

      // Verify the unit exists and is approved
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      if (unit.publishStatus !== 'approved') {
        return res.status(400).json({ 
          message: "Only approved properties can be featured",
          code: "NOT_APPROVED"
        });
      }

      // Get the next sort order
      const [maxOrder] = await db
        .select({ maxOrder: sql<number>`COALESCE(MAX(sort_order), 0)` })
        .from(featuredProperties);
      const nextOrder = Number(maxOrder?.maxOrder || 0) + 1;

      const userId = req.user?.claims?.sub || req.user?.id;
      
      const [newFeatured] = await db.insert(featuredProperties)
        .values({
          unitId,
          sortOrder: nextOrder,
          addedBy: userId,
        })
        .returning();

      res.status(201).json(newFeatured);
    } catch (error: any) {
      console.error("Error adding featured property:", error);
      res.status(500).json({ message: "Error adding featured property" });
    }
  });

  // PATCH /api/featured-properties/:id - Update sortOrder for a single featured property (admin only)
  app.patch("/api/featured-properties/:id", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { sortOrder } = req.body;

      if (typeof sortOrder !== 'number' || sortOrder < 1 || sortOrder > 30) {
        return res.status(400).json({ message: "sortOrder must be a number between 1 and 30" });
      }

      // Verify the featured property exists
      const [existing] = await db.select()
        .from(featuredProperties)
        .where(eq(featuredProperties.id, id));

      if (!existing) {
        return res.status(404).json({ message: "Featured property not found" });
      }

      // Get all featured properties to handle reordering
      const allFeatured = await db.select()
        .from(featuredProperties)
        .orderBy(asc(featuredProperties.sortOrder));

      const oldIndex = allFeatured.findIndex(fp => fp.id === id);
      const newIndex = sortOrder - 1;

      if (oldIndex === newIndex) {
        return res.json({ message: "No change needed" });
      }

      // Update sort orders for affected items
      const updates: Promise<any>[] = [];
      
      if (newIndex < oldIndex) {
        // Moving up: increment sortOrder for items between newIndex and oldIndex
        allFeatured.forEach((fp, idx) => {
          if (fp.id === id) {
            updates.push(db.update(featuredProperties)
              .set({ sortOrder: sortOrder })
              .where(eq(featuredProperties.id, fp.id)));
          } else if (idx >= newIndex && idx < oldIndex) {
            updates.push(db.update(featuredProperties)
              .set({ sortOrder: idx + 2 })
              .where(eq(featuredProperties.id, fp.id)));
          }
        });
      } else {
        // Moving down: decrement sortOrder for items between oldIndex and newIndex
        allFeatured.forEach((fp, idx) => {
          if (fp.id === id) {
            updates.push(db.update(featuredProperties)
              .set({ sortOrder: sortOrder })
              .where(eq(featuredProperties.id, fp.id)));
          } else if (idx > oldIndex && idx <= newIndex) {
            updates.push(db.update(featuredProperties)
              .set({ sortOrder: idx })
              .where(eq(featuredProperties.id, fp.id)));
          }
        });
      }

      await Promise.all(updates);

      res.json({ message: "Sort order updated successfully" });
    } catch (error: any) {
      console.error("Error updating featured property sort order:", error);
      res.status(500).json({ message: "Error updating sort order" });
    }
  });

  // PATCH /api/featured-properties/reorder - Bulk reorder featured properties (admin only)
  app.patch("/api/featured-properties/reorder", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { order } = req.body; // Array of { id, sortOrder }

      if (!Array.isArray(order)) {
        return res.status(400).json({ message: "order must be an array of { id, sortOrder }" });
      }

      // Validate all items have valid sortOrder (1-30)
      for (const item of order) {
        if (typeof item.sortOrder !== 'number' || item.sortOrder < 1 || item.sortOrder > 30) {
          return res.status(400).json({ message: "All sortOrder values must be between 1 and 30" });
        }
      }

      // Verify all IDs exist in the database - only allow updating existing items
      const existingItems = await db.select({ id: featuredProperties.id })
        .from(featuredProperties);
      const existingIds = new Set(existingItems.map(item => item.id));
      
      for (const item of order) {
        if (!existingIds.has(item.id)) {
          return res.status(400).json({ message: `Featured property ${item.id} not found` });
        }
      }

      // Ensure we're not exceeding the 30-item limit
      if (order.length > 30) {
        return res.status(400).json({ 
          message: "Cannot exceed 30 featured properties",
          code: "MAX_LIMIT_EXCEEDED"
        });
      }

      // Update each featured property's sort order
      await Promise.all(order.map(async (item: { id: string; sortOrder: number }) => {
        await db.update(featuredProperties)
          .set({ sortOrder: item.sortOrder })
          .where(eq(featuredProperties.id, item.id));
      }));

      res.json({ message: "Order updated successfully" });
    } catch (error: any) {
      console.error("Error reordering featured properties:", error);
      res.status(500).json({ message: "Error reordering featured properties" });
    }
  });

  // DELETE /api/featured-properties/:id - Remove a property from featured (admin only)
  app.delete("/api/featured-properties/:id", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { id } = req.params;

      const [deleted] = await db.delete(featuredProperties)
        .where(eq(featuredProperties.id, id))
        .returning();

      if (!deleted) {
        return res.status(404).json({ message: "Featured property not found" });
      }

      // Re-normalize sort orders after deletion
      const remaining = await db.select()
        .from(featuredProperties)
        .orderBy(asc(featuredProperties.sortOrder));

      await Promise.all(remaining.map(async (fp, index) => {
        await db.update(featuredProperties)
          .set({ sortOrder: index + 1 })
          .where(eq(featuredProperties.id, fp.id));
      }));

      res.json({ message: "Featured property removed", deleted });
    } catch (error: any) {
      console.error("Error removing featured property:", error);
      res.status(500).json({ message: "Error removing featured property" });
    }
  });

  // GET /api/featured-properties/available-units - Get available units to add as featured
  app.get("/api/featured-properties/available-units", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { search, limit = 20 } = req.query;

      // Get currently featured unit IDs
      const featured = await db.select({ unitId: featuredProperties.unitId })
        .from(featuredProperties);
      const featuredIds = featured.map(f => f.unitId);

      // Build query for approved units not already featured
      let conditions = [
        eq(externalUnits.publishStatus, 'approved'),
        eq(externalUnits.publishToMain, true),
        eq(externalUnits.isActive, true),
      ];

      if (featuredIds.length > 0) {
        conditions.push(sql`${externalUnits.id} NOT IN (${sql.raw(featuredIds.map(id => `'${id}'`).join(','))})`);
      }

      if (search && typeof search === 'string' && search.trim()) {
        const searchTerm = `%${search.trim()}%`;
        conditions.push(or(
          ilike(externalUnits.title, searchTerm),
          ilike(externalUnits.unitNumber, searchTerm),
          ilike(externalUnits.zone, searchTerm)
        ));
      }

      const units = await db
        .select({
          id: externalUnits.id,
          unitNumber: externalUnits.unitNumber,
          title: externalUnits.title,
          propertyType: externalUnits.propertyType,
          zone: externalUnits.zone,
          price: externalUnits.price,
          salePrice: externalUnits.salePrice,
          listingType: externalUnits.listingType,
          bedrooms: externalUnits.bedrooms,
          bathrooms: externalUnits.bathrooms,
          area: externalUnits.area,
          condominiumId: externalUnits.condominiumId,
          images: externalUnits.images,
          agencyId: externalUnits.agencyId,
        })
        .from(externalUnits)
        .where(and(...conditions))
        .orderBy(desc(externalUnits.createdAt))
        .limit(Number(limit));

      // Fetch condominium names
      const withCondos = await Promise.all(units.map(async (unit) => {
        if (unit.condominiumId) {
          const [condo] = await db.select({ name: externalCondominiums.name })
            .from(externalCondominiums)
            .where(eq(externalCondominiums.id, unit.condominiumId));
          return { ...unit, condominiumName: condo?.name || null };
        }
        return { ...unit, condominiumName: null };
      }));

      res.json(withCondos);
    } catch (error: any) {
      console.error("Error fetching available units:", error);
      res.status(500).json({ message: "Error fetching available units" });
    }
  });


  // External Agencies Routes
  app.get("/api/external-agencies", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { isActive } = req.query;
      const filters = isActive !== undefined ? { isActive: isActive === 'true' } : undefined;
      
      let agencies;
      if (req.user.role === "external_agency_admin") {
        // External agency admins can only see their own agency
        agencies = await storage.getExternalAgenciesByCreator(req.user.id);
      } else {
        // Master and admin can see all agencies
        agencies = await storage.getExternalAgencies(filters);
      }
      
      res.json(agencies);
    } catch (error: any) {
      console.error("Error fetching external agencies:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-agencies/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agency = await storage.getExternalAgency(id);
      
      if (!agency) {
        return res.status(404).json({ message: "Agency not found" });
      }
      
      res.json(agency);
    } catch (error: any) {
      console.error("Error fetching external agency:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-agencies", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const validatedData = insertExternalAgencySchema.parse(req.body);
      
      // Admin can assign an agency to a specific user via createdBy field
      const assignedUserId = validatedData.createdBy || req.user.id;
      
      // Verify that the assigned user exists
      const assignedUser = await storage.getUser(assignedUserId);
      if (!assignedUser) {
        return res.status(404).json({ message: "Assigned user not found" });
      }
      
      // Check if the assigned user already has an agency
      const existingAgencies = await storage.getExternalAgenciesByCreator(assignedUserId);
      if (existingAgencies && existingAgencies.length > 0) {
        return res.status(400).json({ message: "User already has an external agency" });
      }
      
      // Create agency first
      const agency = await storage.createExternalAgency({
        ...validatedData,
        createdBy: assignedUserId,
      });
      
      try {
        // Update assigned user's role to external_agency_admin, clear any additional roles, set their agency ID, and verify their email
        await storage.updateUserRole(assignedUserId, "external_agency_admin");
        await storage.updateUser(assignedUserId, { 
          externalAgencyId: agency.id,
          emailVerified: true,
          additionalRole: null  // Clear any additional roles to prevent conflicts
        });
      } catch (roleError) {
        // Rollback: Delete the agency if role update fails
        console.error("Role update failed, attempting rollback:", roleError);
        try {
          await storage.deleteExternalAgency(agency.id);
          console.log("Successfully rolled back agency creation");
        } catch (deleteError) {
          console.error("CRITICAL: Rollback failed - manual cleanup required for agency", agency.id, deleteError);
          // Agency exists but role was not assigned - admin must manually fix
        }
        throw new Error("Failed to assign user role. Please contact support if this persists.");
      }
      
      await createAuditLog(req, "create", "external_agency", agency.id, `Created external agency for user ${assignedUserId}`);
      res.status(201).json(agency);
    } catch (error: any) {
      console.error("Error creating external agency:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // Self-registration endpoint for external agencies (available to all authenticated users)
  app.post("/api/external-agencies/register", isAuthenticated, async (req: any, res) => {
    try {
      // Check if user already has an agency
      const existingAgencies = await storage.getExternalAgenciesByCreator(req.user.id);
      if (existingAgencies && existingAgencies.length > 0) {
        return res.status(400).json({ message: "User already has an external agency" });
      }

      const validatedData = insertExternalAgencySchema.parse(req.body);
      const agency = await storage.createExternalAgency({
        ...validatedData,
        createdBy: req.user.id,
      });
      
      // Update user role to external_agency_admin, clear any additional roles, set their agency ID, and verify their email
      await storage.updateUserRole(req.user.id, "external_agency_admin");
      await storage.updateUser(req.user.id, { 
        externalAgencyId: agency.id,
        emailVerified: true,
        additionalRole: null  // Clear any additional roles to prevent conflicts
      });
      
      await createAuditLog(req, "create", "external_agency", agency.id, "Self-registered external agency");
      res.status(201).json(agency);
    } catch (error: any) {
      console.error("Error registering external agency:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-agencies/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { createdBy: newCreatedBy, ...updateData } = req.body;
      
      // Get current agency to check if createdBy is changing
      const currentAgency = await storage.getExternalAgency(id);
      if (!currentAgency) {
        return res.status(404).json({ message: "Agency not found" });
      }
      
      // Handle user reassignment if createdBy is changing
      if (newCreatedBy && newCreatedBy !== currentAgency.createdBy) {
        // Verify new user exists and is approved
        const newUser = await storage.getUser(newCreatedBy);
        if (!newUser) {
          return res.status(404).json({ message: "New assigned user not found" });
        }
        if (newUser.status !== "approved") {
          return res.status(400).json({ message: "User must be approved" });
        }
        
        // Check if new user already has an agency
        const existingAgencies = await storage.getExternalAgenciesByCreator(newCreatedBy);
        if (existingAgencies && existingAgencies.length > 0) {
          return res.status(400).json({ message: "New user already has an external agency" });
        }
        
        // Update agency with new createdBy
        const agency = await storage.updateExternalAgency(id, {
          ...updateData,
          createdBy: newCreatedBy,
        });
        
        // Update new user's role to external_agency_admin
        await storage.updateUserRole(newCreatedBy, "external_agency_admin");
        
        await createAuditLog(req, "update", "external_agency", id, `Reassigned agency from user ${currentAgency.createdBy} to ${newCreatedBy}`);
        res.json(agency);
      } else {
        // No user reassignment, just update agency data
        const agency = await storage.updateExternalAgency(id, updateData);
        await createAuditLog(req, "update", "external_agency", id, "Updated external agency");
        res.json(agency);
      }
    } catch (error: any) {
      console.error("Error updating external agency:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-agencies/:id/toggle-active", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      const agency = await storage.toggleExternalAgencyActive(id, isActive);
      
      await createAuditLog(req, "update", "external_agency", id, `${isActive ? 'Activated' : 'Deactivated'} external agency`);
      res.json(agency);
    } catch (error: any) {
      console.error("Error toggling external agency status:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-agencies/:id", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteExternalAgency(id);
      
      await createAuditLog(req, "delete", "external_agency", id, "Deleted external agency");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external agency:", error);
      handleGenericError(res, error);
    }
  });


  // ==============================
  // External Agency Integrations Routes
  // ==============================

  // GET /api/external-agencies/:agencyId/integrations - Get integration settings for agency
  app.get("/api/external-agencies/:agencyId/integrations", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { agencyId } = req.params;
      
      // Verify user has access to this agency
      const userAgencyId = await getUserAgencyId(req);
      if (userAgencyId && userAgencyId !== agencyId && !ADMIN_ONLY.includes(req.user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const integration = await storage.getExternalAgencyIntegration(agencyId);
      
      // Check Replit Google Calendar connection
      const googleCalendarStatus = await checkGoogleCalendarConnection();
      
      // Don't return sensitive tokens to frontend, only connection status
      if (integration) {
        res.json({
          ...integration,
          googleCalendarAccessToken: undefined,
          googleCalendarRefreshToken: undefined,
          openaiApiKey: undefined,
          googleCalendarConnected: googleCalendarStatus.connected,
          googleCalendarEmail: googleCalendarStatus.email,
          openaiConnected: !!(integration.openaiApiKey || integration.openaiUseReplitIntegration),
          openaiUseReplitIntegration: integration.openaiUseReplitIntegration,
          openaiHasCustomKey: !!integration.openaiApiKey,
        });
      } else {
        res.json({
          agencyId,
          googleCalendarConnected: googleCalendarStatus.connected,
          googleCalendarEmail: googleCalendarStatus.email,
          openaiConnected: false,
          openaiUseReplitIntegration: true,
          openaiHasCustomKey: false,
        });
      }
    } catch (error: any) {
      console.error("Error fetching agency integrations:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-agencies/:agencyId/integrations/openai - Update OpenAI configuration
  app.patch("/api/external-agencies/:agencyId/integrations/openai", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { agencyId } = req.params;
      const { apiKey, useReplitIntegration } = req.body;
      
      // Verify user has access to this agency
      const userAgencyId = await getUserAgencyId(req);
      if (userAgencyId && userAgencyId !== agencyId && !ADMIN_ONLY.includes(req.user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const integration = await storage.updateOpenAIConfig(agencyId, {
        apiKey: apiKey || null,
        useReplitIntegration: useReplitIntegration ?? true,
      });

      await createAuditLog(req, "update", "external_agency_integration", agencyId, "Updated OpenAI configuration");
      
      res.json({
        ...integration,
        openaiApiKey: undefined, // Don't return API key
        openaiConnected: !!(integration.openaiApiKey || integration.openaiUseReplitIntegration),
      });
    } catch (error: any) {
      console.error("Error updating OpenAI config:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-agencies/:agencyId/integrations/google-calendar - Disconnect Google Calendar
  app.delete("/api/external-agencies/:agencyId/integrations/google-calendar", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { agencyId } = req.params;
      
      // Verify user has access to this agency
      const userAgencyId = await getUserAgencyId(req);
      if (userAgencyId && userAgencyId !== agencyId && !ADMIN_ONLY.includes(req.user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      await storage.disconnectGoogleCalendar(agencyId);
      
      await createAuditLog(req, "delete", "external_agency_integration", agencyId, "Disconnected Google Calendar");
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error disconnecting Google Calendar:", error);
      handleGenericError(res, error);
    }
  });
  // ==============================
  // External Permission Management Routes
  // ==============================

  // GET /api/external/permissions/roles - Get all role permissions for agency
  app.get("/api/external/permissions/roles", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const permissions = await storage.getExternalRolePermissions(agencyId);
      
      // Return both saved permissions and default structure
      res.json({
        permissions,
        defaults: DEFAULT_ROLE_PERMISSIONS,
        sections: EXTERNAL_PERMISSION_SECTIONS,
        actions: EXTERNAL_PERMISSION_ACTIONS,
        sectionLabels: PERMISSION_SECTION_LABELS,
        actionLabels: PERMISSION_ACTION_LABELS,
      });
    } catch (error: any) {
      console.error("Error fetching role permissions:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/permissions/roles - Update role permissions (bulk upsert)
  app.patch("/api/external/permissions/roles", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const { permissions } = req.body;
      if (!Array.isArray(permissions)) {
        return res.status(400).json({ message: "permissions must be an array" });
      }

      // Validate and prepare permissions
      const validatedPermissions = permissions.map((p: any) => {
        const validated = insertExternalRolePermissionSchema.parse({
          agencyId,
          role: p.role,
          section: p.section,
          action: p.action,
          allowed: p.allowed,
        });
        return validated;
      });

      const results = await storage.bulkUpsertExternalRolePermissions(validatedPermissions);
      
      await createAuditLog(req, "update", "external_role_permissions", agencyId, `Updated ${results.length} role permissions`);
      
      res.json(results);
    } catch (error: any) {
      console.error("Error updating role permissions:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/permissions/users - Get all user permission overrides for agency
  app.get("/api/external/permissions/users", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const permissions = await storage.getExternalUserPermissions(agencyId);
      const agencyUsers = await storage.getUsersByAgency(agencyId);
      
      res.json({
        permissions,
        users: agencyUsers.map(u => ({
          id: u.id,
          firstName: u.firstName,
          lastName: u.lastName,
          email: u.email,
          role: u.role,
        })),
        sections: EXTERNAL_PERMISSION_SECTIONS,
        actions: EXTERNAL_PERMISSION_ACTIONS,
        sectionLabels: PERMISSION_SECTION_LABELS,
        actionLabels: PERMISSION_ACTION_LABELS,
      });
    } catch (error: any) {
      console.error("Error fetching user permissions:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/permissions/users/:userId - Get specific user's permission overrides
  app.get("/api/external/permissions/users/:userId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const { userId } = req.params;
      const permissions = await storage.getExternalUserPermissionsByUser(agencyId, userId);
      
      res.json(permissions);
    } catch (error: any) {
      console.error("Error fetching user permissions:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/permissions/users/:userId - Update specific user's permission overrides
  app.patch("/api/external/permissions/users/:userId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const { userId } = req.params;
      const { permissions } = req.body;
      
      if (!Array.isArray(permissions)) {
        return res.status(400).json({ message: "permissions must be an array" });
      }

      // Validate user belongs to agency
      const user = await storage.getUser(userId);
      if (!user || user.externalAgencyId !== agencyId) {
        return res.status(404).json({ message: "User not found in agency" });
      }

      // Validate and prepare permissions
      const validatedPermissions = permissions.map((p: any) => {
        const validated = insertExternalUserPermissionSchema.parse({
          agencyId,
          userId,
          section: p.section,
          action: p.action,
          allowed: p.allowed,
        });
        return validated;
      });

      const results = await storage.bulkUpsertExternalUserPermissions(validatedPermissions);
      
      await createAuditLog(req, "update", "external_user_permissions", userId, `Updated ${results.length} user permissions`);
      
      res.json(results);
    } catch (error: any) {
      console.error("Error updating user permissions:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/permissions/users/:userId - Clear all permission overrides for a user
  app.delete("/api/external/permissions/users/:userId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const { userId } = req.params;
      
      // Validate user belongs to agency
      const user = await storage.getUser(userId);
      if (!user || user.externalAgencyId !== agencyId) {
        return res.status(404).json({ message: "User not found in agency" });
      }

      await storage.deleteAllExternalUserPermissions(agencyId, userId);
      
      await createAuditLog(req, "delete", "external_user_permissions", userId, "Cleared all user permission overrides");
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error clearing user permissions:", error);
      handleGenericError(res, error);
    }
  });

  // ==============================
  // External Agency User Management Routes
  // ==============================

  // GET /api/external/users - Get all users for the authenticated user's agency
  app.get("/api/external/users", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const users = await storage.getUsersByAgency(agencyId);
      res.json(users);
    } catch (error: any) {
      console.error("Error fetching agency users:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/users - Create a new user for the agency
  app.post("/api/external/users", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const bcrypt = await import("bcryptjs");
      const crypto = await import("crypto");
      
      // Generate random password
      const generatedPassword = crypto.randomBytes(8).toString('base64').slice(0, 12);
      const passwordHash = await bcrypt.hash(generatedPassword, 10);

      const userData = {
        ...req.body,
        externalAgencyId: agencyId,
        passwordHash,
        requirePasswordChange: true,
        status: "approved" as const,
        emailVerified: true,
      };

      const user = await storage.createUserWithPassword(userData);
      
      // Remove sensitive fields and return user with generated password (only this once)
      const { passwordHash: _, ...safeUser } = user;
      await createAuditLog(req, "create", "user", user.id, `Created agency user: ${user.email}`);
      res.status(201).json({ ...safeUser, generatedPassword });
    } catch (error: any) {
      console.error("Error creating agency user:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/users/:id - Update a user in the agency
  app.patch("/api/external/users/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      // Verify the user belongs to the same agency
      const existingUser = await storage.getUser(id);
      if (!existingUser) {
        return res.status(404).json({ message: "User not found" });
      }

      if (existingUser.externalAgencyId !== agencyId) {
        return res.status(403).json({ message: "Cannot modify users from another agency" });
      }

      // Prevent changing externalAgencyId
      const { externalAgencyId: _, ...updates } = req.body;
      
      const user = await storage.updateUser(id, updates);
      
      // Remove sensitive fields from response
      const { passwordHash, ...safeUser } = user;
      await createAuditLog(req, "update", "user", id, `Updated agency user: ${user.email}`);
      res.json(safeUser);
    } catch (error: any) {
      console.error("Error updating agency user:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/users/:id - Delete a user from the agency
  app.delete("/api/external/users/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      // Verify the user belongs to the same agency
      const existingUser = await storage.getUser(id);
      if (!existingUser) {
        return res.status(404).json({ message: "User not found" });
      }

      if (existingUser.externalAgencyId !== agencyId) {
        return res.status(403).json({ message: "Cannot delete users from another agency" });
      }

      // Prevent deleting yourself
      const userId = req.user?.claims?.sub || req.user?.id;
      if (id === userId) {
        return res.status(400).json({ message: "Cannot delete your own account" });
      }

      await storage.deleteUser(id);
      await createAuditLog(req, "delete", "user", id, `Deleted agency user: ${existingUser.email}`);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting agency user:", error);
      handleGenericError(res, error);
    }
  });

  // External Properties Routes

  // ==================== External Appointments Routes ====================
  // Roles for appointment management
  const EXTERNAL_APPOINTMENT_VIEW_ROLES = ["master", "admin", "external_agency_admin", "external_agency_concierge", "external_agency_lawyer", "external_agency_seller"];
  const EXTERNAL_APPOINTMENT_MANAGE_ROLES = ["master", "admin", "external_agency_admin", "external_agency_concierge"];

  // GET /api/external-appointments - Get all appointments for agency
  app.get("/api/external-appointments", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_VIEW_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      const { status, salespersonId, conciergeId, startDate, endDate, mode, page, limit, search } = req.query;

      // Parse filters
      const filters: any = {};
      if (status) filters.status = status.includes(',') ? status.split(',') : status;
      if (salespersonId) filters.salespersonId = salespersonId;
      if (conciergeId) filters.conciergeId = conciergeId;
      if (startDate) filters.startDate = new Date(startDate);
      if (endDate) filters.endDate = new Date(endDate);
      if (mode) filters.mode = mode;

      // If pagination requested
      if (page && limit) {
        const result = await storage.getExternalAppointmentsPaginated(agencyId, {
          limit: parseInt(limit),
          offset: (parseInt(page) - 1) * parseInt(limit),
          ...filters,
          search: search || undefined,
        });
        return res.json(result);
      }

      const appointments = await storage.getExternalAppointmentsByAgency(agencyId, filters);
      res.json(appointments);
    } catch (error: any) {
      console.error("Error fetching external appointments:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-appointments/:id - Get single appointment
  app.get("/api/external-appointments/:id", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_VIEW_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      // Use agency-scoped query to prevent enumeration
      const appointment = await storage.getExternalAppointmentByAgency(id, agencyId);
      
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      // Get tour stops if this is a tour
      let tourStops: any[] = [];
      if (appointment.mode === 'tour') {
        tourStops = await storage.getExternalAppointmentUnitsByAppointment(id);
      }

      res.json({ ...appointment, tourStops });
    } catch (error: any) {
      console.error("Error fetching external appointment:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-appointments/unit/:unitId - Get appointments for a specific unit
  app.get("/api/external-appointments/unit/:unitId", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_VIEW_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      // Verify the unit belongs to the requester's agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit || unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Unit not found or not accessible" });
      }

      const appointments = await storage.getExternalAppointmentsByUnit(unitId, agencyId);
      res.json(appointments);
    } catch (error: any) {
      console.error("Error fetching unit appointments:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-appointments - Create appointment
  app.post("/api/external-appointments", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_MANAGE_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      const userId = req.user?.claims?.sub || req.user?.id;
      const { tourStops, ...appointmentData } = req.body;

      // Convert date string to Date object if needed
      const parsedDate = typeof appointmentData.date === 'string' 
        ? new Date(appointmentData.date) 
        : appointmentData.date;

      // Validate appointment data
      const validatedData = insertExternalAppointmentSchema.parse({
        ...appointmentData,
        date: parsedDate,
        agencyId,
        createdBy: userId,
      });

      // For tours, validate max 3 properties rule
      if (validatedData.mode === 'tour' && tourStops && tourStops.length > 3) {
        return res.status(400).json({ message: "Tours can have a maximum of 3 properties" });
      }

      // Calculate end time based on mode
      const startDate = new Date(validatedData.date);
      let endDate: Date;
      
      if (validatedData.mode === 'individual') {
        // Individual appointments are 1 hour
        endDate = new Date(startDate.getTime() + 60 * 60 * 1000);
      } else {
        // Tours: 30 minutes per property
        const propertyCount = tourStops?.length || 1;
        endDate = new Date(startDate.getTime() + propertyCount * 30 * 60 * 1000);
      }

      // Generate tour group ID if this is a tour
      const tourGroupId = validatedData.mode === 'tour' ? crypto.randomUUID() : null;

      const appointment = await storage.createExternalAppointment({
        ...validatedData,
        endTime: endDate,
        tourGroupId,
      });

      // Create tour stops if this is a tour
      if (validatedData.mode === 'tour' && tourStops && tourStops.length > 0) {
        const stopsData = tourStops.map((stop: any, index: number) => ({
          appointmentId: appointment.id,
          unitId: stop.unitId,
          sequence: index + 1,
          scheduledTime: new Date(startDate.getTime() + index * 30 * 60 * 1000),
          notes: stop.notes || null,
        }));

        await storage.createExternalAppointmentUnits(stopsData);
      }

      await createAuditLog(req, "create", "external_appointment", appointment.id, 
        `Created ${validatedData.mode} appointment for ${validatedData.clientName}`);

      // Log property activity for each unit in the appointment
      try {
        const unitsToLog: Array<{unitId: string, condominiumId: string | null}> = [];
        
        // For individual appointments, log the single unit
        if (validatedData.mode === 'individual' && validatedData.unitId) {
          const unit = await storage.getExternalUnit(validatedData.unitId);
          if (unit) {
            unitsToLog.push({ unitId: unit.id, condominiumId: unit.condominiumId || null });
          }
        }
        
        // For tours, log each tour stop
        if (validatedData.mode === 'tour' && tourStops) {
          for (const stop of tourStops) {
            const unit = await storage.getExternalUnit(stop.unitId);
            if (unit) {
              unitsToLog.push({ unitId: unit.id, condominiumId: unit.condominiumId || null });
            }
          }
        }
        
        // Log activity for each unit
        for (const unitInfo of unitsToLog) {
          await db.insert(externalPropertyActivityHistory).values({
            agencyId,
            unitId: unitInfo.unitId,
            condominiumId: unitInfo.condominiumId,
            activityType: 'appointment_scheduled',
            leadId: validatedData.leadId || null,
            leadName: validatedData.clientName,
            clientId: validatedData.clientId || null,
            clientName: validatedData.clientName,
            appointmentId: appointment.id,
            performedBy: userId,
            performedByName: null,
            details: {
              status: appointment.status,
              notes: appointment.notes
            },
          });
        }
      } catch (activityError) {
        console.error("Error logging property activity for appointment:", activityError);
      }


      res.status(201).json(appointment);
    } catch (error: any) {
      console.error("Error creating external appointment:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-appointments/:id - Update appointment
  app.patch("/api/external-appointments/:id", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_MANAGE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      // Use agency-scoped query to prevent enumeration
      const appointment = await storage.getExternalAppointmentByAgency(id, agencyId);
      
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      const { tourStops, ...rawUpdateData } = req.body;

      // Validate tour stops if provided (max 3)
      if (tourStops && tourStops.length > 3) {
        return res.status(400).json({ message: "Tours can have a maximum of 3 properties" });
      }

      // Filter out undefined values and only include valid updatable fields to prevent NOT NULL violations
      const allowedFields = ['clientId', 'leadId', 'presentationCardId', 'clientName', 'clientEmail', 'clientPhone', 'mode', 'type', 'date', 'unitId', 'notes', 'salespersonId', 'conciergeId', 'status', 'completedAt', 'tourStops', 'feedbackOutcome', 'feedbackNotes', 'feedbackRatingDelta', 'feedbackSubmittedAt', 'feedbackSubmittedBy'];
      const updateData: Record<string, any> = {};
      for (const field of allowedFields) {
        if (rawUpdateData[field] !== undefined) {
          updateData[field] = rawUpdateData[field];
        }
      }

      const updated = await storage.updateExternalAppointment(id, updateData);

      // Update tour stops if provided
      if (tourStops) {
        await storage.deleteExternalAppointmentUnitsByAppointment(id);
        if (tourStops.length > 0) {
          const startDate = new Date(updated.date);
          const stopsData = tourStops.map((stop: any, index: number) => ({
            appointmentId: id,
            unitId: stop.unitId,
            sequence: index + 1,
            scheduledTime: new Date(startDate.getTime() + index * 30 * 60 * 1000),
            notes: stop.notes || null,
          }));
          await storage.createExternalAppointmentUnits(stopsData);
        }
      }

      await createAuditLog(req, "update", "external_appointment", id, "Updated appointment details");

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating external appointment:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-appointments/:id/status - Update appointment status
  app.patch("/api/external-appointments/:id/status", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_MANAGE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status, cancellationReason } = req.body;

      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      // Use agency-scoped query to prevent enumeration
      const appointment = await storage.getExternalAppointmentByAgency(id, agencyId);
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      // Validate status transitions
      const validTransitions: Record<string, string[]> = {
        pending: ['confirmed', 'cancelled'],
        confirmed: ['completed', 'cancelled'],
        completed: [],
        cancelled: [],
      };
      
      const currentStatus = appointment.status;
      const allowedNextStatuses = validTransitions[currentStatus] || [];
      if (!allowedNextStatuses.includes(status)) {
        return res.status(400).json({ 
          message: 'Invalid status transition',
          allowedTransitions: allowedNextStatuses 
        });
      }

      const additionalData: any = {};
      if (status === 'confirmed') additionalData.confirmedAt = new Date();
      if (status === 'completed') additionalData.completedAt = new Date();
      if (status === 'cancelled') {
        additionalData.cancelledAt = new Date();
        if (cancellationReason) additionalData.cancellationReason = cancellationReason;
      }

      const updated = await storage.updateExternalAppointmentStatus(id, status, additionalData);

      await createAuditLog(req, "update", "external_appointment", id, `Changed status to ${status}`);

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating appointment status:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-appointments/:id/feedback - Submit appointment feedback
  app.patch("/api/external-appointments/:id/feedback", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_MANAGE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { outcome, notes, ratingDelta } = req.body;
      const userId = req.user?.id || req.session?.user?.id;

      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      const appointment = await storage.getExternalAppointmentByAgency(id, agencyId);
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }


      // Allow feedback for pending/confirmed appointments - this will also mark them as completed
      if (appointment.status === "cancelled") {
        return res.status(400).json({ message: "Cannot submit feedback for cancelled appointments" });
      }

      // First mark as completed if not already
      if (appointment.status !== "completed") {
        await storage.updateExternalAppointment(id, { 
          status: "completed",
          completedAt: new Date().toISOString(),
        });
      }

      const updated = await storage.submitAppointmentFeedback(id, {
        outcome,
        notes,
        ratingDelta,
        submittedBy: userId,
      });

      // Create client rating entry if ratingDelta is provided
      if (ratingDelta && (appointment.clientId || appointment.leadId)) {
        await storage.createClientRating({
          agencyId,
          clientId: appointment.clientId || null,
          leadId: appointment.leadId || null,
          appointmentId: id,
          ratingDelta,
          reason: outcome,
          notes,
          createdBy: userId,
        });

        // Update cumulative rating on client or lead
        if (appointment.clientId) {
          const newRating = await storage.getClientCumulativeRating(appointment.clientId, null);
          await storage.updateExternalClient(appointment.clientId, { cumulativeRating: newRating });
        } else if (appointment.leadId) {
          const newRating = await storage.getClientCumulativeRating(null, appointment.leadId);
          await storage.updateExternalLead(appointment.leadId, { cumulativeRating: newRating });
        }
      }

      await createAuditLog(req, "update", "external_appointment", id, `Submitted feedback: ${outcome}`);

      res.json(updated);
    } catch (error: any) {
      console.error("Error submitting appointment feedback:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/property-ratings - Get property ratings
  app.get("/api/external/property-ratings", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_VIEW_ROLES), async (req: any, res) => {
    try {
      const { propertyId, unitId } = req.query;
      const ratings = await storage.getPropertyRatings(propertyId, unitId);
      res.json(ratings);
    } catch (error: any) {
      console.error("Error getting property ratings:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/property-ratings - Create property rating
  app.post("/api/external/property-ratings", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_MANAGE_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      const userId = req.user?.id || req.session?.user?.id;
      const rating = await storage.createPropertyRating({
        ...req.body,
        agencyId,
        createdBy: userId,
      });

      await createAuditLog(req, "create", "property_rating", rating.id, "Created property rating");
      res.json(rating);
    } catch (error: any) {
      console.error("Error creating property rating:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/property-ratings/average - Get average rating for property
  app.get("/api/external/property-ratings/average", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_VIEW_ROLES), async (req: any, res) => {
    try {
      const { propertyId, unitId } = req.query;
      const result = await storage.getPropertyAverageRating(propertyId, unitId);
      res.json(result);
    } catch (error: any) {
      console.error("Error getting property average rating:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/client-ratings - Get client rating history
  app.get("/api/external/client-ratings", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_VIEW_ROLES), async (req: any, res) => {
    try {
      const { clientId, leadId } = req.query;
      const ratings = await storage.getClientRatings(clientId || null, leadId || null);
      res.json(ratings);
    } catch (error: any) {
      console.error("Error getting client ratings:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-appointments/:id/assign-concierge - Assign concierge
  app.patch("/api/external-appointments/:id/assign-concierge", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { conciergeId } = req.body;

      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      // Use agency-scoped query to prevent enumeration
      const appointment = await storage.getExternalAppointmentByAgency(id, agencyId);
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      const updated = await storage.assignExternalAppointmentConcierge(id, conciergeId);

      await createAuditLog(req, "update", "external_appointment", id, `Assigned concierge ${conciergeId}`);

      res.json(updated);
    } catch (error: any) {
      console.error("Error assigning concierge:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-appointments/:id - Delete appointment
  app.delete("/api/external-appointments/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      // Use agency-scoped query to prevent enumeration
      const appointment = await storage.getExternalAppointmentByAgency(id, agencyId);
      
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      // Delete tour stops first
      await storage.deleteExternalAppointmentUnitsByAppointment(id);
      await storage.deleteExternalAppointment(id);

      await createAuditLog(req, "delete", "external_appointment", id, "Deleted appointment");

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external appointment:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-appointments/:id/tour-stops - Get tour stops for appointment
  app.get("/api/external-appointments/:id/tour-stops", isAuthenticated, requireRole(EXTERNAL_APPOINTMENT_VIEW_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const stops = await storage.getExternalAppointmentUnitsByAppointment(id);
      res.json(stops);
    } catch (error: any) {
      console.error("Error fetching tour stops:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-properties", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { agencyId, status } = req.query;
      
      if (!agencyId) {
        return res.status(400).json({ message: "Agency ID is required" });
      }
      
      const filters = status ? { status } : undefined;
      const properties = await storage.getExternalPropertiesByAgency(agencyId, filters);
      
      res.json(properties);
    } catch (error: any) {
      console.error("Error fetching external properties:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-properties/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const property = await storage.getExternalProperty(id);
      
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }
      
      res.json(property);
    } catch (error: any) {
      console.error("Error fetching external property:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-properties", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalPropertySchema.parse(req.body);
      const property = await storage.createExternalProperty({
        ...validatedData,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_property", property.id, "Created external property");
      res.status(201).json(property);
    } catch (error: any) {
      console.error("Error creating external property:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-properties/:id", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const property = await storage.updateExternalProperty(id, req.body);
      
      await createAuditLog(req, "update", "external_property", id, "Updated external property");
      res.json(property);
    } catch (error: any) {
      console.error("Error updating external property:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-properties/:id/link", isAuthenticated, requireRole(ADMIN_ONLY), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { linkedPropertyId } = req.body;
      
      if (!linkedPropertyId) {
        return res.status(400).json({ message: "Linked property ID is required" });
      }
      
      const property = await storage.linkExternalProperty(id, linkedPropertyId);
      
      await createAuditLog(req, "update", "external_property", id, `Linked to property ${linkedPropertyId}`);
      res.json(property);
    } catch (error: any) {
      console.error("Error linking external property:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-properties/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteExternalProperty(id);
      
      await createAuditLog(req, "delete", "external_property", id, "Deleted external property");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external property:", error);
      handleGenericError(res, error);
    }
  });

  // External Rental Contracts Routes
  app.get("/api/external-contracts", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { agencyId, propertyId, status } = req.query;
      
      if (propertyId) {
        const contracts = await storage.getExternalRentalContractsByProperty(propertyId);
        return res.json(contracts);
      }
      
      if (!agencyId) {
        return res.status(400).json({ message: "Agency ID or Property ID is required" });
      }
      
      const filters = status ? { status } : undefined;
      const contracts = await storage.getExternalRentalContractsByAgency(agencyId, filters);
      
      res.json(contracts);
    } catch (error: any) {
      console.error("Error fetching external contracts:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-contracts/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const contract = await storage.getExternalRentalContract(id);
      
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      res.json(contract);
    } catch (error: any) {
      console.error("Error fetching external contract:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-contracts", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalRentalContractSchema.parse(req.body);
      const contract = await storage.createExternalRentalContract({
        ...validatedData,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_contract", contract.id, "Created external rental contract");
      res.status(201).json(contract);
    } catch (error: any) {
      console.error("Error creating external contract:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-contracts/:id", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const contract = await storage.updateExternalRentalContract(id, req.body);
      
      await createAuditLog(req, "update", "external_contract", id, "Updated external rental contract");
      res.json(contract);
    } catch (error: any) {
      console.error("Error updating external contract:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-contracts/:id/status", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status, autoConvertToLead } = req.body;
      
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }
      
      // Get the contract before updating to check for client
      const existingContract = await storage.getExternalRentalContractById(id);
      
      const contract = await storage.updateExternalContractStatus(id, status);
      
      await createAuditLog(req, "update", "external_contract", id, `Changed contract status to ${status}`);
      
      // Auto-convert client to lead when rental ends (status = completed)
      let convertedLead = null;
      if (status === 'completed' && existingContract?.clientId && autoConvertToLead !== false) {
        try {
          const client = await storage.getExternalClient(existingContract.clientId);
          
          // Only convert if client exists, is active, and hasn't been converted already
          if (client && client.status === 'active' && !client.convertedBackToLeadId) {
            const agencyId = existingContract.agencyId;
            
            // Get agency name for seller assignment
            const agencyResult = await db.select({
              name: externalAgencies.name,
            })
            .from(externalAgencies)
            .where(eq(externalAgencies.id, agencyId))
            .limit(1);
            
            const agencyName = agencyResult[0]?.name || 'Agencia';
            
            // Create new lead from client data
            const leadData = {
              agencyId,
              registrationType: 'seller' as const,
              firstName: client.firstName,
              lastName: client.lastName,
              email: client.email || undefined,
              phone: client.phone || undefined,
              status: 'nuevo_lead' as const,
              source: 'reconversion_cliente_rental_ended',
              notes: `Reconvertido automáticamente al finalizar renta. Contrato: ${id}. Cliente original ID: ${client.id}`,
              bedroomsText: client.bedroomsPreference?.toString() || undefined,
              sellerName: agencyName, // Assign agency as the seller
              createdBy: req.user.id,
            };

            convertedLead = await storage.createExternalLead(leadData);

            // Update client to mark as converted back
            await storage.updateExternalClient(client.id, {
              status: 'archived',
              convertedBackToLeadId: convertedLead.id,
              convertedBackToLeadAt: new Date(),
              convertedBackReason: 'rental_ended',
            });

            await createAuditLog(req, "create", "external_lead", convertedLead.id, `Auto-reconverted from client ${client.id} when rental ended`);
            await createAuditLog(req, "update", "external_client", client.id, `Auto-converted back to lead ${convertedLead.id} when rental ended`);
          }
        } catch (conversionError: any) {
          console.error("Error auto-converting client to lead:", conversionError);
          // Don't fail the main request if conversion fails
        }
      }
      
      res.json({ 
        ...contract,
        convertedLead: convertedLead ? { id: convertedLead.id, message: "Cliente reconvertido a lead automáticamente" } : null
      });
    } catch (error: any) {
      console.error("Error updating external contract status:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-contracts/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteExternalRentalContract(id);
      
      await createAuditLog(req, "delete", "external_contract", id, "Deleted external rental contract");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external contract:", error);
      handleGenericError(res, error);
    }
  });

  // External Agency Users Routes
  app.get("/api/external-agency-users", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Get all users with external agency roles that belong to this agency
      const externalRoles = ["external_agency_admin", "external_agency_accounting", "external_agency_maintenance", "external_agency_seller", "external_agency_concierge", "external_agency_lawyer"];
      const externalUsers = await db
        .select({
          id: users.id,
          email: users.email,
          firstName: users.firstName,
          lastName: users.lastName,
          phone: users.phone,
          role: users.role,
          status: users.status,
          maintenanceSpecialty: users.maintenanceSpecialty,
          isSuspended: users.isSuspended,
          createdAt: users.createdAt,
        })
        .from(users)
        .where(and(
          inArray(users.role, externalRoles),
          eq(users.externalAgencyId, agencyId)
        ))
        .orderBy(users.createdAt);

      res.json(externalUsers);
    } catch (error: any) {
      console.error("Error fetching external agency users:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-agency-users", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Zod validation schema for create user request
      const createUserSchema = z.object({
        email: z.string().email("Invalid email"),
        firstName: z.string().min(1, "First name required"),
        lastName: z.string().min(1, "Last name required"),
        phone: z.string().optional(),
        role: z.enum(["external_agency_admin", "external_agency_accounting", "external_agency_maintenance", "external_agency_seller", "external_agency_concierge", "external_agency_lawyer"]),
        maintenanceSpecialty: z.enum(["encargado_mantenimiento", "mantenimiento_general", "electrico", "plomero", "refrigeracion", "carpintero", "pintor", "jardinero", "albanil", "limpieza"]).optional(),
        commissionRate: z.enum(["10", "20", "40", "50"]).optional(),
      });

      const validatedData = createUserSchema.parse(req.body);

      // Check if user already exists
      console.log(`Checking for existing user with email: ${validatedData.email}`);
      const existingUser = await storage.getUserByEmail(validatedData.email);
      console.log(`Existing user found:`, existingUser ? `Yes - ID: ${existingUser.id}, Role: ${existingUser.role}` : 'No');
      if (existingUser) {
        return res.status(400).json({ message: "User with this email already exists" });
      }

      // Generate temporary password
      const tempPassword = crypto.randomBytes(8).toString('hex');
      const passwordHash = await bcrypt.hash(tempPassword, 10);

      // Create user with password change requirement
      const user = await storage.createUserWithPassword({
        email: validatedData.email,
        passwordHash,
        firstName: validatedData.firstName,
        lastName: validatedData.lastName,
        phone: validatedData.phone || null,
        role: validatedData.role,
        status: "approved",
        emailVerified: true, // Auto-verify external agency users
        requirePasswordChange: true, // Force password change on first login
        externalAgencyId: agencyId, // Link user to agency via externalAgencyId field
        maintenanceSpecialty: validatedData.maintenanceSpecialty || null,
      });

      await createAuditLog(req, "create", "user", user.id, `Created external agency user with role ${validatedData.role}`);


      // Auto-seed default message templates for sellers and create seller profile
      if (validatedData.role === "external_agency_seller") {
        try {
          const templatesCreated = await seedDefaultTemplatesForSeller(agencyId);
          console.log(`Auto-seeded ${templatesCreated} default templates for new seller ${user.email} in agency ${agencyId}`);
        } catch (templateError) {
          console.error("Error auto-seeding templates for new seller:", templateError);
          // Non-blocking - user creation succeeded
        }
        
        // Create seller profile with commission rate if provided
        try {
          await storage.createExternalSellerProfile({
            agencyId,
            userId: user.id,
            status: "active",
            commissionRate: validatedData.commissionRate || "10.00", // Default 10%
            hireDate: new Date(),
          });
          console.log(`Created seller profile for ${user.email} with commission rate ${validatedData.commissionRate || "10"}%`);
        } catch (profileError) {
          console.error("Error creating seller profile:", profileError);
          // Non-blocking - user creation succeeded
        }
      }
      res.status(201).json({ 
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          status: user.status,
          maintenanceSpecialty: user.maintenanceSpecialty,
        }, 
        tempPassword 
      });
    } catch (error: any) {
      console.error("Error creating external agency user:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-agency-users/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Zod validation schema for update user request
      const updateUserSchema = z.object({
        firstName: z.string().min(1, "First name required").optional(),
        lastName: z.string().min(1, "Last name required").optional(),
        phone: z.string().optional().nullable(),
        role: z.enum(["external_agency_admin", "external_agency_accounting", "external_agency_maintenance", "external_agency_seller", "external_agency_concierge", "external_agency_lawyer"]).optional(),
        maintenanceSpecialty: z.enum(["encargado_mantenimiento", "mantenimiento_general", "electrico", "plomero", "refrigeracion", "carpintero", "pintor", "jardinero", "albanil", "limpieza"]).optional().nullable(),
        commissionRate: z.enum(["10", "20", "40", "50"]).optional().nullable(),
      });

      const validatedData = updateUserSchema.parse(req.body);

      // Verify user belongs to this agency
      const user = await storage.getUser(id);
      if (!user || user.externalAgencyId !== agencyId) {
        return res.status(403).json({ message: "Unauthorized to update this user" });
      }

      // Update user in database
      const updateData: any = {
        updatedAt: new Date()
      };
      
      if (validatedData.firstName !== undefined) updateData.firstName = validatedData.firstName;
      if (validatedData.lastName !== undefined) updateData.lastName = validatedData.lastName;
      if (validatedData.phone !== undefined) updateData.phone = validatedData.phone || null;
      if (validatedData.role !== undefined) updateData.role = validatedData.role;
      if (validatedData.maintenanceSpecialty !== undefined) {
        updateData.maintenanceSpecialty = validatedData.maintenanceSpecialty || null;
      }

      const [updatedUser] = await db.update(users)
        .set(updateData)
        .where(eq(users.id, id))
        .returning();
      await createAuditLog(req, "update", "user", id, `Updated external agency user - changed: ${Object.keys(validatedData).join(', ')}`);

      // If this is a seller and commission rate is provided, update the seller profile
      if (validatedData.commissionRate && (validatedData.role === "external_agency_seller" || updatedUser.role === "external_agency_seller")) {
        const existingProfile = await storage.getExternalSellerProfileByUser(agencyId, id);
        const payload = {
          agencyId,
          userId: id,
          status: existingProfile?.status ?? "active",
          commissionRate: `${validatedData.commissionRate}.00`,
        };

        if (existingProfile) {
          await storage.updateExternalSellerProfile(existingProfile.id, payload);
        } else {
          await storage.createExternalSellerProfile({ ...payload, hireDate: new Date() });
        }
      }


      res.json({
        email: updatedUser.email,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        phone: updatedUser.phone,
        role: updatedUser.role,
        status: updatedUser.status,
        maintenanceSpecialty: updatedUser.maintenanceSpecialty,
      });
    } catch (error: any) {
      console.error("Error updating external agency user:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-agency-users/:id/reset-password", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Verify user belongs to this agency
      const user = await storage.getUser(id);
      if (!user || user.externalAgencyId !== agencyId) {
        return res.status(403).json({ message: "Unauthorized to reset password for this user" });
      }

      // Generate new temporary password
      const tempPassword = crypto.randomBytes(8).toString('hex');
      const passwordHash = await bcrypt.hash(tempPassword, 10);

      // Update password directly in database
      await db.update(users).set({ 
        passwordHash,
        updatedAt: new Date()
      }).where(eq(users.id, id));

      await createAuditLog(req, "update", "user", id, "Reset password for external agency user");

      res.json({ tempPassword });
    } catch (error: any) {
      console.error("Error resetting password:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-agency-users/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Verify user belongs to this agency
      const user = await storage.getUser(id);
      if (!user || user.externalAgencyId !== agencyId) {
        return res.status(403).json({ message: "Unauthorized to delete this user" });
      }

      await storage.deleteUser(id);
      await createAuditLog(req, "delete", "user", id, "Deleted external agency user");

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external agency user:", error);
      handleGenericError(res, error);
    }
  });


  // Suspend external agency user
  app.post("/api/external-agency-users/:id/suspend", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const user = await storage.getUser(id);
      if (!user || user.externalAgencyId !== agencyId) {
        return res.status(403).json({ message: "Unauthorized to suspend this user" });
      }

      const adminId = req.user?.claims?.sub || req.user?.id;
      if (id === adminId) {
        return res.status(400).json({ message: "No puedes suspender tu propia cuenta" });
      }

      await db
        .update(users)
        .set({
          isSuspended: true,
          suspendedAt: new Date(),
          suspendedById: adminId,
        })
        .where(eq(users.id, id));

      await createAuditLog(req, "update", "user", id, `Suspended external agency user ${user.firstName} ${user.lastName}`);
      res.json({ message: "Usuario suspendido exitosamente" });
    } catch (error: any) {
      console.error("Error suspending external agency user:", error);
      handleGenericError(res, error);
    }
  });

  // Unsuspend/Reactivate external agency user
  app.post("/api/external-agency-users/:id/unsuspend", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const user = await storage.getUser(id);
      if (!user || user.externalAgencyId !== agencyId) {
        return res.status(403).json({ message: "Unauthorized to reactivate this user" });
      }

      await db
        .update(users)
        .set({
          isSuspended: false,
          suspendedAt: null,
          suspendedById: null,
        })
        .where(eq(users.id, id));

      await createAuditLog(req, "update", "user", id, `Reactivated external agency user ${user.firstName} ${user.lastName}`);
      res.json({ message: "Usuario reactivado exitosamente" });
    } catch (error: any) {
      console.error("Error reactivating external agency user:", error);
      handleGenericError(res, error);
    }
  });
  // External Worker Assignments Routes
  app.get("/api/external-worker-assignments", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Get all worker assignments for this agency
      const assignments = await db
        .select({
          id: externalWorkerAssignments.id,
          agencyId: externalWorkerAssignments.agencyId,
          userId: externalWorkerAssignments.userId,
          condominiumId: externalWorkerAssignments.condominiumId,
          unitId: externalWorkerAssignments.unitId,
          createdAt: externalWorkerAssignments.createdAt,
        })
        .from(externalWorkerAssignments)
        .where(eq(externalWorkerAssignments.agencyId, agencyId));

      // Get maintenance managers (encargado_mantenimiento) who have global access
      const maintenanceManagers = await db
        .select({
          id: users.id,
        })
        .from(users)
        .where(and(
          eq(users.assignedToUser, agencyId),
          eq(users.maintenanceSpecialty, 'encargado_mantenimiento')
        ));

      // Get all condominiums for this agency
      const allCondominiums = await db
        .select({ id: externalCondominiums.id })
        .from(externalCondominiums)
        .where(eq(externalCondominiums.agencyId, agencyId));

      // Generate virtual assignments for maintenance managers (they have access to all condos)
      const virtualAssignments: any[] = [];
      for (const manager of maintenanceManagers) {
        // Check if manager already has manual assignments - if so, skip virtual ones for those condos
        const existingCondoIds = new Set(
          assignments.filter(a => a.userId === manager.id && a.condominiumId).map(a => a.condominiumId)
        );
        
        for (const condo of allCondominiums) {
          // Only add virtual assignment if no manual assignment exists for this condo
          if (!existingCondoIds.has(condo.id)) {
            virtualAssignments.push({
              id: `virtual-${manager.id}-${condo.id}`,
              agencyId,
              userId: manager.id,
              condominiumId: condo.id,
              unitId: null,
              createdAt: new Date(),
              isGlobal: true, // Flag to indicate this is an automatic global assignment
            });
          }
        }
      }

      // Combine real assignments (marked with isGlobal: false) with virtual ones
      const combinedAssignments = [
        ...assignments.map(a => ({ ...a, isGlobal: false })),
        ...virtualAssignments,
      ];

      res.json(combinedAssignments);
    } catch (error: any) {
      console.error("Error fetching worker assignments:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-worker-assignments", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const assignmentSchema = z.object({
        userId: z.string().min(1),
        condominiumId: z.string().min(1).optional(),
        unitId: z.string().min(1).optional(),
      });

      const data = assignmentSchema.parse(req.body);

      // Verify that the user belongs to this agency
      const worker = await storage.getUser(data.userId);
      if (!worker || worker.assignedToUser !== agencyId) {
        return res.status(403).json({ message: "Worker does not belong to this agency" });
      }

      // Verify condominium ownership if provided
      if (data.condominiumId) {
        const [condo] = await db
          .select()
          .from(externalCondominiums)
          .where(and(
            eq(externalCondominiums.id, data.condominiumId),
            eq(externalCondominiums.agencyId, agencyId)
          ))
          .limit(1);
        
        if (!condo) {
          return res.status(403).json({ message: "Condominium does not belong to this agency" });
        }
      }

      // Verify unit ownership if provided
      if (data.unitId) {
        const [unit] = await db
          .select()
          .from(externalUnits)
          .where(and(
            eq(externalUnits.id, data.unitId),
            eq(externalUnits.agencyId, agencyId)
          ))
          .limit(1);
        
        if (!unit) {
          return res.status(403).json({ message: "Unit does not belong to this agency" });
        }
      }

      // Create assignment
      const [assignment] = await db
        .insert(externalWorkerAssignments)
        .values({
          agencyId,
          userId: data.userId,
          condominiumId: data.condominiumId || null,
          unitId: data.unitId || null,
        })
        .returning();

      await createAuditLog(req, "create", "external_worker_assignment", assignment.id, "Created worker assignment");

      res.status(201).json(assignment);
    } catch (error: any) {
      console.error("Error creating worker assignment:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-worker-assignments/batch", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const batchSchema = z.object({
        assignments: z.array(z.object({
          userId: z.string().min(1),
          condominiumId: z.string().min(1).optional(),
          unitId: z.string().min(1).optional(),
        })),
      });

      const { assignments } = batchSchema.parse(req.body);

      if (!assignments || assignments.length === 0) {
        return res.status(400).json({ message: "No assignments provided" });
      }

      // Verify all resources belong to this agency
      for (const assignment of assignments) {
        // Verify worker belongs to agency
        const worker = await storage.getUser(assignment.userId);
        if (!worker || worker.assignedToUser !== agencyId) {
          return res.status(403).json({ message: `Worker ${assignment.userId} does not belong to this agency` });
        }

        // Verify condominium ownership if provided
        if (assignment.condominiumId) {
          const [condo] = await db
            .select()
            .from(externalCondominiums)
            .where(and(
              eq(externalCondominiums.id, assignment.condominiumId),
              eq(externalCondominiums.agencyId, agencyId)
            ))
            .limit(1);
          
          if (!condo) {
            return res.status(403).json({ message: `Condominium ${assignment.condominiumId} does not belong to this agency` });
          }
        }

        // Verify unit ownership if provided
        if (assignment.unitId) {
          const [unit] = await db
            .select()
            .from(externalUnits)
            .where(and(
              eq(externalUnits.id, assignment.unitId),
              eq(externalUnits.agencyId, agencyId)
            ))
            .limit(1);
          
          if (!unit) {
            return res.status(403).json({ message: `Unit ${assignment.unitId} does not belong to this agency` });
          }
        }
      }

      // Create all assignments
      const createdAssignments = [];
      for (const assignment of assignments) {
        const [created] = await db
          .insert(externalWorkerAssignments)
          .values({
            agencyId,
            userId: assignment.userId,
            condominiumId: assignment.condominiumId || null,
            unitId: assignment.unitId || null,
          })
          .returning();
        createdAssignments.push(created);
      }

      await createAuditLog(req, "create", "external_worker_assignment", "batch", `Created ${createdAssignments.length} worker assignments`);

      res.status(201).json({ 
        count: createdAssignments.length,
        assignments: createdAssignments 
      });
    } catch (error: any) {
      console.error("Error creating batch worker assignments:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-worker-assignments/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Verify assignment belongs to this agency
      const [assignment] = await db
        .select()
        .from(externalWorkerAssignments)
        .where(eq(externalWorkerAssignments.id, id))
        .limit(1);

      if (!assignment) {
        return res.status(404).json({ message: "Assignment not found" });
      }

      if (assignment.agencyId !== agencyId) {
        return res.status(403).json({ message: "Unauthorized to delete this assignment" });
      }

      await db
        .delete(externalWorkerAssignments)
        .where(eq(externalWorkerAssignments.id, id));

      await createAuditLog(req, "delete", "external_worker_assignment", id, "Deleted worker assignment");

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting worker assignment:", error);
      handleGenericError(res, error);
    }
  });

  // External All Access Controls Routes (Consolidated view)
  // Send access control by email
  app.post("/api/external-access-controls/send-email", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const sendEmailSchema = z.object({
        accessId: z.string().uuid(),
        userId: z.string().uuid(),
      });

      const { accessId, userId } = sendEmailSchema.parse(req.body);

      // Get access control and verify ownership
      const [accessControl] = await db
        .select({
          id: externalUnitAccessControls.id,
          accessType: externalUnitAccessControls.accessType,
          accessCode: externalUnitAccessControls.accessCode,
          description: externalUnitAccessControls.description,
          unitId: externalUnitAccessControls.unitId,
          unitNumber: externalUnits.unitNumber,
          condominiumId: externalUnits.condominiumId,
        })
        .from(externalUnitAccessControls)
        .innerJoin(externalUnits, eq(externalUnitAccessControls.unitId, externalUnits.id))
        .where(eq(externalUnitAccessControls.id, accessId))
        .limit(1);

      if (!accessControl) {
        return res.status(404).json({ message: "Access control not found" });
      }

      // Verify unit belongs to agency's condominium
      const [condo] = await db
        .select()
        .from(externalCondominiums)
        .where(eq(externalCondominiums.id, accessControl.condominiumId))
        .limit(1);

      if (!condo || condo.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get recipient user and verify they belong to the same agency
      const [recipient] = await db
        .select()
        .from(users)
        .where(eq(users.id, userId))
        .limit(1);

      if (!recipient || recipient.assignedToUser !== agencyId) {
        return res.status(404).json({ message: "Recipient user not found or not in your agency" });
      }

      // Send email using Resend
      const { sendAccessCodeEmail } = await import('./resend-service');
      
      await sendAccessCodeEmail(
        recipient.email,
        `${recipient.firstName} ${recipient.lastName}`,
        {
          condominiumName: condo.name,
          unitNumber: accessControl.unitNumber,
          accessType: accessControl.accessType,
          accessCode: accessControl.accessCode || '',
          description: accessControl.description || undefined,
        }
      );

      await createAuditLog(
        req,
        "email",
        "access_control",
        accessControl.id,
        `Sent access code to ${recipient.email}`
      );

      res.json({ success: true, message: "Email sent successfully" });
    } catch (error: any) {
      console.error("Error sending access control email:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-all-access-controls", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Get all units for this agency
      const units = await storage.getExternalUnitsByAgency(agencyId);
      const unitIds = units.map(u => u.id);

      if (unitIds.length === 0) {
        return res.json([]);
      }

      // Get all access controls for these units
      const accessControls = await db
        .select({
          id: externalUnitAccessControls.id,
          unitId: externalUnitAccessControls.unitId,
          accessType: externalUnitAccessControls.accessType,
          accessCode: externalUnitAccessControls.accessCode,
          description: externalUnitAccessControls.description,
          isActive: externalUnitAccessControls.isActive,
          canShareWithMaintenance: externalUnitAccessControls.canShareWithMaintenance,
          createdAt: externalUnitAccessControls.createdAt,
          updatedAt: externalUnitAccessControls.updatedAt,
          unitNumber: externalUnits.unitNumber,
          condominiumId: externalUnits.condominiumId,
        })
        .from(externalUnitAccessControls)
        .innerJoin(externalUnits, eq(externalUnitAccessControls.unitId, externalUnits.id))
        .where(
          and(
            inArray(externalUnitAccessControls.unitId, unitIds),
            eq(externalUnitAccessControls.isActive, true)
          )
        )
        .orderBy(externalUnits.unitNumber);

      // Get condominium names
      const condoIds = [...new Set(accessControls.map(ac => ac.condominiumId))];
      const condominiums = await db
        .select()
        .from(externalCondominiums)
        .where(inArray(externalCondominiums.id, condoIds));

      const condoMap = Object.fromEntries(condominiums.map(c => [c.id, c.name]));

      // Add condominium names and decrypt sensitive data
      const enrichedAccessControls = accessControls.map(ac => {
        const enriched: any = {
          ...ac,
          condominiumName: condoMap[ac.condominiumId] || 'Unknown',
        };
        
        // Decrypt accessCode if present
        if (enriched.accessCode) {
          try {
            enriched.accessCode = decrypt(enriched.accessCode);
          } catch (e) {
            console.error('Failed to decrypt accessCode for access control:', ac.id);
            enriched.accessCode = '';
          }
        }
        
        return enriched;
      });

      res.json(enrichedAccessControls);
    } catch (error: any) {
      console.error("Error fetching all access controls:", error);
      handleGenericError(res, error);
    }
  });

  // External Payment Schedules Routes
  app.get("/api/external-payment-schedules", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { contractId, isActive } = req.query;
      
      if (contractId) {
        const schedules = await storage.getExternalPaymentSchedulesByContract(contractId);
        return res.json(schedules);
      }
      
      // Get agency ID from authenticated user (admin/master can pass agencyId to view other agencies)
      let agencyId = req.query.agencyId;
      if (!agencyId) {
        agencyId = await getUserAgencyId(req);
        if (!agencyId) {
          return res.status(400).json({ message: "User is not assigned to any agency" });
        }
      }
      
      const filters = isActive !== undefined ? { isActive: isActive === 'true' } : undefined;
      const schedules = await storage.getExternalPaymentSchedulesByAgency(agencyId, filters);
      
      res.json(schedules);
    } catch (error: any) {
      console.error("Error fetching external payment schedules:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-payment-schedules", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalPaymentScheduleSchema.parse(req.body);
      const schedule = await storage.createExternalPaymentSchedule({
        ...validatedData,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_payment_schedule", schedule.id, "Created external payment schedule");
      res.status(201).json(schedule);
    } catch (error: any) {
      console.error("Error creating external payment schedule:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-payment-schedules/:id", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const schedule = await storage.updateExternalPaymentSchedule(id, req.body);
      
      await createAuditLog(req, "update", "external_payment_schedule", id, "Updated external payment schedule");
      res.json(schedule);
    } catch (error: any) {
      console.error("Error updating external payment schedule:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-payment-schedules/:id/toggle-active", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      const schedule = await storage.toggleExternalPaymentScheduleActive(id, isActive);
      
      await createAuditLog(req, "update", "external_payment_schedule", id, `${isActive ? 'Activated' : 'Deactivated'} payment schedule`);
      res.json(schedule);
    } catch (error: any) {
      console.error("Error toggling payment schedule status:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-payment-schedules/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteExternalPaymentSchedule(id);
      
      await createAuditLog(req, "delete", "external_payment_schedule", id, "Deleted external payment schedule");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external payment schedule:", error);
      handleGenericError(res, error);
    }
  });

  // Generate payments from schedules for a contract
  app.post("/api/external-payment-schedules/generate-payments/:contractId", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const { monthsAhead = 1 } = req.body; // How many months ahead to generate
      
      // Get contract and verify ownership
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Get active schedules for this contract
      const schedules = await db.select()
        .from(externalPaymentSchedules)
        .where(and(
          eq(externalPaymentSchedules.contractId, contractId),
          eq(externalPaymentSchedules.isActive, true)
        ));
      
      const generatedPayments = [];
      const now = new Date();
      const currentYear = now.getFullYear();
      const currentMonth = now.getMonth();
      
      // Normalize contract start to UTC midnight for comparison
      const contractStartDate = new Date(contract.startDate);
      const contractStartNormalized = new Date(Date.UTC(
        contractStartDate.getFullYear(),
        contractStartDate.getMonth(),
        contractStartDate.getDate(),
        0, 0, 0, 0
      ));
      
      for (const schedule of schedules) {
        // Determine the earliest valid payment date (max of contract start and schedule start)
        let earliestDate = contractStartNormalized;
        if (schedule.startDate) {
          const scheduleStartDate = new Date(schedule.startDate);
          const scheduleStartNormalized = new Date(Date.UTC(
            scheduleStartDate.getFullYear(),
            scheduleStartDate.getMonth(),
            scheduleStartDate.getDate(),
            0, 0, 0, 0
          ));
          if (scheduleStartNormalized > earliestDate) {
            earliestDate = scheduleStartNormalized;
          }
        }
        
        let paymentsCreated = 0;
        let monthOffset = 0;
        
        // Keep iterating until we have created the desired number of valid payments
        while (paymentsCreated < monthsAhead && monthOffset < 24) { // Cap at 24 months to prevent infinite loops
          // Properly calculate target date by adding months
          const targetDate = new Date(currentYear, currentMonth + monthOffset, 1);
          const targetYear = targetDate.getFullYear();
          const targetMonth = targetDate.getMonth();
          
          // Get last day of target month to clamp dayOfMonth
          const lastDayOfMonth = new Date(targetYear, targetMonth + 1, 0).getDate();
          const clampedDay = Math.min(schedule.dayOfMonth, lastDayOfMonth);
          
          // Create date at UTC midnight to avoid timezone issues
          const dueDateNormalized = new Date(Date.UTC(targetYear, targetMonth, clampedDay, 0, 0, 0, 0));
          
          // Format as ISO date for comparison
          const dueDateStr = dueDateNormalized.toISOString().split('T')[0];
          
          // Check if payment already exists for this month and service
          // Use SQL date comparison to handle any timezone differences in stored data
          const existingPayment = await db.select()
            .from(externalPayments)
            .where(and(
              eq(externalPayments.scheduleId, schedule.id),
              sql`DATE(${externalPayments.dueDate}) = ${dueDateStr}`
            ))
            .limit(1);
          
          // Only create payment if it doesn't exist and is valid (on or after earliest date)
          if (existingPayment.length === 0 && dueDateNormalized >= earliestDate) {
            const [payment] = await db.insert(externalPayments).values({
              id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
              agencyId: schedule.agencyId,
              contractId: schedule.contractId,
              scheduleId: schedule.id,
              serviceType: schedule.serviceType,
              amount: schedule.amount,
              currency: schedule.currency,
              dueDate: dueDateNormalized,
              status: 'pending',
              createdBy: req.user.id,
            }).returning();
            
            generatedPayments.push(payment);
            paymentsCreated++;
          }
          
          monthOffset++;
        }
      }
      
      await createAuditLog(req, "create", "external_payment", "", `Generated ${generatedPayments.length} payments from schedules`);
      res.status(201).json({ 
        generated: generatedPayments.length,
        payments: generatedPayments 
      });
    } catch (error: any) {
      console.error("Error generating payments from schedules:", error);
      handleGenericError(res, error);
    }
  });

  // External Payments Routes
  app.get("/api/external-payments", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { contractId, status, serviceType, upcomingDays } = req.query;
      
      if (contractId) {
        const filters = status ? { status } : undefined;
        const payments = await storage.getExternalPaymentsByContract(contractId, filters);
        return res.json(payments);
      }
      
      // Get agency ID from authenticated user (admin/master can pass agencyId to view other agencies)
      let agencyId = req.query.agencyId;
      if (!agencyId) {
        agencyId = await getUserAgencyId(req);
        if (!agencyId) {
          return res.status(400).json({ message: "User is not assigned to any agency" });
        }
      }
      
      if (upcomingDays) {
        const payments = await storage.getUpcomingExternalPayments(agencyId, parseInt(upcomingDays));
        return res.json(payments);
      }
      
      const filters: any = {};
      if (status) filters.status = status;
      if (serviceType) filters.serviceType = serviceType;
      
      const payments = await storage.getExternalPaymentsByAgency(agencyId, filters);
      
      res.json(payments);
    } catch (error: any) {
      console.error("Error fetching external payments:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-payments/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const payment = await storage.getExternalPayment(id);
      
      if (!payment) {
        return res.status(404).json({ message: "Payment not found" });
      }
      
      res.json(payment);
    } catch (error: any) {
      console.error("Error fetching external payment:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-payments", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalPaymentSchema.parse(req.body);
      const payment = await storage.createExternalPayment({
        ...validatedData,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_payment", payment.id, "Created external payment");
      res.status(201).json(payment);
    } catch (error: any) {
      console.error("Error creating external payment:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-payments/:id", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const payment = await storage.updateExternalPayment(id, req.body);
      
      await createAuditLog(req, "update", "external_payment", id, "Updated external payment");
      res.json(payment);
    } catch (error: any) {
      console.error("Error updating external payment:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-payments/:id/mark-paid", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const validatedData = markPaymentAsPaidSchema.parse(req.body);
      
      // Extract authenticated user ID
      const userId = req.user?.id || req.session?.adminUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "User ID not found in session" });
      }
      
      // Verify payment exists
      const existingPayment = await storage.getExternalPayment(id);
      if (!existingPayment) {
        return res.status(404).json({ message: "Payment not found" });
      }
      
      // Verify ownership: master/admin can access all, others must match agency
      let userRole = req.user?.role || req.session?.adminUser?.role;
      // Get role from database if not in session
      if (!userRole && userId) {
        const dbUser = await storage.getUser(userId);
        userRole = dbUser?.role;
      }
      const isMasterOrAdmin = userRole === "master" || userRole === "admin";
      
      if (!isMasterOrAdmin) {
        const agencyId = await getUserAgencyId(req);
        if (!agencyId || existingPayment.agencyId !== agencyId) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      
      // Mark payment as paid and create financial transaction
      const result = await storage.markExternalPaymentAsPaid(id, {
        paidBy: userId,
        confirmedBy: userId, // Same user marks and confirms for now
        confirmedAt: new Date(),
        paidDate: validatedData.paidDate,
        paymentMethod: validatedData.paymentMethod,
        paymentReference: validatedData.paymentReference,
        paymentProofUrl: validatedData.paymentProofUrl,
        notes: validatedData.notes,
      });
      
      // Try to generate next payment if this was from a schedule (best effort, don't fail main request)
      if (existingPayment.scheduleId) {
        try {
          const nextPayment = await storage.generateNextExternalPayment(id, userId);
          if (nextPayment) {
            await createAuditLog(req, "update", "external_payment", id, `Marked payment as paid and auto-generated next payment`);
          } else {
            await createAuditLog(req, "update", "external_payment", id, `Marked payment as paid (no next payment generated)`);
          }
        } catch (error: any) {
          console.error("Error generating next payment:", error);
          await createAuditLog(req, "update", "external_payment", id, `Marked payment as paid (error generating next payment: ${error.message})`);
        }
      } else {
        await createAuditLog(req, "update", "external_payment", id, "Marked payment as paid");
      }
      
      res.json(result);
    } catch (error: any) {
      console.error("Error marking payment as paid:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-payments/:id/status", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status, paidDate } = req.body;
      
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }
      
      // Verify payment exists
      const existingPayment = await storage.getExternalPayment(id);
      if (!existingPayment) {
        return res.status(404).json({ message: "Payment not found" });
      }
      
      // Verify ownership: master/admin can access all, others must match agency
      let userRole = req.user?.role || req.session?.adminUser?.role;
      // Get role from database if not in session
      if (!userRole && userId) {
        const dbUser = await storage.getUser(userId);
        userRole = dbUser?.role;
      }
      const isMasterOrAdmin = userRole === "master" || userRole === "admin";
      
      if (!isMasterOrAdmin) {
        const agencyId = await getUserAgencyId(req);
        if (!agencyId || existingPayment.agencyId !== agencyId) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      
      const payment = await storage.updateExternalPaymentStatus(id, status, paidDate ? new Date(paidDate) : undefined);
      
      // If payment is marked as paid, automatically generate next payment
      if (status === 'paid') {
        try {
          const nextPayment = await storage.generateNextExternalPayment(id, req.user.id);
          if (nextPayment) {
            await createAuditLog(req, "update", "external_payment", id, `Changed payment status to ${status} and auto-generated next payment`);
          } else {
            await createAuditLog(req, "update", "external_payment", id, `Changed payment status to ${status} (no next payment generated)`);
          }
        } catch (error: any) {
          console.error("Error generating next payment:", error);
          // Don't fail the main request, just log the error
          await createAuditLog(req, "update", "external_payment", id, `Changed payment status to ${status} (error generating next payment: ${error.message})`);
        }
      } else {
        await createAuditLog(req, "update", "external_payment", id, `Changed payment status to ${status}`);
      }
      
      res.json(payment);
    } catch (error: any) {
      console.error("Error updating external payment status:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-payments/:id/reminder-sent", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const payment = await storage.markExternalPaymentReminderSent(id);
      
      await createAuditLog(req, "update", "external_payment", id, "Marked payment reminder as sent");
      res.json(payment);
    } catch (error: any) {
      console.error("Error marking payment reminder sent:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-payments/:id/send-reminder", isAuthenticated, requireRole(EXTERNAL_ACCOUNTING_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Get payment details
      const payment = await storage.getExternalPayment(id);
      if (!payment) {
        return res.status(404).json({ message: "Payment not found" });
      }

      // Get contract details to find tenant email
      const contract = await storage.getExternalRentalContract(payment.contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found for this payment" });
      }

      // Get agency details for sender info
      let agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }
      const agency = await storage.getExternalAgency(agencyId);

      const tenantEmail = contract.tenantEmail;
      if (!tenantEmail) {
        return res.status(400).json({ message: "Tenant email not found in contract" });
      }

      // Prepare email content
      const dueDate = new Date(payment.dueDate).toLocaleDateString('es-MX', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
      
      const serviceTypeLabels: Record<string, string> = {
        rent: "Renta",
        electricity: "Electricidad",
        water: "Agua",
        gas: "Gas",
        internet: "Internet",
        cable_tv: "Cable TV",
        security: "Seguridad",
        parking: "Estacionamiento",
        maintenance: "Mantenimiento",
        cleaning: "Limpieza",
        other: "Otro",
      };

      const serviceName = serviceTypeLabels[payment.serviceType] || payment.serviceType;

      const emailSubject = `Recordatorio de Pago - ${serviceName}`;
      const emailHtml = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background-color: #4F46E5; color: white; padding: 20px; text-align: center; }
            .content { background-color: #f9fafb; padding: 30px; }
            .payment-details { background-color: white; border-radius: 8px; padding: 20px; margin: 20px 0; }
            .detail-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #e5e7eb; }
            .detail-label { font-weight: bold; color: #6b7280; }
            .detail-value { color: #111827; }
            .amount { font-size: 24px; font-weight: bold; color: #4F46E5; text-align: center; margin: 20px 0; }
            .footer { text-align: center; padding: 20px; color: #6b7280; font-size: 14px; }
            .warning { background-color: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin: 20px 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>Recordatorio de Pago</h1>
            </div>
            <div class="content">
              <p>Estimado/a ${contract.tenantName},</p>
              <p>Le recordamos que tiene un pago pendiente con los siguientes detalles:</p>
              
              <div class="payment-details">
                <div class="detail-row">
                  <span class="detail-label">Concepto:</span>
                  <span class="detail-value">${serviceName}</span>
                </div>
                <div class="detail-row">
                  <span class="detail-label">Fecha de Vencimiento:</span>
                  <span class="detail-value">${dueDate}</span>
                </div>
                <div class="amount">
                  $${parseFloat(payment.amount).toFixed(2)} ${payment.currency}
                </div>
              </div>

              ${payment.status === 'overdue' ? `
                <div class="warning">
                  <strong>⚠️ Pago Vencido</strong><br>
                  Este pago está vencido. Por favor, regularice su situación a la brevedad posible.
                </div>
              ` : ''}

              <p>Para más información o aclaraciones, por favor contáctenos.</p>
              <p>Atentamente,<br>${agency?.name || 'MISTIQ Tulum'}</p>
            </div>
            <div class="footer">
              <p>Este es un mensaje automático, por favor no responda a este correo.</p>
            </div>
          </div>
        </body>
        </html>
      `;

      // TODO: Send email using email service (Resend, SendGrid, etc.)
      // For now, we'll just mark it as sent and log the action
      console.log(`Would send payment reminder email to ${tenantEmail}`);
      console.log(`Subject: ${emailSubject}`);
      
      // Mark reminder as sent
      const updatedPayment = await storage.markExternalPaymentReminderSent(id);
      
      await createAuditLog(req, "notification", "external_payment", id, `Sent payment reminder to ${tenantEmail}`);
      
      res.json({ 
        success: true,
        message: "Payment reminder sent successfully",
        payment: updatedPayment 
      });
    } catch (error: any) {
      console.error("Error sending payment reminder:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-payments/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteExternalPayment(id);
      
      await createAuditLog(req, "delete", "external_payment", id, "Deleted external payment");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external payment:", error);
      handleGenericError(res, error);
    }
  });

  // External Maintenance Tickets Routes
  // External Maintenance Tickets Statistics by Biweekly Period
  app.get("/api/external-tickets/stats/biweekly", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { year, month, period, category, excludeCategories } = req.query; // period: 1 (1-15) or 2 (16-end)
      const agencyId = await getUserAgencyId(req);
      
      const now = new Date();
      const targetYear = year ? parseInt(year as string) : now.getFullYear();
      const targetMonth = month ? parseInt(month as string) : now.getMonth() + 1; // 1-based
      const targetPeriod = period ? parseInt(period as string) : (now.getDate() <= 15 ? 1 : 2);
      
      // Calculate date range for the biweekly period
      const startDay = targetPeriod === 1 ? 1 : 16;
      const lastDayOfMonth = new Date(targetYear, targetMonth, 0).getDate();
      const endDay = targetPeriod === 1 ? 15 : lastDayOfMonth;
      
      const startDate = new Date(targetYear, targetMonth - 1, startDay);
      startDate.setHours(0, 0, 0, 0);
      
      const endDate = new Date(targetYear, targetMonth - 1, endDay);
      endDate.setHours(23, 59, 59, 999);
      
      // Build category filter conditions
      const categoryConditions: any[] = [];
      if (category && typeof category === 'string') {
        categoryConditions.push(sql`category = ${category.trim()}`);
      }
      if (excludeCategories && typeof excludeCategories === 'string') {
        const excludeList = excludeCategories.split(',').map((c: string) => c.trim()).filter((c: string) => c);
        if (excludeList.length > 0) {
          categoryConditions.push(sql`category NOT IN (${sql.join(excludeList.map((c: string) => sql`${c}`), sql`, `)})`);
        }
      }
      
      // Query tickets for this agency within the biweekly period using reference date
      // Reference date: for closed/resolved tickets use closed_at, otherwise use scheduled_date or created_at
      let result;
      if (agencyId) {
        const baseCondition = sql`agency_id = ${agencyId}
            AND COALESCE(closed_at, scheduled_date, created_at) >= ${startDate.toISOString()}::timestamp
            AND COALESCE(closed_at, scheduled_date, created_at) <= ${endDate.toISOString()}::timestamp`;
        
        const whereClause = categoryConditions.length > 0
          ? sql`${baseCondition} AND ${sql.join(categoryConditions, sql` AND `)}`
          : baseCondition;
          
        result = await db.execute(sql`
          SELECT 
            COUNT(*) as total,
            COUNT(*) FILTER (WHERE status IN ('open', 'in_progress')) as open_count,
            COUNT(*) FILTER (WHERE status IN ('resolved', 'closed')) as resolved_count,
            COALESCE(SUM(CASE WHEN status IN ('resolved', 'closed') AND actual_cost IS NOT NULL THEN actual_cost ELSE 0 END), 0) as actual_cost_sum,
            COALESCE(SUM(CASE WHEN status IN ('resolved', 'closed') THEN COALESCE(total_charge_amount, actual_cost * 1.15, 0) ELSE 0 END), 0) as total_charge_sum,
            COALESCE(SUM(CASE WHEN status IN ('resolved', 'closed') AND accounting_sync_status = 'synced' THEN COALESCE(total_charge_amount, actual_cost * 1.15, 0) ELSE 0 END), 0) as paid_total_sum
          FROM external_maintenance_tickets
          WHERE ${whereClause}
        `);
      } else {
        // Admin/master users see all agencies
        const baseCondition = sql`COALESCE(closed_at, scheduled_date, created_at) >= ${startDate.toISOString()}::timestamp
            AND COALESCE(closed_at, scheduled_date, created_at) <= ${endDate.toISOString()}::timestamp`;
        
        const whereClause = categoryConditions.length > 0
          ? sql`${baseCondition} AND ${sql.join(categoryConditions, sql` AND `)}`
          : baseCondition;
          
        result = await db.execute(sql`
          SELECT 
            COUNT(*) as total,
            COUNT(*) FILTER (WHERE status IN ('open', 'in_progress')) as open_count,
            COUNT(*) FILTER (WHERE status IN ('resolved', 'closed')) as resolved_count,
            COALESCE(SUM(CASE WHEN status IN ('resolved', 'closed') AND actual_cost IS NOT NULL THEN actual_cost ELSE 0 END), 0) as actual_cost_sum,
            COALESCE(SUM(CASE WHEN status IN ('resolved', 'closed') THEN COALESCE(total_charge_amount, actual_cost * 1.15, 0) ELSE 0 END), 0) as total_charge_sum,
            COALESCE(SUM(CASE WHEN status IN ('resolved', 'closed') AND accounting_sync_status = 'synced' THEN COALESCE(total_charge_amount, actual_cost * 1.15, 0) ELSE 0 END), 0) as paid_total_sum
          FROM external_maintenance_tickets
          WHERE ${whereClause}
        `);
      }
      
      const row = result.rows[0] as any;
      const actualCost = parseFloat(row.actual_cost_sum || '0');
      const totalCharge = parseFloat(row.total_charge_sum || '0');
      const paidTotal = parseFloat(row.paid_total_sum || '0');
      const commission = totalCharge - actualCost;
      
      // Get month name in Spanish
      const monthNames = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
      const monthName = monthNames[targetMonth - 1];
      
      res.json({
        period: {
          year: targetYear,
          month: targetMonth,
          biweekly: targetPeriod,
          startDate: startDate.toISOString(),
          endDate: endDate.toISOString(),
          label: targetPeriod === 1 
            ? `1ra Quincena de ${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${targetYear}`
            : `2da Quincena de ${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${targetYear}`
        },
        stats: {
          total: parseInt(row.total || '0'),
          open: parseInt(row.open_count || '0'),
          resolved: parseInt(row.resolved_count || '0'),
          actualCost: actualCost,
          commission: commission,
          totalCharge: totalCharge,
          paidTotal: paidTotal
        }
      });
    } catch (error: any) {
      console.error("Error fetching biweekly stats:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-tickets", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { propertyId, assignedTo, status, priority, category, excludeCategories, condominiumId, dateFilter, search, sortField, sortOrder, page, pageSize } = req.query;
      
      if (propertyId) {
        const tickets = await storage.getExternalMaintenanceTicketsByProperty(propertyId);
        return res.json(tickets);
      }
      
      if (assignedTo) {
        const tickets = await storage.getExternalMaintenanceTicketsByAssignee(assignedTo);
        return res.json(tickets);
      }
      
      // Get agency ID from authenticated user (admin/master can pass agencyId to view other agencies)
      let agencyId = req.query.agencyId;
      if (!agencyId) {
        agencyId = await getUserAgencyId(req);
        if (!agencyId) {
          return res.status(400).json({ message: "User is not assigned to any agency" });
        }
      }
      
      // Use paginated query when page/pageSize provided (from main page)
      const pageNum = parseInt(page as string) || 1;
      const pageSizeNum = parseInt(pageSize as string) || 10;
      const offset = (pageNum - 1) * pageSizeNum;
      
      const result = await storage.getExternalMaintenanceTicketsPaginated(agencyId, {
        limit: pageSizeNum,
        offset,
        search: search as string,
        status: status as string,
        priority: priority as string,
        category: category as string,
        excludeCategories: excludeCategories ? (excludeCategories as string).split(",") : undefined,
        condominiumId: condominiumId as string,
        dateFilter: dateFilter as string,
        sortField: sortField as string || 'createdAt',
        sortOrder: (sortOrder as 'asc' | 'desc') || 'desc',
      });
      
      const totalPages = Math.ceil(result.total / pageSizeNum);
      
      res.json({
        data: result.data,
        total: result.total,
        page: pageNum,
        pageSize: pageSizeNum,
        totalPages,
      });
    } catch (error: any) {
      console.error("Error fetching external tickets:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-tickets/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Fetch enriched ticket with joined data in a single query
      const enrichedResult = await db.execute(sql`
        SELECT 
          t.*,
          u.unit_number as "unitNumber",
          c.name as "condominiumName",
          COALESCE(NULLIF(TRIM(COALESCE(assigned_user.first_name, '') || ' ' || COALESCE(assigned_user.last_name, '')), ''), assigned_user.email) as "assignedToName",
          COALESCE(NULLIF(TRIM(COALESCE(created_user.first_name, '') || ' ' || COALESCE(created_user.last_name, '')), ''), created_user.email) as "createdByName",
          CASE WHEN t.quotation_id IS NOT NULL THEN true ELSE false END as "feeApplied",
          0.15 as "feeRate"
        FROM external_maintenance_tickets t
        LEFT JOIN external_units u ON t.unit_id = u.id
        LEFT JOIN external_condominiums c ON u.condominium_id = c.id
        LEFT JOIN users assigned_user ON t.assigned_to = assigned_user.id
        LEFT JOIN users created_user ON t.created_by = created_user.id
        WHERE t.id = ${id}
      `);
      
      if (!enrichedResult.rows || enrichedResult.rows.length === 0) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      const row = enrichedResult.rows[0] as any;
      
      // Convert snake_case to camelCase and compute base cost
      const ticket = {
        id: row.id,
        unitId: row.unit_id,
        title: row.title,
        description: row.description,
        category: row.category,
        priority: row.priority,
        status: row.status,
        reportedBy: row.reported_by,
        assignedTo: row.assigned_to,
        scheduledDate: row.scheduled_date,
        resolvedDate: row.resolved_date,
        estimatedCost: row.estimated_cost,
        actualCost: row.actual_cost,
        notes: row.notes,
        createdBy: row.created_by,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        agencyId: row.agency_id,
        quotationId: row.quotation_id,
        quotedTotal: row.quoted_total,
        quotedAdminFee: row.quoted_admin_fee,
        quotedServices: row.quoted_services,
        closureWorkNotes: row.closure_work_notes,
        invoiceDate: row.invoice_date,
        finalChargeAmount: row.final_charge_amount,
        applyAdminFee: row.apply_admin_fee,
        adminFeeAmount: row.admin_fee_amount,
        totalChargeAmount: row.total_charge_amount,
        afterWorkPhotos: row.after_work_photos,
        accountingTransactionId: row.accounting_transaction_id,
        accountingSyncStatus: row.accounting_sync_status,
        // Enriched fields
        unitNumber: row.unitNumber,
        condominiumName: row.condominiumName,
        assignedToName: row.assignedToName,
        createdByName: row.createdByName,
        feeApplied: row.feeApplied,
        feeRate: parseFloat(row.feeRate),
        sourceQuotationId: row.quotation_id,
        // Computed base cost (if fee was applied via quotation, divide by 1.15 to get original)
        baseCost: row.feeApplied && row.estimated_cost 
          ? (parseFloat(row.estimated_cost) / 1.15).toFixed(2) 
          : row.estimated_cost,
      };
      
      res.json(ticket);
    } catch (error: any) {
      console.error("Error fetching external ticket:", error);
      handleGenericError(res, error);
    }
  });
  app.post("/api/external-tickets", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalMaintenanceTicketSchema.parse(req.body);
      const ticket = await storage.createExternalMaintenanceTicket({
        ...validatedData,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_ticket", ticket.id, "Created external maintenance ticket");
      res.status(201).json(ticket);
    } catch (error: any) {
      console.error("Error creating external ticket:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-tickets/:id", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.claims?.sub || req.user?.id;
      let userRole = req.user?.role || req.session?.adminUser?.role;
      // Get role from database if not in session
      if (!userRole && userId) {
        const dbUser = await storage.getUser(userId);
        userRole = dbUser?.role;
      }
      
      // Only admins and maintenance managers can modify tickets directly
      // Regular users should use POST /updates and POST /photos endpoints
      if (!storage.canModifyMaintenanceTicket(userRole)) {
        return res.status(403).json({ 
          message: "Only administrators and maintenance managers can modify tickets. Use the updates endpoint to add comments." 
        });
      }
      
      // Verify ticket exists and belongs to user's agency
      const ticket = await storage.getExternalMaintenanceTicket(id);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      const unit = await storage.getExternalUnit(ticket.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const updatedTicket = await storage.updateExternalMaintenanceTicket(id, req.body);
      
      await createAuditLog(req, "update", "external_ticket", id, "Updated external maintenance ticket");
      res.json(updatedTicket);
    } catch (error: any) {
      console.error("Error updating external ticket:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-tickets/:id/status", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status, resolvedDate, completionNotes } = req.body;
      const userId = req.user?.claims?.sub || req.user?.id;
      let userRole = req.user?.role || req.session?.adminUser?.role;
      // Get role from database if not in session
      if (!userRole && userId) {
        const dbUser = await storage.getUser(userId);
        userRole = dbUser?.role;
      }
      
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }
      
      // Verify ticket exists and belongs to user's agency
      const ticket = await storage.getExternalMaintenanceTicket(id);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      const unit = await storage.getExternalUnit(ticket.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Only admin and maintenance managers can modify ticket status
      if (!storage.canModifyMaintenanceTicket(userRole)) {
        return res.status(403).json({ 
          message: "Only administrators and maintenance managers can modify ticket status" 
        });
      }
      
      // Prepare update data
      const updateData: any = { status };
      if (resolvedDate) {
        updateData.resolvedDate = new Date(resolvedDate);
      }
      
      // If closing, add closure metadata
      if (status === 'closed') {
        updateData.closedBy = userId;
        updateData.closedAt = new Date();
        if (completionNotes) {
          updateData.completionNotes = completionNotes;
        }
      }
      
      const updatedTicket = await storage.updateExternalMaintenanceTicket(id, updateData);
      
      // Auto-create financial transaction when closing ticket with actual cost
      // Use updated ticket data to catch newly provided actualCost
      if (status === 'closed' && updatedTicket.actualCost && parseFloat(updatedTicket.actualCost) > 0) {
        try {
          // Get owner information from the unit
          const unitOwners = await storage.getExternalUnitOwnersByUnit(ticket.unitId);
          const primaryOwner = unitOwners.find(o => o.ownershipPercentage && parseFloat(o.ownershipPercentage) > 0) || unitOwners[0];
          
          // Create financial transaction for maintenance expense
          await storage.createExternalFinancialTransaction({
            agencyId: unit.agencyId,
            direction: 'outflow',
            category: 'maintenance_expense',
            status: 'pending',
            grossAmount: updatedTicket.actualCost,
            fees: '0.00',
            netAmount: updatedTicket.actualCost,
            currency: 'MXN',
            dueDate: new Date(), // Cost incurred immediately
            payerRole: primaryOwner ? 'owner' : 'agency', // Owner pays or agency if no owner
            payeeRole: 'agency', // Agency paid the service provider
            ownerId: primaryOwner?.id || null,
            contractId: updatedTicket.contractId || null,
            unitId: updatedTicket.unitId,
            maintenanceTicketId: updatedTicket.id,
            description: `Gasto de mantenimiento: ${updatedTicket.title}`,
            notes: updatedTicket.completionNotes || undefined,
          });
          
          console.log(`✅ Auto-created financial transaction for ticket ${updatedTicket.id} with cost ${updatedTicket.actualCost}`);
        } catch (finError) {
          // Log but don't fail the ticket closure
          console.error('Failed to create financial transaction for ticket:', finError);
        }
      }
      
      await createAuditLog(req, "update", "external_ticket", id, `Changed ticket status to ${status}`);
      res.json(updatedTicket);
    } catch (error: any) {
      console.error("Error updating external ticket status:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-tickets/:id/close-with-report - Close ticket with full closure report
  app.post("/api/external-tickets/:id/close-with-report", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { 
        closureWorkNotes,
        invoiceDate,
        finalChargeAmount,
        applyAdminFee = true,
        afterWorkPhotos = [],
        completionNotes
      } = req.body;
      
      const userId = req.user?.claims?.sub || req.user?.id;
      let userRole = req.user?.role || req.session?.adminUser?.role;
      // Get role from database if not in session
      if (!userRole && userId) {
        const dbUser = await storage.getUser(userId);
        userRole = dbUser?.role;
      }
      
      // Verify ticket exists
      const ticket = await storage.getExternalMaintenanceTicket(id);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Get unit for agency verification
      const unit = await storage.getExternalUnit(ticket.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Only admin and maintenance managers can close tickets
      if (!storage.canModifyMaintenanceTicket(userRole)) {
        return res.status(403).json({ 
          message: "Only administrators and maintenance managers can close tickets" 
        });
      }
      
      // Calculate administrative fee (15%)
      const chargeAmount = parseFloat(finalChargeAmount || '0');
      const adminFeeAmount = applyAdminFee ? (chargeAmount * 0.15) : 0;
      const totalChargeAmount = chargeAmount + adminFeeAmount;
      
      // Prepare closure data
      const closureData: any = {
        status: 'closed',
        closedBy: userId,
        closedAt: new Date(),
        resolvedDate: new Date(),
        closureWorkNotes: closureWorkNotes || completionNotes,
        completionNotes: completionNotes,
        invoiceDate: invoiceDate ? new Date(invoiceDate) : new Date(),
        finalChargeAmount: chargeAmount.toFixed(2),
        applyAdminFee: applyAdminFee,
        adminFeeAmount: adminFeeAmount.toFixed(2),
        totalChargeAmount: totalChargeAmount.toFixed(2),
        afterWorkPhotos: afterWorkPhotos,
        actualCost: chargeAmount.toFixed(2),
        accountingSyncStatus: 'pending'
      };
      
      // Update ticket with closure data
      const updatedTicket = await storage.updateExternalMaintenanceTicket(id, closureData);
      
      // Create financial transaction for the charge
      let transactionId = null;
      if (totalChargeAmount > 0) {
        try {
          // Get owner information from the unit
          const unitOwners = await storage.getExternalUnitOwnersByUnit(ticket.unitId);
          const primaryOwner = unitOwners.find(o => o.ownershipPercentage && parseFloat(o.ownershipPercentage) > 0) || unitOwners[0];
          
          // Create financial transaction - charge to owner
          const transaction = await storage.createExternalFinancialTransaction({
            agencyId: unit.agencyId,
            direction: 'inflow',
            category: 'maintenance_charge',
            status: 'pending',
            grossAmount: totalChargeAmount.toFixed(2),
            fees: adminFeeAmount.toFixed(2),
            netAmount: chargeAmount.toFixed(2),
            currency: 'MXN',
            dueDate: invoiceDate ? new Date(invoiceDate) : new Date(),
            payerRole: 'owner',
            payeeRole: 'agency',
            ownerId: primaryOwner?.id || null,
            contractId: updatedTicket.contractId || null,
            unitId: updatedTicket.unitId,
            maintenanceTicketId: updatedTicket.id,
            description: updatedTicket.title,
            notes: closureWorkNotes || completionNotes || undefined,
          });
          
          transactionId = transaction.id;
          
          // Update ticket with transaction reference
          await storage.updateExternalMaintenanceTicket(id, {
            accountingTransactionId: transaction.id,
            accountingSyncStatus: 'synced'
          });
          
          console.log(`Created accounting transaction ${transaction.id} for ticket closure ${id} - Total: ${totalChargeAmount}`);
        } catch (finError) {
          console.error('Failed to create financial transaction for ticket closure:', finError);
          await storage.updateExternalMaintenanceTicket(id, {
            accountingSyncStatus: 'error'
          });
        }
      }
      
      await createAuditLog(req, "update", "external_ticket", id, `Closed ticket with report - Charge: ${totalChargeAmount} MXN`);
      
      // Get updated ticket with all changes
      const finalTicket = await storage.getExternalMaintenanceTicket(id);
      res.json({ 
        ticket: finalTicket,
        transactionId,
        message: transactionId ? 'Ticket closed and sent to accounting' : 'Ticket closed'
      });
    } catch (error: any) {
      console.error("Error closing ticket with report:", error);
      handleGenericError(res, error);
    }
  });


  app.patch("/api/external-tickets/:id/assign", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { assignedTo } = req.body;
      
      if (!assignedTo) {
        return res.status(400).json({ message: "Assigned To user ID is required" });
      }
      
      const ticket = await storage.assignExternalTicket(id, assignedTo);
      
      await createAuditLog(req, "update", "external_ticket", id, `Assigned ticket to user ${assignedTo}`);
      res.json(ticket);
    } catch (error: any) {
      console.error("Error assigning external ticket:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-tickets/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteExternalMaintenanceTicket(id);
      
      await createAuditLog(req, "delete", "external_ticket", id, "Deleted external maintenance ticket");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external ticket:", error);
      handleGenericError(res, error);
    }
  });

  // External Maintenance Updates Routes
  app.get("/api/external-tickets/:id/updates", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify ticket exists and belongs to user's agency
      const ticket = await storage.getExternalMaintenanceTicket(id);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Verify agency ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, ticket.agencyId);
      if (!hasAccess) return;
      
      const updates = await storage.getExternalMaintenanceUpdates(id);
      res.json(updates);
    } catch (error: any) {
      console.error("Error fetching external ticket updates:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-tickets/:id/updates", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.claims?.sub || req.user?.id;
      
      // Verify ticket exists and belongs to user's agency
      const ticket = await storage.getExternalMaintenanceTicket(id);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Verify agency ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, ticket.agencyId);
      if (!hasAccess) return;
      
      const validated = insertExternalMaintenanceUpdateSchema.parse({
        ...req.body,
        ticketId: id,
        createdBy: userId,
        statusSnapshot: ticket.status,
        prioritySnapshot: ticket.priority,
        assignedToSnapshot: ticket.assignedTo,
      });
      
      const update = await storage.createExternalMaintenanceUpdate(validated);
      
      await createAuditLog(req, "create", "external_ticket_update", update.id, `Created update for ticket ${id}`);
      res.status(201).json(update);
    } catch (error: any) {
      console.error("Error creating external ticket update:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      handleGenericError(res, error);
    }
  });

  // External Maintenance Photos Routes
  app.get("/api/external-tickets/:id/photos", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { phase, updateId } = req.query;
      
      // Verify ticket exists and belongs to user's agency
      const ticket = await storage.getExternalMaintenanceTicket(id);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Verify agency ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, ticket.agencyId);
      if (!hasAccess) return;
      
      const filters: any = {};
      if (phase) filters.phase = phase as string;
      if (updateId) filters.updateId = updateId as string;
      
      const photos = await storage.getExternalMaintenancePhotos(id, filters);
      res.json(photos);
    } catch (error: any) {
      console.error("Error fetching external ticket photos:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-tickets/:id/photos", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.claims?.sub || req.user?.id;
      
      // Verify ticket exists and belongs to user's agency
      const ticket = await storage.getExternalMaintenanceTicket(id);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Verify agency ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, ticket.agencyId);
      if (!hasAccess) return;
      
      const validated = insertExternalMaintenancePhotoSchema.parse({
        ...req.body,
        ticketId: id,
        uploadedBy: userId,
      });
      
      const photo = await storage.createExternalMaintenancePhoto(validated);
      
      await createAuditLog(req, "create", "external_ticket_photo", photo.id, `Uploaded photo for ticket ${id}`);
      res.status(201).json(photo);
    } catch (error: any) {
      console.error("Error creating external ticket photo:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-maintenance-photos/:id", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify photo exists and belongs to user's agency
      const photo = await storage.getExternalMaintenancePhoto(id);
      if (!photo) {
        return res.status(404).json({ message: "Photo not found" });
      }
      
      // Verify ticket ownership through photo
      const ticket = await storage.getExternalMaintenanceTicket(photo.ticketId);
      if (!ticket) {
        return res.status(404).json({ message: "Associated ticket not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, ticket.agencyId);
      if (!hasAccess) return;
      
      // Validate only phase and caption can be updated
      const updateSchema = z.object({
        phase: z.enum(["before", "during", "after", "other"]).optional(),
        caption: z.string().optional(),
      });
      
      const validated = updateSchema.parse(req.body);
      const updatedPhoto = await storage.updateExternalMaintenancePhoto(id, validated);
      
      await createAuditLog(req, "update", "external_ticket_photo", id, `Updated maintenance photo`);
      res.json(updatedPhoto);
    } catch (error: any) {
      console.error("Error updating external maintenance photo:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-maintenance-photos/:id", isAuthenticated, requireRole(EXTERNAL_MAINTENANCE_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      await storage.deleteExternalMaintenancePhoto(id);
      
      await createAuditLog(req, "delete", "external_ticket_photo", id, "Deleted maintenance photo");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external maintenance photo:", error);
      handleGenericError(res, error);
    }
  });


  // External Dashboard Summary - optimized endpoint for dashboard statistics
  app.get("/api/external-dashboard-summary", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      let agencyId = req.query.agencyId;
      if (!agencyId) {
        agencyId = await getUserAgencyId(req);
        if (!agencyId) {
          return res.status(400).json({ message: "User is not assigned to any agency" });
        }
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, agencyId);
      if (!hasAccess) return;
      
      const summary = await storage.getExternalDashboardSummary(agencyId);
      res.json(summary);
    } catch (error: any) {
      console.error("Error fetching dashboard summary:", error);
      handleGenericError(res, error);
    }
  });

  // Seller Dashboard Summary - optimized endpoint for seller-specific statistics
  app.get("/api/external-dashboard/seller-summary", isAuthenticated, requireRole(['external_agency_seller', 'master', 'admin']), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      // Get today's date boundaries
      const today = new Date();
      const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);
      const next7Days = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 7);

      // Parallel queries for seller statistics
      const [
        totalLeads,
        leadsByStatus,
        todayShowings,
        upcomingShowings,
        recentActivities,
        convertedLeads,
        thisMonthLeads
      ] = await Promise.all([
        // Total leads assigned to this seller
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeads)
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId)
          ))
          .then(r => r[0]?.count || 0),
        
        // Leads by status
        db.select({
          status: externalLeads.status,
          count: sql<number>`count(*)::int`
        })
          .from(externalLeads)
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId)
          ))
          .groupBy(externalLeads.status)
          .then(rows => {
            const statusCounts: Record<string, number> = {};
            rows.forEach(r => { statusCounts[r.status] = r.count; });
            return statusCounts;
          }),
        
        // Today's showings
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeadShowings)
          .innerJoin(externalLeads, eq(externalLeadShowings.leadId, externalLeads.id))
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeadShowings.scheduledAt} >= ${startOfDay}`,
            sql`${externalLeadShowings.scheduledAt} < ${endOfDay}`
          ))
          .then(r => r[0]?.count || 0),
        
        // Upcoming showings (next 7 days)
        db.select({
          id: externalLeadShowings.id,
          scheduledAt: externalLeadShowings.scheduledAt,
          status: externalLeadShowings.status,
          leadName: sql<string>`concat(${externalLeads.firstName}, ' ', ${externalLeads.lastName})`,
          propertyName: externalLeadShowings.propertyName,
        })
          .from(externalLeadShowings)
          .innerJoin(externalLeads, eq(externalLeadShowings.leadId, externalLeads.id))
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeadShowings.scheduledAt} >= ${startOfDay}`,
            sql`${externalLeadShowings.scheduledAt} < ${next7Days}`,
            eq(externalLeadShowings.status, 'scheduled')
          ))
          .orderBy(asc(externalLeadShowings.scheduledAt))
          .limit(10),
        
        // Recent activities (last 10)
        db.select({
          id: externalLeadActivities.id,
          activityType: externalLeadActivities.activityType,
          description: externalLeadActivities.description,
          createdAt: externalLeadActivities.createdAt,
          leadName: sql<string>`concat(${externalLeads.firstName}, ' ', ${externalLeads.lastName})`,
        })
          .from(externalLeadActivities)
          .innerJoin(externalLeads, eq(externalLeadActivities.leadId, externalLeads.id))
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId)
          ))
          .orderBy(desc(externalLeadActivities.createdAt))
          .limit(10),
        
        // Converted leads (with convertedToClientId not null)
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeads)
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            isNotNull(externalLeads.convertedToClientId)
          ))
          .then(r => r[0]?.count || 0),
        
        // Leads this month
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeads)
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeads.createdAt} >= ${new Date(today.getFullYear(), today.getMonth(), 1)}`
          ))
          .then(r => r[0]?.count || 0),
      ]);

      // Calculate conversion rate
      const conversionRate = totalLeads > 0 ? Math.round((convertedLeads / totalLeads) * 100) : 0;

      res.json({
        totalLeads,
        leadsByStatus,
        todayShowings,
        upcomingShowings,
        recentActivities,
        convertedLeads,
        thisMonthLeads,
        conversionRate,
      });
    } catch (error: any) {
      console.error("Error fetching seller dashboard summary:", error);
      handleGenericError(res, error);
    }
  });

  // Seller Activity Reports - statistics on activities, showings, and conversions
  app.get("/api/external-dashboard/seller-reports", isAuthenticated, requireRole(['external_agency_seller', 'master', 'admin']), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { period = 'week' } = req.query;
      
      // Calculate date range based on period
      const today = new Date();
      let startDate: Date;
      
      switch (period) {
        case 'today':
          startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
          break;
        case 'month':
          startDate = new Date(today.getFullYear(), today.getMonth(), 1);
          break;
        case 'week':
        default:
          startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
          break;
      }

      const [
        activitiesByType,
        showingsByOutcome,
        leadsContacted,
        leadsConverted
      ] = await Promise.all([
        // Activities by type
        db.select({
          activityType: externalLeadActivities.activityType,
          count: sql<number>`count(*)::int`
        })
          .from(externalLeadActivities)
          .innerJoin(externalLeads, eq(externalLeadActivities.leadId, externalLeads.id))
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeadActivities.createdAt} >= ${startDate}`
          ))
          .groupBy(externalLeadActivities.type)
          .then(rows => {
            const counts: Record<string, number> = {};
            rows.forEach(r => { counts[r.type] = r.count || 0; });
            return counts;
          }),
        
        // Showings by outcome
        db.select({
          outcome: externalLeadShowings.outcome,
          count: sql<number>`count(*)::int`
        })
          .from(externalLeadShowings)
          .innerJoin(externalLeads, eq(externalLeadShowings.leadId, externalLeads.id))
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeadShowings.scheduledAt} >= ${startDate}`,
            isNotNull(externalLeadShowings.outcome)
          ))
          .groupBy(externalLeadShowings.outcome)
          .then(rows => {
            const counts: Record<string, number> = {};
            rows.forEach(r => { 
              if (r.outcome) counts[r.outcome] = r.count || 0; 
            });
            return counts;
          }),
        
        // Unique leads contacted (with at least one activity)
        db.selectDistinct({ leadId: externalLeadActivities.leadId })
          .from(externalLeadActivities)
          .innerJoin(externalLeads, eq(externalLeadActivities.leadId, externalLeads.id))
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeadActivities.createdAt} >= ${startDate}`
          ))
          .then(r => r.length),
        
        // Leads converted in period
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeads)
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            isNotNull(externalLeads.convertedToClientId),
            sql`${externalLeads.updatedAt} >= ${startDate}`
          ))
          .then(r => r[0]?.count || 0),
      ]);

      // Calculate totals
      const totalActivities = Object.values(activitiesByType).reduce((sum, count) => sum + count, 0);
      const totalShowings = Object.values(showingsByOutcome).reduce((sum, count) => sum + count, 0);
      const conversionRate = leadsContacted > 0 
        ? Math.round((leadsConverted / leadsContacted) * 100) 
        : 0;

      res.json({
        period,
        totalActivities,
        activitiesByType,
        totalShowings,
        showingsByOutcome,
        leadsContacted,
        leadsConverted,
        conversionRate,
        dailyActivity: [],
      });
    } catch (error: any) {
      console.error("Error fetching seller reports:", error);
      handleGenericError(res, error);
    }
  });

  // Seller Goals - active goals and achievement tracking
  app.get("/api/external-dashboard/seller-goals", isAuthenticated, requireRole(['external_agency_seller', 'master', 'admin']), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      // For now, return a placeholder structure since goals table may not exist
      const today = new Date();
      const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
      const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

      // Calculate current stats for default goals
      const [totalLeads, convertedLeads, totalShowings] = await Promise.all([
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeads)
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeads.createdAt} >= ${startOfMonth}`
          ))
          .then(r => r[0]?.count || 0),
        
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeads)
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            isNotNull(externalLeads.convertedToClientId),
            sql`${externalLeads.updatedAt} >= ${startOfMonth}`
          ))
          .then(r => r[0]?.count || 0),
        
        db.select({ count: sql<number>`count(*)::int` })
          .from(externalLeadShowings)
          .innerJoin(externalLeads, eq(externalLeadShowings.leadId, externalLeads.id))
          .where(and(
            eq(externalLeads.agencyId, agencyId),
            eq(externalLeads.sellerId, userId),
            sql`${externalLeadShowings.scheduledAt} >= ${startOfMonth}`
          ))
          .then(r => r[0]?.count || 0),
      ]);

      // Default goals based on typical sales targets - using translation keys
      const activeGoals = [
        {
          id: 'default-leads',
          nameKey: 'goals.monthlyLeadAcquisition',
          descriptionKey: 'goals.monthlyLeadAcquisitionDesc',
          type: 'leads',
          target: 20,
          current: totalLeads,
          period: 'monthly',
          startDate: startOfMonth.toISOString(),
          endDate: endOfMonth.toISOString(),
        },
        {
          id: 'default-conversions',
          nameKey: 'goals.monthlyConversions',
          descriptionKey: 'goals.monthlyConversionsDesc',
          type: 'conversions',
          target: 5,
          current: convertedLeads,
          period: 'monthly',
          startDate: startOfMonth.toISOString(),
          endDate: endOfMonth.toISOString(),
        },
        {
          id: 'default-showings',
          nameKey: 'goals.monthlyShowings',
          descriptionKey: 'goals.monthlyShowingsDesc',
          type: 'showings',
          target: 15,
          current: totalShowings,
          period: 'monthly',
          startDate: startOfMonth.toISOString(),
          endDate: endOfMonth.toISOString(),
        },
      ];

      const achievedCount = activeGoals.filter(g => g.current >= g.target).length;

      res.json({
        activeGoals,
        achievedCount,
        totalPoints: achievedCount * 100,
        rank: 0,
      });
    } catch (error: any) {
      console.error("Error fetching seller goals:", error);
      handleGenericError(res, error);
    }
  });

  // External Condominiums Routes

  // ============================================
  // ADMIN SELLER GOALS CRUD ENDPOINTS
  // ============================================

  // GET /api/admin/seller-goals - List all goals for the agency
  app.get("/api/admin/seller-goals", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const goals = await db.select()
        .from(sellerGoals)
        .where(eq(sellerGoals.agencyId, agencyId))
        .orderBy(desc(sellerGoals.createdAt));

      res.json(goals);
    } catch (error: any) {
      console.error("Error fetching seller goals:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/admin/seller-goals - Create a new goal
  app.post("/api/admin/seller-goals", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const validation = insertSellerGoalSchema.safeParse({
        ...req.body,
        agencyId,
        createdBy: req.user.id,
      });

      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid goal data", 
          errors: validation.error.errors 
        });
      }

      const [newGoal] = await db.insert(sellerGoals)
        .values(validation.data)
        .returning();

      res.status(201).json(newGoal);
    } catch (error: any) {
      console.error("Error creating seller goal:", error);
      handleGenericError(res, error);
    }
  });

  // PUT /api/admin/seller-goals/:id - Update a goal
  app.put("/api/admin/seller-goals/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { id } = req.params;

      // Check goal exists and belongs to agency
      const existingGoal = await db.select()
        .from(sellerGoals)
        .where(and(
          eq(sellerGoals.id, id),
          eq(sellerGoals.agencyId, agencyId)
        ))
        .then(r => r[0]);

      if (!existingGoal) {
        return res.status(404).json({ message: "Goal not found" });
      }

      const [updatedGoal] = await db.update(sellerGoals)
        .set({
          ...req.body,
          updatedAt: new Date(),
        })
        .where(eq(sellerGoals.id, id))
        .returning();

      res.json(updatedGoal);
    } catch (error: any) {
      console.error("Error updating seller goal:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/admin/seller-goals/:id - Delete a goal
  app.delete("/api/admin/seller-goals/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { id } = req.params;

      // Check goal exists and belongs to agency
      const existingGoal = await db.select()
        .from(sellerGoals)
        .where(and(
          eq(sellerGoals.id, id),
          eq(sellerGoals.agencyId, agencyId)
        ))
        .then(r => r[0]);

      if (!existingGoal) {
        return res.status(404).json({ message: "Goal not found" });
      }

      await db.delete(sellerGoals)
        .where(eq(sellerGoals.id, id));

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting seller goal:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/admin/seller-goals/:id - Get a specific goal
  app.get("/api/admin/seller-goals/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { id } = req.params;

      const goal = await db.select()
        .from(sellerGoals)
        .where(and(
          eq(sellerGoals.id, id),
          eq(sellerGoals.agencyId, agencyId)
        ))
        .then(r => r[0]);

      if (!goal) {
        return res.status(404).json({ message: "Goal not found" });
      }

      res.json(goal);
    } catch (error: any) {
      console.error("Error fetching seller goal:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/admin/sellers-for-goals - Get list of sellers for goal assignment
  app.get("/api/admin/sellers-for-goals", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const sellers = await db.select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        email: users.email,
      })
        .from(users)
        .where(and(
          eq(users.agencyId, agencyId),
          eq(users.role, 'external_agency_seller')
        ))
        .orderBy(users.firstName, users.lastName);

      res.json(sellers);
    } catch (error: any) {
      console.error("Error fetching sellers for goals:", error);
      handleGenericError(res, error);
    }
  });

  // ============================================
  // SELLER WORKSPACE ENDPOINTS
  // ============================================

  // GET /api/external-seller/property-catalog - Property catalog with filters for sellers
  app.get("/api/external-seller/property-catalog", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { 
        minPrice, maxPrice, 
        bedrooms, 
        zone, 
        propertyType,
        status = 'active',
        search,
        limit = '50', 
        offset = '0' 
      } = req.query;

      const conditions: any[] = [
        eq(externalUnits.agencyId, agencyId),
      ];

      if (status) {
        conditions.push(eq(externalUnits.isActive, status === 'active'));
      }

      if (minPrice) {
        conditions.push(gte(externalUnits.price, parseInt(minPrice as string)));
      }
      if (maxPrice) {
        conditions.push(lte(externalUnits.price, parseInt(maxPrice as string)));
      }
      if (bedrooms) {
        conditions.push(eq(externalUnits.bedrooms, parseInt(bedrooms as string)));
      }
      if (zone) {
        conditions.push(ilike(externalUnits.zone, '%' + (zone as string) + '%'));
      }
      if (propertyType) {
        conditions.push(eq(externalUnits.propertyType, propertyType as string));
      }
      if (search) {
        conditions.push(or(
          ilike(externalUnits.title, '%' + (search as string) + '%'),
          ilike(externalUnits.zone, '%' + (search as string) + '%'),
          ilike(externalUnits.propertyType, '%' + (search as string) + '%')
        ));
      }

      const [units, totalResult] = await Promise.all([
        db.select({
          id: externalUnits.id,
          name: externalUnits.title,
          unitNumber: externalUnits.unitNumber,
          zone: externalUnits.zone,
          unitType: externalUnits.propertyType,
          bedrooms: externalUnits.bedrooms,
          bathrooms: externalUnits.bathrooms,
          monthlyRent: externalUnits.price,
          currency: externalUnits.currency,
          isActive: externalUnits.isActive,
          images: externalUnits.primaryImages,
          amenities: externalUnits.amenities,
          condominiumId: externalUnits.condominiumId,
          condominiumName: externalCondominiums.name,
          squareMeters: externalUnits.area,
          description: externalUnits.description,
          petsAllowed: externalUnits.petFriendly,
        })
          .from(externalUnits)
          .leftJoin(externalCondominiums, eq(externalUnits.condominiumId, externalCondominiums.id))
          .where(and(...conditions))
          .orderBy(desc(externalUnits.createdAt))
          .limit(parseInt(limit as string))
          .offset(parseInt(offset as string)),
        db.select({ count: sql<number>`count(*)` })
          .from(externalUnits)
          .where(and(...conditions))
      ]);

      res.json({
        data: units,
        total: totalResult[0]?.count || 0,
        limit: parseInt(limit as string),
        offset: parseInt(offset as string),
      });
    } catch (error: any) {
      console.error("Error fetching property catalog:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/my-leads - Get leads assigned to current seller with search preferences
  app.get("/api/external-seller/my-leads", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const sellerId = req.user?.id;
      if (!sellerId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { limit = '50', offset = '0', status } = req.query;

      const conditions: any[] = [
        eq(externalLeads.agencyId, agencyId),
        eq(externalLeads.sellerId, sellerId),
        ne(externalLeads.status, 'proceso_renta'),
      ];

      if (status) {
        conditions.push(eq(externalLeads.status, status as string));
      }

      const leads = await db.select({
        id: externalLeads.id,
        firstName: externalLeads.firstName,
        lastName: externalLeads.lastName,
        phone: externalLeads.phone,
        email: externalLeads.email,
        status: externalLeads.status,
        estimatedRentCost: externalLeads.estimatedRentCost,
        estimatedRentCostText: externalLeads.estimatedRentCostText,
        bedrooms: externalLeads.bedrooms,
        bedroomsText: externalLeads.bedroomsText,
        desiredUnitType: externalLeads.desiredUnitType,
        desiredNeighborhood: externalLeads.desiredNeighborhood,
        contractDuration: externalLeads.contractDuration,
        hasPets: externalLeads.hasPets,
      })
        .from(externalLeads)
        .where(and(...conditions))
        .orderBy(desc(externalLeads.createdAt))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));

      res.json({ data: leads });
    } catch (error: any) {
      console.error("Error fetching seller leads:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-seller/share-property - Share property with lead and log it
  app.post("/api/external-seller/share-property", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { leadId, unitId, propertyId, channel = 'whatsapp', templateId, message } = req.body;

      if (!leadId || (!unitId && !propertyId)) {
        return res.status(400).json({ message: "Lead ID and Unit/Property ID are required" });
      }

      // Create the property offer record
      const [offer] = await db.insert(externalLeadPropertyOffers).values({
        agencyId,
        leadId,
        unitId: unitId || null,
        propertyId: propertyId || null,
        sellerId: req.user.id,
        channel,
        templateId: templateId || null,
        message,
      }).returning();

      // Get lead and unit details for WhatsApp message
      const [lead] = await db.select().from(externalLeads).where(eq(externalLeads.id, leadId));
      let unit = null;
      let condominium = null;
      if (unitId) {
        [unit] = await db.select().from(externalUnits).where(eq(externalUnits.id, unitId));
        if (unit?.condominiumId) {
          [condominium] = await db.select().from(externalCondominiums).where(eq(externalCondominiums.id, unit.condominiumId));
        }
      }

      // Generate WhatsApp link
      let whatsappMessage = message;
      if (!whatsappMessage && unit) {
        whatsappMessage = `Hola ${lead?.firstName || ''}! Te comparto esta propiedad que puede interesarte:\n\n` +
          `${unit.name}\n` +
          `${unit.unitType || 'Propiedad'} - ${unit.bedrooms || 0} recámaras\n` +
          `${unit.monthlyRent?.toLocaleString() || 'Consultar'} ${unit.currency || 'MXN'}/mes\n` +
          `${unit.zone || ''}\n\n` +
          `¿Te gustaría agendar una visita?`;
      }

      const phone = lead?.phone?.replace(/\D/g, '') || '';
      const whatsappUrl = `https://wa.me/${phone}?text=${encodeURIComponent(whatsappMessage || '')}`;

      // Get seller info and log activity AFTER share operation completes successfully
      const sellerUserId = req.user.claims?.sub || req.user.id;
      const [sellerUser] = await db.select().from(users).where(eq(users.id, sellerUserId)).limit(1);
      const sellerName = sellerUser?.firstName && sellerUser?.lastName 
        ? `${sellerUser.firstName} ${sellerUser.lastName}`
        : sellerUser?.username || 'Vendedor';

      // Create activity record AFTER all operations succeed
      const activityType = channel === 'email' ? 'email' : 'whatsapp';
      const propertyInfo = unit 
        ? `${condominium?.name || ''} ${unit.unitNumber || unit.name || 'Unidad'}`.trim()
        : 'Propiedad';
      const priceInfo = unit?.monthlyRent ? ` - ${Number(unit.monthlyRent).toLocaleString()} ${unit.currency || 'MXN'}/mes` : '';
      
      await db.insert(externalLeadActivities).values({
        leadId,
        agencyId,
        activityType: activityType as any,
        title: `Propiedad compartida: ${propertyInfo}`,
        description: `${sellerName} compartió la propiedad ${propertyInfo}${priceInfo} vía ${channel === 'whatsapp' ? 'WhatsApp' : channel === 'email' ? 'Email' : channel}`,
        relatedPropertyId: propertyId || null,
        relatedUnitId: unitId || null,
        createdBy: sellerUserId,
        completedAt: new Date(),
        outcome: 'pending',
      });

      res.json({
        success: true,
        offer,
        whatsappUrl,
        message: whatsappMessage,
      });
    } catch (error: any) {
      console.error("Error sharing property:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/lead/:leadId/property-offers - Get property offers history for a lead
  app.get("/api/external-seller/lead/:leadId/property-offers", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { leadId } = req.params;

      const offers = await db.select({
        id: externalLeadPropertyOffers.id,
        unitId: externalLeadPropertyOffers.unitId,
        propertyId: externalLeadPropertyOffers.propertyId,
        channel: externalLeadPropertyOffers.channel,
        message: externalLeadPropertyOffers.message,
        isViewed: externalLeadPropertyOffers.isViewed,
        isInterested: externalLeadPropertyOffers.isInterested,
        sentAt: externalLeadPropertyOffers.sentAt,
        unitName: externalUnits.title,
        unitZone: externalUnits.zone,
        unitType: externalUnits.propertyType,
        unitPrice: externalUnits.monthlyRent,
        sellerName: users.name,
      })
        .from(externalLeadPropertyOffers)
        .leftJoin(externalUnits, eq(externalLeadPropertyOffers.unitId, externalUnits.id))
        .leftJoin(users, eq(externalLeadPropertyOffers.sellerId, users.id))
        .where(and(
          eq(externalLeadPropertyOffers.agencyId, agencyId),
          eq(externalLeadPropertyOffers.leadId, leadId)
        ))
        .orderBy(desc(externalLeadPropertyOffers.sentAt));

      res.json(offers);
    } catch (error: any) {
      console.error("Error fetching lead property offers:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/templates - Get seller message templates
  app.get("/api/external-seller/templates", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const templates = await db.select()
        .from(sellerMessageTemplates)
        .where(and(
          eq(sellerMessageTemplates.agencyId, agencyId),
          eq(sellerMessageTemplates.isActive, true),
          or(
            isNull(sellerMessageTemplates.sellerId),
            eq(sellerMessageTemplates.sellerId, req.user.id)
          )
        ))
        .orderBy(sellerMessageTemplates.templateType, sellerMessageTemplates.title);

      res.json(templates);
    } catch (error: any) {
      console.error("Error fetching templates:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-seller/templates - Create a new template
  app.post("/api/external-seller/templates", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { templateType, title, body, isDefault } = req.body;

      if (!templateType || !title || !body) {
        return res.status(400).json({ message: "Template type, title, and body are required" });
      }

      // If setting as default, unset other defaults of same type
      if (isDefault) {
        await db.update(sellerMessageTemplates)
          .set({ isDefault: false })
          .where(and(
            eq(sellerMessageTemplates.agencyId, agencyId),
            eq(sellerMessageTemplates.templateType, templateType),
            or(
              isNull(sellerMessageTemplates.sellerId),
              eq(sellerMessageTemplates.sellerId, req.user.id)
            )
          ));
      }

      const [template] = await db.insert(sellerMessageTemplates).values({
        agencyId,
        sellerId: req.user.id,
        templateType,
        title,
        body,
        isDefault: isDefault || false,
      }).returning();

      res.status(201).json(template);
    } catch (error: any) {
      console.error("Error creating template:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-seller/templates/:id - Update a template
  app.patch("/api/external-seller/templates/:id", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { id } = req.params;
      const { title, body, isDefault, isActive } = req.body;

      // Verify ownership
      const [existing] = await db.select().from(sellerMessageTemplates)
        .where(and(
          eq(sellerMessageTemplates.id, id),
          eq(sellerMessageTemplates.agencyId, agencyId)
        ));

      if (!existing) {
        return res.status(404).json({ message: "Template not found" });
      }

      // Only allow editing own templates or shared templates if admin
      if (existing.sellerId && existing.sellerId !== req.user.id) {
        return res.status(403).json({ message: "Cannot edit other seller's templates" });
      }

      const updates: any = { updatedAt: new Date() };
      if (title !== undefined) updates.title = title;
      if (body !== undefined) updates.body = body;
      if (isActive !== undefined) updates.isActive = isActive;

      if (isDefault !== undefined) {
        if (isDefault) {
          await db.update(sellerMessageTemplates)
            .set({ isDefault: false })
            .where(and(
              eq(sellerMessageTemplates.agencyId, agencyId),
              eq(sellerMessageTemplates.templateType, existing.templateType),
              or(
                isNull(sellerMessageTemplates.sellerId),
                eq(sellerMessageTemplates.sellerId, req.user.id)
              )
            ));
        }
        updates.isDefault = isDefault;
      }

      const [updated] = await db.update(sellerMessageTemplates)
        .set(updates)
        .where(eq(sellerMessageTemplates.id, id))
        .returning();

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating template:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-seller/templates/:id - Delete a template
  app.delete("/api/external-seller/templates/:id", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { id } = req.params;

      // Verify ownership
      const [existing] = await db.select().from(sellerMessageTemplates)
        .where(and(
          eq(sellerMessageTemplates.id, id),
          eq(sellerMessageTemplates.agencyId, agencyId)
        ));

      if (!existing) {
        return res.status(404).json({ message: "Template not found" });
      }

      if (existing.sellerId && existing.sellerId !== req.user.id) {
        return res.status(403).json({ message: "Cannot delete other seller's templates" });
      }

      await db.delete(sellerMessageTemplates).where(eq(sellerMessageTemplates.id, id));

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error deleting template:", error);
      handleGenericError(res, error);
    }
  });



  // Helper function to seed default templates for an agency
  async function seedDefaultTemplatesForSeller(agencyId: string): Promise<number> {
    const defaultTemplates = [
      // Property Share Templates
      {
        templateType: "property_share",
        title: "Propiedad Destacada",
        body: `¡Hola {{nombre}}! 

Te comparto esta excelente propiedad que coincide con lo que buscas:

*{{propiedad}}*
{{zona}}
${{precio}} MXN/mes
{{recamaras}} recámaras

Ver propiedad: {{link}}

¿Te gustaría agendar una visita? Estoy a tus órdenes.

Saludos,
{{vendedor}}`,
        isDefault: true,
      },
      {
        templateType: "property_share",
        title: "Múltiples Opciones",
        body: `¡Hola {{nombre}}!

Basándome en tus preferencias, encontré esta propiedad que podría interesarte:

*{{propiedad}}*
Ubicación: {{zona}}
Renta: ${{precio}} MXN mensuales
Habitaciones: {{recamaras}}

Ver detalles: {{link}}

Tengo más opciones similares si esta no te convence. ¿Qué te parece?

{{vendedor}}`,
        isDefault: false,
      },
      {
        templateType: "property_share",
        title: "Oportunidad Rápida",
        body: `{{nombre}}, ¡buenas noticias! 

Acaba de entrar esta propiedad al mercado:

*{{propiedad}}* en {{zona}}
Precio: ${{precio}}/mes | {{recamaras}} recámaras

{{link}}

Las propiedades en esta zona se rentan rápido. ¿Cuándo puedes verla?

{{vendedor}}`,
        isDefault: false,
      },
      // Follow-up Templates
      {
        templateType: "follow_up",
        title: "Seguimiento General",
        body: `¡Hola {{nombre}}! 

Quería dar seguimiento a tu búsqueda de departamento. ¿Has tenido oportunidad de revisar las opciones que te compartí?

Quedo atento a tus comentarios.

{{vendedor}}`,
        isDefault: true,
      },
      {
        templateType: "follow_up",
        title: "Post-Visita",
        body: `¡Hola {{nombre}}!

Espero que estés muy bien. ¿Qué te pareció la propiedad que visitamos? 

Me encantaría conocer tus impresiones y si necesitas más información para tomar tu decisión.

Saludos,
{{vendedor}}`,
        isDefault: false,
      },
      {
        templateType: "follow_up",
        title: "Recordatorio Amigable",
        body: `{{nombre}}, ¡espero que todo marche bien! 

No he sabido de ti desde nuestra última conversación. ¿Sigues buscando propiedad? Tengo nuevas opciones que podrían gustarte.

Cuando tengas un momento, platiquemos.

{{vendedor}}`,
        isDefault: false,
      },
      // Initial Contact Templates
      {
        templateType: "initial_contact",
        title: "Bienvenida",
        body: `¡Hola {{nombre}}! 

Gracias por tu interés en nuestras propiedades. Soy {{vendedor}} y te ayudaré a encontrar el lugar perfecto para ti.

Para poder enviarte las mejores opciones, ¿podrías confirmarme:
- Zona de preferencia
- Presupuesto aproximado
- Número de recámaras que necesitas

¡Estoy a tus órdenes!`,
        isDefault: true,
      },
      {
        templateType: "initial_contact",
        title: "Respuesta a Consulta",
        body: `¡Hola {{nombre}}!

Recibí tu consulta y con gusto te ayudo. Tenemos varias opciones que podrían interesarte.

¿Tienes disponibilidad esta semana para platicar sobre lo que buscas? Así puedo enviarte propiedades que realmente se ajusten a tus necesidades.

Saludos,
{{vendedor}}`,
        isDefault: false,
      },
      // Appointment Templates
      {
        templateType: "appointment",
        title: "Confirmación de Cita",
        body: `¡Hola {{nombre}}!

Te confirmo nuestra cita para visitar:

*{{propiedad}}*
{{zona}}

Por favor llega 10 minutos antes. Si necesitas reagendar, avísame con anticipación.

Te espero,
{{vendedor}}`,
        isDefault: true,
      },
      {
        templateType: "appointment",
        title: "Recordatorio de Visita",
        body: `{{nombre}}, te recuerdo que mañana tenemos cita para visitar {{propiedad}}.

Te espero puntual. Si tienes algún contratiempo, por favor avísame.

{{vendedor}}`,
        isDefault: false,
      },
      // Closing Templates
      {
        templateType: "closing",
        title: "Cierre Exitoso",
        body: `¡Felicidades {{nombre}}! 

Muchas gracias por confiar en nosotros para encontrar tu nuevo hogar. Fue un placer ayudarte.

Si en el futuro necesitas algo más, no dudes en contactarme.

¡Te deseo lo mejor!
{{vendedor}}`,
        isDefault: true,
      },
      // General Templates
      {
        templateType: "general",
        title: "Información Adicional",
        body: `{{nombre}}, aquí te comparto información adicional sobre la propiedad que te interesó:

*{{propiedad}}*
{{zona}}
${{precio}}/mes

¿Tienes alguna otra pregunta? Con gusto te ayudo.

{{vendedor}}`,
        isDefault: false,
      },
    ];

    let createdCount = 0;
    for (const template of defaultTemplates) {
      try {
        const [existing] = await db.select().from(sellerMessageTemplates)
          .where(and(
            eq(sellerMessageTemplates.agencyId, agencyId),
            eq(sellerMessageTemplates.title, template.title),
            eq(sellerMessageTemplates.templateType, template.templateType as any),
            isNull(sellerMessageTemplates.sellerId)
          ));

        if (!existing) {
          await db.insert(sellerMessageTemplates).values({
            agencyId,
            sellerId: null,
            templateType: template.templateType as any,
            title: template.title,
            body: template.body,
            isDefault: template.isDefault,
          });
          createdCount++;
        }
      } catch (err) {
        console.error(`Error creating template ${template.title}:`, err);
      }
    }
    return createdCount;
  }


  // POST /api/external-seller/templates/seed-defaults - Create default templates for agency
  app.post("/api/external-seller/templates/seed-defaults", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      // Default templates for different use cases
      const defaultTemplates = [
        // Property Share Templates
        {
          templateType: "property_share",
          title: "Propiedad Destacada",
          body: `¡Hola {{nombre}}! 

Te comparto esta excelente propiedad que coincide con lo que buscas:

*{{propiedad}}*
{{zona}}
${{precio}} MXN/mes
{{recamaras}} recámaras

¿Te gustaría agendar una visita? Estoy a tus órdenes.

Saludos,
{{vendedor}}`,
          isDefault: true,
        },
        {
          templateType: "property_share",
          title: "Múltiples Opciones",
          body: `¡Hola {{nombre}}!

Basándome en tus preferencias, encontré esta propiedad que podría interesarte:

*{{propiedad}}*
Ubicación: {{zona}}
Renta: ${{precio}} MXN mensuales
Habitaciones: {{recamaras}}

Tengo más opciones similares si esta no te convence. ¿Qué te parece?

{{vendedor}}`,
          isDefault: false,
        },
        {
          templateType: "property_share",
          title: "Oportunidad Rápida",
          body: `{{nombre}}, ¡buenas noticias! 

Acaba de entrar esta propiedad al mercado:

*{{propiedad}}* en {{zona}}
Precio: ${{precio}}/mes | {{recamaras}} recámaras

Las propiedades en esta zona se rentan rápido. ¿Cuándo puedes verla?

{{vendedor}}`,
          isDefault: false,
        },
        // Follow-up Templates
        {
          templateType: "follow_up",
          title: "Seguimiento General",
          body: `¡Hola {{nombre}}! 

Quería dar seguimiento a tu búsqueda de departamento. ¿Has tenido oportunidad de revisar las opciones que te compartí?

Quedo atento a tus comentarios.

{{vendedor}}`,
          isDefault: true,
        },
        {
          templateType: "follow_up",
          title: "Post-Visita",
          body: `¡Hola {{nombre}}!

Espero que estés muy bien. ¿Qué te pareció la propiedad que visitamos? 

Me encantaría conocer tus impresiones y si necesitas más información para tomar tu decisión.

Saludos,
{{vendedor}}`,
          isDefault: false,
        },
        {
          templateType: "follow_up",
          title: "Recordatorio Amigable",
          body: `{{nombre}}, ¡espero que todo marche bien! 

No he sabido de ti desde nuestra última conversación. ¿Sigues buscando propiedad? Tengo nuevas opciones que podrían gustarte.

Cuando tengas un momento, platiquemos.

{{vendedor}}`,
          isDefault: false,
        },
        // Initial Contact Templates
        {
          templateType: "initial_contact",
          title: "Bienvenida",
          body: `¡Hola {{nombre}}! 

Gracias por tu interés en nuestras propiedades. Soy {{vendedor}} y te ayudaré a encontrar el lugar perfecto para ti.

Para poder enviarte las mejores opciones, ¿podrías confirmarme:
- Zona de preferencia
- Presupuesto aproximado
- Número de recámaras que necesitas

¡Estoy a tus órdenes!`,
          isDefault: true,
        },
        {
          templateType: "initial_contact",
          title: "Respuesta a Consulta",
          body: `¡Hola {{nombre}}!

Recibí tu consulta y con gusto te ayudo. Tenemos varias opciones que podrían interesarte.

¿Tienes disponibilidad esta semana para platicar sobre lo que buscas? Así puedo enviarte propiedades que realmente se ajusten a tus necesidades.

Saludos,
{{vendedor}}`,
          isDefault: false,
        },
        // Appointment Templates
        {
          templateType: "appointment",
          title: "Confirmación de Cita",
          body: `¡Hola {{nombre}}!

Te confirmo nuestra cita para visitar:

*{{propiedad}}*
{{zona}}

¿Podrías confirmarme la hora que te acomoda? Estoy disponible por la mañana o tarde.

{{vendedor}}`,
          isDefault: true,
        },
        {
          templateType: "appointment",
          title: "Recordatorio de Visita",
          body: `{{nombre}}, ¡te recuerdo nuestra cita de hoy!

Visitaremos: *{{propiedad}}*
Ubicación: {{zona}}

Si necesitas reagendar o tienes alguna pregunta, avísame con tiempo.

¡Nos vemos pronto!
{{vendedor}}`,
          isDefault: false,
        },
        // General Templates
        {
          templateType: "general",
          title: "Agradecimiento",
          body: `¡Hola {{nombre}}!

Muchas gracias por confiar en nosotros para encontrar tu nuevo hogar. Fue un placer ayudarte.

Si en el futuro necesitas algo más, no dudes en contactarme.

¡Te deseo lo mejor!
{{vendedor}}`,
          isDefault: true,
        },
        {
          templateType: "general",
          title: "Información Adicional",
          body: `{{nombre}}, aquí te comparto información adicional sobre la propiedad que te interesó:

*{{propiedad}}*
{{zona}}
${{precio}}/mes

¿Tienes alguna otra pregunta? Con gusto te ayudo.

{{vendedor}}`,
          isDefault: false,
        },
      ];

      // Insert templates (sellerId = null means shared for agency)
      const createdTemplates = [];
      for (const template of defaultTemplates) {
        try {
          // Check if a similar template already exists
          const [existing] = await db.select().from(sellerMessageTemplates)
            .where(and(
              eq(sellerMessageTemplates.agencyId, agencyId),
              eq(sellerMessageTemplates.title, template.title),
              eq(sellerMessageTemplates.templateType, template.templateType as any),
              isNull(sellerMessageTemplates.sellerId)
            ));

          if (!existing) {
            const [created] = await db.insert(sellerMessageTemplates).values({
              agencyId,
              sellerId: null, // Shared template for all sellers in agency
              templateType: template.templateType as any,
              title: template.title,
              body: template.body,
              isDefault: template.isDefault,
            }).returning();
            createdTemplates.push(created);
          }
        } catch (err) {
          console.error(`Error creating template ${template.title}:`, err);
        }
      }

      res.status(201).json({ 
        success: true, 
        message: `${createdTemplates.length} templates created`,
        templates: createdTemplates 
      });
    } catch (error: any) {
      console.error("Error seeding default templates:", error);
      handleGenericError(res, error);
    }
  });


  // ==================== Seller Appointment Endpoints ====================
  // POST /api/external-seller/appointments - Create appointment (seller can create for their leads)
  app.post("/api/external-seller/appointments", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      const userId = req.user?.id || req.session?.user?.id;
      const { tourStops, leadId, ...appointmentData } = req.body;

      // If leadId provided, verify lead belongs to this seller
      if (leadId) {
        const lead = await storage.getExternalLead(leadId);
        if (!lead || lead.agencyId !== agencyId) {
          return res.status(404).json({ message: "Lead not found" });
        }
        // Sellers can only create appointments for their own leads
        if (req.user.role === 'external_agency_seller' && lead.sellerId !== userId) {
          return res.status(403).json({ message: "You can only create appointments for your own leads" });
        }
      }

      // Convert date string to Date object if needed
      const parsedDate = typeof appointmentData.date === 'string' 
        ? new Date(appointmentData.date) 
        : appointmentData.date;

      // Validate appointment data
      const validatedData = insertExternalAppointmentSchema.parse({
        ...appointmentData,
        date: parsedDate,
        agencyId,
        createdBy: userId,
        salespersonId: userId, // Seller is the salesperson
        leadId: leadId || null,
      });

      // For tours, validate max 3 properties rule
      if (validatedData.mode === 'tour' && tourStops && tourStops.length > 3) {
        return res.status(400).json({ message: "Tours can have a maximum of 3 properties" });
      }

      // Calculate end time based on mode
      const startDate = new Date(validatedData.date);
      let endDate: Date;
      
      if (validatedData.mode === 'individual') {
        // Individual appointments are 1 hour
        endDate = new Date(startDate.getTime() + 60 * 60 * 1000);
      } else {
        // Tours: 30 minutes per property
        const propertyCount = tourStops?.length || 1;
        endDate = new Date(startDate.getTime() + propertyCount * 30 * 60 * 1000);
      }

      // Generate tour group ID if this is a tour
      const tourGroupId = validatedData.mode === 'tour' ? crypto.randomUUID() : null;

      const appointment = await storage.createExternalAppointment({
        ...validatedData,
        endTime: endDate,
        tourGroupId,
      });

      // Create tour stops if this is a tour
      if (validatedData.mode === 'tour' && tourStops && tourStops.length > 0) {
        const stopsData = tourStops.map((stop: any, index: number) => ({
          appointmentId: appointment.id,
          unitId: stop.unitId,
          sequence: index + 1,
          scheduledTime: new Date(startDate.getTime() + index * 30 * 60 * 1000),
          notes: stop.notes || null,
        }));

        await storage.createExternalAppointmentUnits(stopsData);
      }

      await createAuditLog(req, "create", "external_appointment", appointment.id, 
        `Seller created ${validatedData.mode} appointment for ${validatedData.clientName}`);

      res.status(201).json(appointment);
    } catch (error: any) {
      console.error("Error creating seller appointment:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/appointments - Get appointments for seller's calendar view
  app.get("/api/external-seller/appointments", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      const userId = req.user?.id || req.session?.user?.id;
      const isSeller = req.user.role === 'external_agency_seller';
      const { startDate, endDate, status } = req.query;

      const filters: any = {};
      if (status) filters.status = status.includes(',') ? status.split(',') : status;
      if (startDate) filters.startDate = new Date(startDate);
      if (endDate) filters.endDate = new Date(endDate);

      const appointments = await storage.getExternalAppointmentsByAgency(agencyId, filters);

      // Transform appointments for seller view
      const transformedAppointments = appointments.map((apt: any) => {
        const isOwner = apt.salespersonId === userId || apt.createdBy === userId;
        
        if (isSeller && !isOwner) {
          // Limited view for other sellers' appointments
          return {
            id: apt.id,
            date: apt.date,
            endTime: apt.endTime,
            mode: apt.mode,
            status: apt.status,
            // Limited info - only show client first name and property info
            clientName: apt.clientName?.split(' ')[0] || 'Cliente',
            condominiumName: apt.condominiumName || null,
            unitNumber: apt.unitNumber || null,
            // Mark as restricted
            isRestricted: true,
            canEdit: false,
            canCancel: false,
          };
        }

        // Full view for owner or admin
        return {
          ...apt,
          isRestricted: false,
          canEdit: isOwner || !isSeller,
          canCancel: isOwner || !isSeller,
        };
      });

      res.json(transformedAppointments);
    } catch (error: any) {
      console.error("Error fetching seller appointments:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-seller/appointments/:id/cancel - Cancel own appointment
  app.patch("/api/external-seller/appointments/:id/cancel", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { cancellationReason } = req.body;
      const userId = req.user?.id || req.session?.user?.id;
      const isSeller = req.user.role === 'external_agency_seller';

      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      const appointment = await storage.getExternalAppointmentByAgency(id, agencyId);
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      // Sellers can only cancel their own appointments
      if (isSeller && appointment.salespersonId !== userId && appointment.createdBy !== userId) {
        return res.status(403).json({ message: "You can only cancel your own appointments" });
      }

      // Check if appointment can be cancelled
      if (appointment.status === 'cancelled' || appointment.status === 'completed') {
        return res.status(400).json({ message: "Cannot cancel this appointment" });
      }

      const updated = await storage.updateExternalAppointmentStatus(id, 'cancelled', {
        cancelledAt: new Date(),
        cancellationReason: cancellationReason || null,
      });

      await createAuditLog(req, "update", "external_appointment", id, 
        `Seller cancelled appointment: ${cancellationReason || 'No reason provided'}`);

      res.json(updated);
    } catch (error: any) {
      console.error("Error cancelling appointment:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/follow-ups - Get follow-up tasks for seller
  app.get("/api/external-seller/follow-ups", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { status = 'pending', limit = '20' } = req.query;

      const conditions = [
        eq(sellerFollowUpTasks.agencyId, agencyId),
        eq(sellerFollowUpTasks.sellerId, req.user.id),
      ];

      if (status && status !== 'all') {
        conditions.push(eq(sellerFollowUpTasks.status, status as string));
      }

      const tasks = await db.select({
        id: sellerFollowUpTasks.id,
        status: sellerFollowUpTasks.status,
        dueDate: sellerFollowUpTasks.dueDate,
        priority: sellerFollowUpTasks.priority,
        reason: sellerFollowUpTasks.reason,
        notes: sellerFollowUpTasks.notes,
        autoGenerated: sellerFollowUpTasks.autoGenerated,
        lastContactedAt: sellerFollowUpTasks.lastContactedAt,
        snoozedUntil: sellerFollowUpTasks.snoozedUntil,
        createdAt: sellerFollowUpTasks.createdAt,
        leadId: sellerFollowUpTasks.leadId,
        leadFirstName: externalLeads.firstName,
        leadLastName: externalLeads.lastName,
        leadPhone: externalLeads.phone,
        leadStatus: externalLeads.status,
      })
        .from(sellerFollowUpTasks)
        .leftJoin(externalLeads, eq(sellerFollowUpTasks.leadId, externalLeads.id))
        .where(and(...conditions))
        .orderBy(asc(sellerFollowUpTasks.dueDate))
        .limit(parseInt(limit as string));

      // Count overdue
      const now = new Date();
      const overdue = tasks.filter(t => t.status === 'pending' && new Date(t.dueDate) < now);

      res.json({
        tasks,
        overdueCount: overdue.length,
        totalPending: tasks.filter(t => t.status === 'pending').length,
      });
    } catch (error: any) {
      console.error("Error fetching follow-ups:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-seller/follow-ups - Create a follow-up task
  app.post("/api/external-seller/follow-ups", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { leadId, dueDate, priority = 'medium', reason, notes } = req.body;

      if (!leadId || !dueDate) {
        return res.status(400).json({ message: "Lead ID and due date are required" });
      }

      const [task] = await db.insert(sellerFollowUpTasks).values({
        agencyId,
        sellerId: req.user.id,
        leadId,
        dueDate: new Date(dueDate),
        priority,
        reason,
        notes,
        autoGenerated: false,
      }).returning();

      res.status(201).json(task);
    } catch (error: any) {
      console.error("Error creating follow-up:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-seller/follow-ups/:id - Update follow-up (complete, snooze, etc.)
  app.patch("/api/external-seller/follow-ups/:id", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { id } = req.params;
      const { status, snoozedUntil, notes } = req.body;

      const updates: any = { updatedAt: new Date() };
      if (status) {
        updates.status = status;
        if (status === 'completed') {
          updates.completedAt = new Date();
        }
      }
      if (snoozedUntil) {
        updates.snoozedUntil = new Date(snoozedUntil);
        updates.status = 'snoozed';
      }
      if (notes !== undefined) {
        updates.notes = notes;
      }

      const [updated] = await db.update(sellerFollowUpTasks)
        .set(updates)
        .where(and(
          eq(sellerFollowUpTasks.id, id),
          eq(sellerFollowUpTasks.agencyId, agencyId),
          eq(sellerFollowUpTasks.sellerId, req.user.id)
        ))
        .returning();

      if (!updated) {
        return res.status(404).json({ message: "Follow-up task not found" });
      }

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating follow-up:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/matching-leads/:unitId - Get leads that match a property/unit
  app.get("/api/external-seller/matching-leads/:unitId", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { unitId } = req.params;

      // Get unit details
      const [unit] = await db.select().from(externalUnits).where(eq(externalUnits.id, unitId));
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }

      const unitPrice = unit.monthlyRent ? Number(unit.monthlyRent) : 0;
      const priceMin = unitPrice * 0.8;
      const priceMax = unitPrice * 1.2;

      // Find matching leads based on preferences
      const userId = req.user?.claims?.sub || req.user?.id;
      const userRole = req.user?.cachedRole || req.user?.role;
      
      const conditions = [
        eq(externalLeads.agencyId, agencyId),
        not(inArray(externalLeads.status, ['converted', 'renta_concretada', 'lost'])),
      ];

      // Sellers only see their own leads (assigned or created by them)
      if (userRole === 'external_agency_seller' && userId) {
        conditions.push(
          or(
            eq(externalLeads.sellerId, userId),
            eq(externalLeads.createdBy, userId)
          )!
        );
      }

      const leads = await db.select({
        id: externalLeads.id,
        firstName: externalLeads.firstName,
        lastName: externalLeads.lastName,
        phone: externalLeads.phone,
        estimatedRentCost: externalLeads.estimatedRentCost,
        bedrooms: externalLeads.bedrooms,
        desiredNeighborhood: externalLeads.desiredNeighborhood,
        desiredUnitType: externalLeads.desiredUnitType,
        status: externalLeads.status,
      })
        .from(externalLeads)
        .where(and(...conditions))
        .limit(50);

      // Score leads by match quality
      const scoredLeads = leads.map(lead => {
        let score = 0;
        let matchReasons: string[] = [];

        // Budget match (±20%)
        const leadBudget = lead.estimatedRentCost ? Number(lead.estimatedRentCost) : 0;
        if (leadBudget >= priceMin && leadBudget <= priceMax) {
          score += 30;
          matchReasons.push('Presupuesto compatible');
        }

        // Bedrooms match
        if (lead.bedrooms && unit.bedrooms && Number(lead.bedrooms) === unit.bedrooms) {
          score += 25;
          matchReasons.push('Recámaras coinciden');
        }

        // Zone match
        if (lead.desiredNeighborhood && unit.zone && 
            lead.desiredNeighborhood.toLowerCase().includes(unit.zone.toLowerCase())) {
          score += 25;
          matchReasons.push('Zona de interés');
        }

        // Unit type match
        if (lead.desiredUnitType && unit.unitType &&
            lead.desiredUnitType.toLowerCase() === unit.unitType.toLowerCase()) {
          score += 20;
          matchReasons.push('Tipo de propiedad');
        }

        return { ...lead, matchScore: score, matchReasons };
      });

      // Filter and sort by score
      const matchingLeads = scoredLeads
        .filter(l => l.matchScore > 0)
        .sort((a, b) => b.matchScore - a.matchScore);

      res.json(matchingLeads);
    } catch (error: any) {
      console.error("Error finding matching leads:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/matching-properties/:leadId - Get properties that match a lead
  app.get("/api/external-seller/matching-properties/:leadId", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const { leadId } = req.params;

      // Get lead details
      const [lead] = await db.select().from(externalLeads).where(eq(externalLeads.id, leadId));
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }

      const leadBudget = lead.estimatedRentCost ? Number(lead.estimatedRentCost) : 0;
      const priceMin = leadBudget * 0.8;
      const priceMax = leadBudget * 1.2;

      // Get available units
      const units = await db.select()
        .from(externalUnits)
        .where(and(
          eq(externalUnits.agencyId, agencyId),
          eq(externalUnits.isActive, true)
        ))
        .limit(100);

      // Score units by match quality
      const scoredUnits = units.map(unit => {
        let score = 0;
        let matchReasons: string[] = [];

        const unitPrice = unit.monthlyRent ? Number(unit.monthlyRent) : 0;

        // Budget match
        if (unitPrice >= priceMin && unitPrice <= priceMax) {
          score += 30;
          matchReasons.push('Dentro del presupuesto');
        }

        // Bedrooms match
        if (lead.bedrooms && unit.bedrooms && Number(lead.bedrooms) === unit.bedrooms) {
          score += 25;
          matchReasons.push('Recámaras coinciden');
        }

        // Zone match
        if (lead.desiredNeighborhood && unit.zone && 
            lead.desiredNeighborhood.toLowerCase().includes(unit.zone.toLowerCase())) {
          score += 25;
          matchReasons.push('Zona preferida');
        }

        // Unit type match
        if (lead.desiredUnitType && unit.unitType &&
            lead.desiredUnitType.toLowerCase() === unit.unitType.toLowerCase()) {
          score += 20;
          matchReasons.push('Tipo de propiedad');
        }

        return { ...unit, matchScore: score, matchReasons };
      });

      // Filter and sort by score
      const matchingUnits = scoredUnits
        .filter(u => u.matchScore > 0)
        .sort((a, b) => b.matchScore - a.matchScore)
        .slice(0, 20);

      res.json(matchingUnits);
    } catch (error: any) {
      console.error("Error finding matching properties:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/metrics - Get seller performance metrics
  app.get("/api/external-seller/metrics", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const sellerId = req.user.id;
      const now = new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      // Get total leads
      const [totalResult] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(externalLeads)
        .where(and(
          eq(externalLeads.agencyId, agencyId),
          eq(externalLeads.sellerId, sellerId)
        ));

      // Get converted leads
      const [convertedResult] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(externalLeads)
        .where(and(
          eq(externalLeads.agencyId, agencyId),
          eq(externalLeads.sellerId, sellerId),
          or(
            eq(externalLeads.status, 'convertido'),
            eq(externalLeads.status, 'renta_concretada')
          )
        ));

      // Get this month leads
      const [thisMonthResult] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(externalLeads)
        .where(and(
          eq(externalLeads.agencyId, agencyId),
          eq(externalLeads.sellerId, sellerId),
          gte(externalLeads.createdAt, startOfMonth)
        ));

      // Get total properties sent
      const [offersTotal] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(externalLeadPropertyOffers)
        .where(and(
          eq(externalLeadPropertyOffers.agencyId, agencyId),
          eq(externalLeadPropertyOffers.sellerId, sellerId)
        ));

      // Get this month properties sent
      const [offersThisMonth] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(externalLeadPropertyOffers)
        .where(and(
          eq(externalLeadPropertyOffers.agencyId, agencyId),
          eq(externalLeadPropertyOffers.sellerId, sellerId),
          gte(externalLeadPropertyOffers.sentAt, startOfMonth)
        ));

      // Get interested count
      const [offersInterested] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(externalLeadPropertyOffers)
        .where(and(
          eq(externalLeadPropertyOffers.agencyId, agencyId),
          eq(externalLeadPropertyOffers.sellerId, sellerId),
          eq(externalLeadPropertyOffers.isInterested, true)
        ));

      // Get pending follow-ups
      const [pendingFollowUps] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(sellerFollowUpTasks)
        .where(and(
          eq(sellerFollowUpTasks.agencyId, agencyId),
          eq(sellerFollowUpTasks.sellerId, sellerId),
          eq(sellerFollowUpTasks.status, 'pending')
        ));

      // Get overdue follow-ups
      const [overdueFollowUps] = await db.select({
        count: sql<number>`count(*)`
      })
        .from(sellerFollowUpTasks)
        .where(and(
          eq(sellerFollowUpTasks.agencyId, agencyId),
          eq(sellerFollowUpTasks.sellerId, sellerId),
          eq(sellerFollowUpTasks.status, 'pending'),
          lt(sellerFollowUpTasks.dueDate, now)
        ));

      // Calculate conversion rate
      const totalLeads = Number(totalResult?.count || 0);
      const convertedLeads = Number(convertedResult?.count || 0);
      const conversionRate = totalLeads > 0 ? (convertedLeads / totalLeads) * 100 : 0;

      res.json({
        leads: {
          total: totalLeads,
          converted: convertedLeads,
          thisMonth: Number(thisMonthResult?.count || 0),
          conversionRate: Math.round(conversionRate * 10) / 10,
        },
        propertiesSent: {
          total: Number(offersTotal?.count || 0),
          thisMonth: Number(offersThisMonth?.count || 0),
          interested: Number(offersInterested?.count || 0),
        },
        followUps: {
          pending: Number(pendingFollowUps?.count || 0),
          overdue: Number(overdueFollowUps?.count || 0),
        },
      });
    } catch (error: any) {
      console.error("Error fetching seller metrics:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-seller/commissions - Get seller commission history
  // Note: External seller commissions tracking not yet implemented
  app.get("/api/external-seller/commissions", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      // For now, return empty array since external seller commissions are not yet tracked
      return res.json([]);
    } catch (error: any) {
      console.error("Error fetching seller commissions:", error);
      handleGenericError(res, error);
    }
  });
  app.post("/api/external-seller/auto-generate-follow-ups", isAuthenticated, requireRole(['external_agency_seller', ...EXTERNAL_ADMIN_ROLES]), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      const sellerId = req.user.id;
      const { inactiveDays = 3 } = req.body;
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - inactiveDays);

      // Find leads without recent activity or follow-up
      const inactiveLeads = await db.select({
        id: externalLeads.id,
        firstName: externalLeads.firstName,
        lastName: externalLeads.lastName,
        updatedAt: externalLeads.updatedAt,
      })
        .from(externalLeads)
        .leftJoin(sellerFollowUpTasks, and(
          eq(sellerFollowUpTasks.leadId, externalLeads.id),
          eq(sellerFollowUpTasks.status, 'pending')
        ))
        .where(and(
          eq(externalLeads.agencyId, agencyId),
          eq(externalLeads.sellerId, sellerId),
          not(inArray(externalLeads.status, ['converted', 'renta_concretada', 'lost'])),
          lt(externalLeads.updatedAt, cutoffDate),
          isNull(sellerFollowUpTasks.id)
        ))
        .limit(10);

      // Create follow-up tasks
      const created = [];
      for (const lead of inactiveLeads) {
        const dueDate = new Date();
        dueDate.setDate(dueDate.getDate() + 1); // Due tomorrow

        const [task] = await db.insert(sellerFollowUpTasks).values({
          agencyId,
          sellerId,
          leadId: lead.id,
          dueDate,
          priority: 'medium',
          reason: `Sin contacto en ${inactiveDays}+ días`,
          autoGenerated: true,
          lastContactedAt: lead.updatedAt,
        }).returning();

        created.push(task);
      }

      res.json({
        generated: created.length,
        tasks: created,
      });
    } catch (error: any) {
      console.error("Error generating follow-ups:", error);
      handleGenericError(res, error);
    }
  });
  app.get("/api/external-condominiums", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { isActive, search, zone, sortField, sortOrder, limit, offset } = req.query;
      
      // Get agency ID from authenticated user (admin/master can pass agencyId to view other agencies)
      let agencyId = req.query.agencyId;
      if (!agencyId) {
        agencyId = await getUserAgencyId(req);
        if (!agencyId) {
          return res.status(400).json({ message: "User is not assigned to any agency" });
        }
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, agencyId);
      if (!hasAccess) return; // Response already sent by helper
      
      // Always use pagination for performance - defaults: limit=50, offset=0
      const limitNum = limit ? parseInt(limit as string, 10) : 50;
      const offsetNum = offset ? parseInt(offset as string, 10) : 0;
      const parsedLimit = Number.isFinite(limitNum) ? Math.min(Math.max(1, limitNum), 1000) : 50;
      const parsedOffset = Number.isFinite(offsetNum) ? Math.max(0, offsetNum) : 0;
      
      // Build filters
      const filters: any = {};
      if (isActive !== undefined) filters.isActive = isActive === 'true';
      if (search) filters.search = search as string;
      if (zone) filters.zone = zone as string;
      if (sortField) filters.sortField = sortField as string;
      if (sortOrder && (sortOrder === 'asc' || sortOrder === 'desc')) filters.sortOrder = sortOrder;
      filters.limit = parsedLimit;
      filters.offset = parsedOffset;
      
      // Execute data fetch and count in parallel
      const [condominiums, total] = await Promise.all([
        storage.getExternalCondominiumsByAgency(agencyId, filters),
        storage.getExternalCondominiumsCountByAgency(agencyId, {
          isActive: filters.isActive,
          search: filters.search,
          sellerId: filters.sellerId,
          sellerScope: filters.sellerScope,
          expiringDays: filters.expiringDays,
        }),
      ]);
      
      res.json({
        data: condominiums,
        total,
        limit: parsedLimit,
        offset: parsedOffset,
        hasMore: parsedOffset + condominiums.length < total,
      });
    } catch (error: any) {
      console.error("Error fetching external condominiums:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-condominiums/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const condominium = await storage.getExternalCondominium(id);
      
      if (!condominium) {
        return res.status(404).json({ message: "Condominium not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, condominium.agencyId);
      if (!hasAccess) return; // Response already sent by helper
      
      res.json(condominium);
    } catch (error: any) {
      console.error("Error fetching external condominium:", error);
      handleGenericError(res, error);
    }
  });

  // GET units for a specific external condominium
  app.get("/api/external-condominiums/:id/units", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const condominium = await storage.getExternalCondominium(id);
      
      if (!condominium) {
        return res.status(404).json({ message: "Condominium not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, condominium.agencyId);
      if (!hasAccess) return;
      
      // Fetch units for this condominium
      const units = await storage.getExternalUnitsByCondominium(id);
      console.log(`[Units for Condo] Fetched ${units.length} units for condominium ${id}`);
      res.json(units.map(u => ({ id: u.id, unitNumber: u.unitNumber, type: u.typology || u.propertyType })));
    } catch (error: any) {
      console.error("Error fetching condominium units:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-condominiums", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      // Get agency ID from authenticated user
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }
      
      const validatedData = insertExternalCondominiumSchema.parse(req.body);
      const condominium = await storage.createExternalCondominium({
        ...validatedData,
        agencyId,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_condominium", condominium.id, "Created external condominium");
      res.status(201).json(condominium);
    } catch (error: any) {
      console.error("Error creating external condominium:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // POST get units by IDs (for hydrating lead form edit state)
  app.post("/api/external-units/by-ids", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const userRole = req.user?.cachedRole || req.user?.role || req.session?.adminUser?.role;
      const agencyId = await getUserAgencyId(req);
      
      // Non-admin users must have an agency
      if (userRole !== 'master' && userRole !== 'admin' && !agencyId) {
        return res.status(403).json({ message: "Access denied: No agency association" });
      }
      
      
      const { unitIds } = req.body;
      if (!Array.isArray(unitIds)) {
        return res.status(400).json({ message: "unitIds must be an array" });
      }
      
      const units = await storage.getExternalUnitsByIds(agencyId, unitIds);
      res.json(units);
    } catch (error: any) {
      console.error("Error fetching units by IDs:", error);
      handleGenericError(res, error);
    }
  });

  // Atomic creation of condominium with units in a transaction
  app.post("/api/external-condominiums/with-units", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      // Get agency ID from authenticated user
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }
      
      const validatedData = createCondominiumWithUnitsSchema.parse(req.body);
      
      // Create condominium and units atomically via storage layer
      const result = await storage.createCondominiumWithUnits(
        validatedData.condominium,
        validatedData.units,
        agencyId,
        req.user.id
      );
      
      await createAuditLog(
        req, 
        "create", 
        "external_condominium", 
        result.condominium.id, 
        `Created external condominium with ${result.units.length} units`
      );
      
      res.status(201).json(result);
    } catch (error: any) {
      console.error("Error creating external condominium with units:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // Add multiple units to an existing condominium
  app.post("/api/external-condominiums/:id/units/bulk", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Get agency ID from authenticated user
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }
      
      const validatedData = addUnitsToCondominiumSchema.parse(req.body);
      
      // Add units to existing condominium atomically via storage layer
      const units = await storage.addUnitsToCondominium(
        id,
        validatedData.units,
        agencyId,
        req.user.id
      );
      
      await createAuditLog(
        req, 
        "create", 
        "external_units", 
        id, 
        `Added ${units.length} units to condominium`
      );
      
      res.status(201).json(units);
    } catch (error: any) {
      console.error("Error adding units to condominium:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      if (error.message.includes("not found")) {
        return res.status(404).json({ message: error.message });
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-condominiums/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify condominium exists
      const existing = await storage.getExternalCondominium(id);
      if (!existing) {
        return res.status(404).json({ message: "Condominium not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return; // Response already sent by helper
      
      // Validate update data
      const validatedData = updateExternalCondominiumSchema.parse(req.body);
      
      // Prevent agencyId modification
      const updateData = { ...validatedData };
      delete (updateData as any).agencyId;
      delete (updateData as any).createdBy;
      
      const condominium = await storage.updateExternalCondominium(id, updateData);
      
      await createAuditLog(req, "update", "external_condominium", id, "Updated external condominium");
      res.json(condominium);
    } catch (error: any) {
      console.error("Error updating external condominium:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-condominiums/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalCondominium(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Condominium not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return; // Response already sent by helper
      
      // Check if condominium has any units
      const units = await storage.getExternalUnitsByCondominium(id);
      if (units && units.length > 0) {
        return res.status(400).json({ 
          message: `Cannot delete condominium with ${units.length} registered units. Please delete all units first.`
        });
      }
      
      await storage.deleteExternalCondominium(id);
      
      await createAuditLog(req, "delete", "external_condominium", id, "Deleted external condominium");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external condominium:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-units/publication-status - Get publication status for all units in agency
  app.get("/api/external-units/publication-status", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "User is not assigned to any agency" });
      }

      // Get the most recent publication request for each unit in this agency
      // Using a subquery to get the latest request per unit
      const allRequests = await db.select({
        unitId: externalPublicationRequests.unitId,
        status: externalPublicationRequests.status,
        requestedAt: externalPublicationRequests.requestedAt,
      })
      .from(externalPublicationRequests)
      .where(eq(externalPublicationRequests.agencyId, agencyId))
      .orderBy(desc(externalPublicationRequests.requestedAt));

      // Get only the latest request per unit
      const latestByUnit = new Map<string, { unitId: string; status: string }>();
      for (const req of allRequests) {
        if (!latestByUnit.has(req.unitId)) {
          latestByUnit.set(req.unitId, { unitId: req.unitId, status: req.status });
        }
      }

      res.json(Array.from(latestByUnit.values()));
    } catch (error: any) {
      console.error("Error fetching publication status:", error);
      handleGenericError(res, error);
    }
  });

  // External Units Routes
  app.get("/api/external-units", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { condominiumId, isActive, search, zone, typology, sortField, sortOrder, limit, offset } = req.query;
      
      // Get agency ID from authenticated user (admin/master can pass agencyId to view other agencies)
      let agencyId = req.query.agencyId;
      if (!agencyId) {
        agencyId = await getUserAgencyId(req);
        if (!agencyId) {
          return res.status(400).json({ message: "User is not assigned to any agency" });
        }
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, agencyId);
      if (!hasAccess) return;
      
      // Always use pagination for performance - defaults: limit=50, offset=0
      const limitNum = limit ? parseInt(limit as string, 10) : 50;
      const offsetNum = offset ? parseInt(offset as string, 10) : 0;
      const parsedLimit = Number.isFinite(limitNum) ? Math.min(Math.max(1, limitNum), 100) : 50;
      const parsedOffset = Number.isFinite(offsetNum) ? Math.max(0, offsetNum) : 0;
      
      const filters: any = {};
      if (isActive !== undefined) filters.isActive = isActive === 'true';
      if (condominiumId) filters.condominiumId = condominiumId;
      if (search) filters.search = search as string;
      if (zone) filters.zone = zone as string;
      if (typology) filters.typology = typology as string;
      if (sortField) filters.sortField = sortField as string;
      if (sortOrder && (sortOrder === 'asc' || sortOrder === 'desc')) filters.sortOrder = sortOrder;
      filters.limit = parsedLimit;
      filters.offset = parsedOffset;
      
      // Execute data fetch and count in parallel
      const [units, total] = await Promise.all([
        storage.getExternalUnitsByAgency(agencyId, filters),
        storage.getExternalUnitsCountByAgency(agencyId, {
          isActive: filters.isActive,
          condominiumId: filters.condominiumId,
          search: filters.search,
          sellerId: filters.sellerId,
          sellerScope: filters.sellerScope,
          expiringDays: filters.expiringDays,
        }),
      ]);
      
      // Get all active contracts for this agency to determine which units are rented
      const activeContracts = await storage.getExternalRentalContractsByAgency(agencyId);
      const activeContractsByUnit = new Map(
        activeContracts
          .filter(c => c.status === 'active')
          .map(c => [c.unitId, c.id])
      );
      
      // Add currentContractId and status field to each unit
      const unitsWithContractInfo = units.map(unit => ({
        ...unit,
        status: unit.isActive ? 'active' : 'inactive',
        currentContractId: activeContractsByUnit.get(unit.id) || null,
      }));
      
      res.json({
        data: unitsWithContractInfo,
        total,
        limit: parsedLimit,
        offset: parsedOffset,
        hasMore: parsedOffset + units.length < total,
      });
    } catch (error: any) {
      console.error("Error fetching external units:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-units/by-condominium/:condominiumId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { condominiumId } = req.params;
      
      // Basic UUID validation to prevent injection
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(condominiumId)) {
        return res.json([]);
      }
      // Verify condominium exists and get its agency
      const condominium = await storage.getExternalCondominium(condominiumId);
      if (!condominium) {
        return res.status(404).json({ message: "Condominium not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, condominium.agencyId);
      if (!hasAccess) return;
      
      const units = await storage.getExternalUnitsByCondominium(condominiumId);
      
      res.json(units);
    } catch (error: any) {
      console.error("Error fetching units by condominium:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-units/:id/overview - Consolidated endpoint for Unit Detail page
  // Returns unit data, condominium, rental history, maintenance history, and available condos
  app.get("/api/external-units/:id/overview", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      // Query 1: Get unit
      const unit = await storage.getExternalUnit(id);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership via fail-closed pattern
      if (unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Query 2: Get condominium (if assigned)
      let condominium = null;
      if (unit.condominiumId) {
        condominium = await storage.getExternalCondominium(unit.condominiumId);
      }
      
      // Query 3: Get rental contracts history (all statuses)
      const rentalContracts = await db.select()
        .from(externalRentalContracts)
        .where(eq(externalRentalContracts.unitId, id))
        .orderBy(desc(externalRentalContracts.createdAt))
        .limit(20);
      
      // Query 4: Get maintenance tickets for this unit
      const maintenanceTickets = await db.select({
        id: externalMaintenanceTickets.id,
        title: externalMaintenanceTickets.title,
        category: externalMaintenanceTickets.category,
        priority: externalMaintenanceTickets.priority,
        status: externalMaintenanceTickets.status,
        reportedBy: externalMaintenanceTickets.reportedBy,
        estimatedCost: externalMaintenanceTickets.estimatedCost,
        actualCost: externalMaintenanceTickets.actualCost,
        scheduledDate: externalMaintenanceTickets.scheduledDate,
        closedAt: externalMaintenanceTickets.closedAt,
        createdAt: externalMaintenanceTickets.createdAt,
      })
        .from(externalMaintenanceTickets)
        .where(
          and(
            eq(externalMaintenanceTickets.unitId, id),
            eq(externalMaintenanceTickets.agencyId, agencyId)
          )
        )
        .orderBy(desc(externalMaintenanceTickets.createdAt))
        .limit(20);
      
      // Query 5: Get available condominiums for reassignment
      const availableCondominiums = await db.select({
        id: externalCondominiums.id,
        name: externalCondominiums.name,
        address: externalCondominiums.address,
      })
        .from(externalCondominiums)
        .where(
          and(
            eq(externalCondominiums.agencyId, agencyId),
            eq(externalCondominiums.isActive, true)
          )
        )
        .orderBy(asc(externalCondominiums.name));
      
      // Query 6: Get showings related to this unit via leads
      const unitShowings = await db.select({
        id: externalLeadShowings.id,
        leadId: externalLeadShowings.leadId,
        scheduledAt: externalLeadShowings.scheduledAt,
        outcome: externalLeadShowings.outcome,
        leadFeedback: externalLeadShowings.leadFeedback,
        createdAt: externalLeadShowings.createdAt,
      })
        .from(externalLeadShowings)
        .where(
          and(
            eq(externalLeadShowings.unitId, id),
            eq(externalLeadShowings.agencyId, agencyId)
          )
        )
        .orderBy(desc(externalLeadShowings.scheduledAt))
        .limit(20);
      
      res.json({
        unit,
        condominium,
        rentalHistory: rentalContracts,
        maintenanceHistory: maintenanceTickets,
        showingsHistory: unitShowings,
        availableCondominiums,
      });
    } catch (error: any) {
      console.error("Error fetching unit overview:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-units/:id/calculate-commission - Calculate commission for a unit
  app.post("/api/external-units/:id/calculate-commission", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { leaseDurationMonths } = req.body;
      
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const unit = await storage.getExternalUnit(id);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      if (unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const monthlyRent = unit.monthlyRent12 || 0;
      if (monthlyRent <= 0) {
        return res.status(400).json({ message: "Unit has no valid monthly rent" });
      }
      
      const duration = leaseDurationMonths || 12;
      if (duration < 6 || duration > 60) {
        return res.status(400).json({ message: "Lease duration must be between 6 and 60 months" });
      }
      
      const commissionResult = calculateExternalCommission({
        monthlyRent,
        leaseDurationMonths: duration,
        commissionType: unit.commissionType,
        referrerName: unit.referrerName,
        referrerPhone: unit.referrerPhone,
        referrerEmail: unit.referrerEmail,
      });
      
      res.json({
        unitId: id,
        unitName: unit.unitNumber,
        monthlyRent,
        leaseDurationMonths: duration,
        ...commissionResult,
      });
    } catch (error: any) {
      console.error("Error calculating commission:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-units/sheet-preview - Preview sheet data before import
  // NOTE: This route must be defined BEFORE the /:id route to avoid being caught by it
  app.get("/api/external-units/sheet-preview", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { spreadsheetId, sheetName = 'Renta/Long Term' } = req.query;
      
      if (!spreadsheetId) {
        return res.status(400).json({ message: "Spreadsheet ID is required" });
      }
      
      // Get sheet stats
      const stats = await getTRHSheetStats(spreadsheetId as string, sheetName as string);
      
      // Get preview of first 10 rows
      const rawRows = await readTRHUnitsFromSheet(spreadsheetId as string, sheetName as string, 2, 10);
      const parsedUnits = rawRows.map(row => parseTRHRow(row));
      
      res.json({
        success: true,
        totalRows: stats.totalRows,
        sheetName: stats.sheetName,
        preview: parsedUnits,
        condominiums: [...new Set(parsedUnits.filter(u => u.condominiumName).map(u => u.condominiumName))],
      });
    } catch (error: any) {
      console.error("Error previewing sheet:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-units/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const unit = await storage.getExternalUnit(id);
      
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      res.json(unit);
    } catch (error: any) {
      console.error("Error fetching external unit:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-units", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalUnitSchema.parse(req.body);
      
      // Get agency ID from the condominium
      const condominium = await storage.getExternalCondominium(validatedData.condominiumId);
      if (!condominium) {
        return res.status(404).json({ message: "Condominium not found" });
      }
      
      // Verify user has access to this agency
      const hasAccess = await verifyExternalAgencyOwnership(req, res, condominium.agencyId);
      if (!hasAccess) return;
      
      const unit = await storage.createExternalUnit({
        ...validatedData,
        agencyId: condominium.agencyId,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_unit", unit.id, "Created external unit");
      res.status(201).json(unit);
    } catch (error: any) {
      console.error("Error creating external unit:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-units/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify unit exists
      const existing = await storage.getExternalUnit(id);
      if (!existing) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      // Validate update data
      const validatedData = updateExternalUnitSchema.parse(req.body);
      
      // Prevent agencyId modification
      const updateData = { ...validatedData };
      delete (updateData as any).agencyId;
      delete (updateData as any).createdBy;
      
      // Check if publishToMain is being set to true and create publication request
      const wasPublishingToMain = existing.publishToMain === true;
      // Check both validated data and raw request body to ensure we capture the toggle
      const wantsToPublishToMain = validatedData.publishToMain === true || 
                                   (validatedData.publishToMain === undefined && req.body.publishToMain === true);
      
      // If unpublishing (publishToMain changed from true to false), set publishStatus to draft
      const wantsToUnpublish = validatedData.publishToMain === false;
      if (wantsToUnpublish && wasPublishingToMain) {
        updateData.publishStatus = 'draft';
      }

      if (wantsToPublishToMain && !wasPublishingToMain) {
        // Check if there's already a pending request for this unit
        const [existingPending] = await db.select()
          .from(externalPublicationRequests)
          .where(and(
            eq(externalPublicationRequests.unitId, id),
            eq(externalPublicationRequests.status, 'pending')
          ));
        
        if (!existingPending) {
          // Check if agency has auto-approve enabled
          const agency = await storage.getExternalAgency(existing.agencyId);
          const shouldAutoApprove = agency?.autoApprovePublications === true;
          
          // Create a new publication request
          const userId = req.user?.claims?.sub || req.user?.id;
          await db.insert(externalPublicationRequests)
            .values({
              unitId: id,
              agencyId: existing.agencyId,
              requestedBy: userId,
              status: shouldAutoApprove ? 'approved' : 'pending',
              reviewedBy: shouldAutoApprove ? userId : null,
              reviewedAt: shouldAutoApprove ? new Date() : null,
              feedback: shouldAutoApprove ? 'Auto-approved by agency configuration' : null,
            });
          
          if (shouldAutoApprove) {
            // Auto-approve: set status to approved
            updateData.publishStatus = 'approved';
            // Sync to properties table
            const fullUnit = await storage.getExternalUnit(id);
            if (fullUnit) {
              await syncExternalUnitToProperty(fullUnit, userId, existing.agencyId);
            }
          } else {
            // Manual approval required
            updateData.publishStatus = 'pending';
          }
        }
      }
      
      const unit = await storage.updateExternalUnit(id, updateData);
      
      await createAuditLog(req, "update", "external_unit", id, "Updated external unit");
      res.json(unit);
    } catch (error: any) {
      console.error("Error updating external unit:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-units/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalUnit(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalUnit(id);
      
      await createAuditLog(req, "delete", "external_unit", id, "Deleted external unit");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external unit:", error);
      handleGenericError(res, error);
    }
  });

  // Google Sheets import endpoint for external units
  app.post("/api/external-agencies/:agencyId/import-units-from-sheets", isAuthenticated, requireRole(['master', 'admin', 'external_agency_admin']), async (req: any, res) => {
    try {
      const { agencyId } = req.params;
      const { spreadsheetId, sheetRange, condominiumId } = req.body;

      if (!spreadsheetId) {
        return res.status(400).json({ message: "Se requiere el ID de la hoja de cálculo (spreadsheetId)" });
      }

      if (!condominiumId) {
        return res.status(400).json({ message: "Se requiere seleccionar un condominio" });
      }

      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, agencyId);
      if (!hasAccess) return;

      // Verify condominium belongs to agency
      const condominium = await storage.getExternalCondominium(condominiumId);
      if (!condominium || condominium.agencyId !== agencyId) {
        return res.status(400).json({ message: "El condominio no pertenece a esta agencia" });
      }

      // Read data from Google Sheets
      const range = sheetRange || 'Sheet1!A2:M';
      const rows = await readUnitsFromSheet(spreadsheetId, range);

      if (rows.length === 0) {
        return res.status(400).json({ message: "No se encontraron datos en la hoja de cálculo" });
      }

      const results = {
        imported: 0,
        skipped: 0,
        errors: [] as string[],
      };

      for (const row of rows) {
        try {
          if (!row.unitNumber) {
            results.skipped++;
            continue;
          }

          // Check if unit already exists
          const existingUnits = await storage.getExternalUnitsByAgency(agencyId);
          const existingUnit = existingUnits.find(u => 
            u.unitNumber === row.unitNumber && u.condominiumId === condominiumId
          );

          if (existingUnit) {
            results.skipped++;
            continue;
          }

          // Create new unit
          await storage.createExternalUnit({
            agencyId,
            condominiumId,
            unitNumber: row.unitNumber,
            rentPurpose: (row.rentPurpose as 'long_term' | 'vacation' | 'both') || 'long_term',
            floorNumber: row.floorNumber ? parseInt(row.floorNumber) : undefined,
            bedrooms: row.bedrooms ? parseInt(row.bedrooms) : undefined,
            bathrooms: row.bathrooms ? parseFloat(row.bathrooms) : undefined,
            size: row.size ? parseFloat(row.size) : undefined,
            rentAmount: row.rentAmount || undefined,
            depositAmount: row.depositAmount || undefined,
            notes: row.notes || undefined,
            isActive: true,
            createdBy: req.user.id,
          });

          results.imported++;
        } catch (err: any) {
          results.errors.push(`Error en fila ${row.unitNumber}: ${err.message}`);
        }
      }

      await createAuditLog(req, "import", "external_units", agencyId, `Imported ${results.imported} units from Google Sheets`);

      res.json({
        message: `Importación completada: ${results.imported} unidades importadas, ${results.skipped} omitidas`,
        ...results,
      });
    } catch (error: any) {
      console.error("Error importing units from Google Sheets:", error);
      if (error.message?.includes('Google Sheet not connected')) {
        return res.status(400).json({ message: "Google Sheets no está conectado. Por favor, configura la conexión primero." });
      }
      handleGenericError(res, error);
    }
  });

  // Get Google Sheets info (for preview)
  app.get("/api/external-agencies/:agencyId/sheets-info", isAuthenticated, requireRole(['master', 'admin', 'external_agency_admin']), async (req: any, res) => {
    try {
      const { agencyId } = req.params;
      const { spreadsheetId } = req.query;

      if (!spreadsheetId) {
        return res.status(400).json({ message: "Se requiere el ID de la hoja de cálculo" });
      }

      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, agencyId);
      if (!hasAccess) return;

      const info = await getSpreadsheetInfo(spreadsheetId as string);
      res.json(info);
    } catch (error: any) {
      console.error("Error getting spreadsheet info:", error);
      if (error.message?.includes('Google Sheet not connected')) {
        return res.status(400).json({ message: "Google Sheets no está conectado. Por favor, configura la conexión primero." });
      }
      handleGenericError(res, error);
    }
  });

  // Preview Google Sheets data before import
  app.get("/api/external-agencies/:agencyId/preview-sheets-data", isAuthenticated, requireRole(['master', 'admin', 'external_agency_admin']), async (req: any, res) => {
    try {
      const { agencyId } = req.params;
      const { spreadsheetId, sheetRange } = req.query;

      if (!spreadsheetId) {
        return res.status(400).json({ message: "Se requiere el ID de la hoja de cálculo" });
      }

      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, agencyId);
      if (!hasAccess) return;

      const range = (sheetRange as string) || 'Sheet1!A2:M';
      const rows = await readUnitsFromSheet(spreadsheetId as string, range);

      res.json({
        totalRows: rows.length,
        preview: rows.slice(0, 10), // First 10 rows for preview
        columns: ['unitNumber', 'condominiumName', 'rentPurpose', 'floorNumber', 'bedrooms', 'bathrooms', 'size', 'rentAmount', 'depositAmount', 'ownerName', 'ownerEmail', 'ownerPhone', 'notes'],
      });
    } catch (error: any) {
      console.error("Error previewing spreadsheet data:", error);
      if (error.message?.includes('Google Sheet not connected')) {
        return res.status(400).json({ message: "Google Sheets no está conectado. Por favor, configura la conexión primero." });
      }
      handleGenericError(res, error);
    }
  });

  // Toggle unit active status (suspend/activate)
  app.patch("/api/external-units/:id/toggle-status", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify unit exists
      const existing = await storage.getExternalUnit(id);
      if (!existing) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      // Toggle status
      const newStatus = !existing.isActive;
      const unit = await storage.updateExternalUnit(id, { isActive: newStatus });
      
      await createAuditLog(
        req, 
        "update", 
        "external_unit", 
        id, 
        `${newStatus ? 'Activated' : 'Suspended'} external unit`
      );
      
      res.json(unit);
    } catch (error: any) {
      console.error("Error toggling unit status:", error);
      handleGenericError(res, error);
    }
  });

  // Update verification status for external unit (internal QA control)
  app.patch("/api/external-units/:id/verification", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { verificationStatus, verificationNotes } = req.body;
      
      // Validate verification status
      if (!['unverified', 'pending_review', 'verified'].includes(verificationStatus)) {
        return res.status(400).json({ message: "Invalid verification status" });
      }
      
      // Verify unit exists
      const existing = await storage.getExternalUnit(id);
      if (!existing) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      const userId = req.user?.claims?.sub || req.user?.id;
      
      // Build update data
      const updateData: any = {
        verificationStatus,
        verificationNotes: verificationNotes || null,
      };
      
      // Set verification timestamp and user if status is 'verified'
      if (verificationStatus === 'verified') {
        updateData.verifiedAt = new Date();
        updateData.verifiedBy = userId;
      } else if (verificationStatus === 'unverified') {
        updateData.verifiedAt = null;
        updateData.verifiedBy = null;
      }
      
      const unit = await storage.updateExternalUnit(id, updateData);
      
      await createAuditLog(
        req, 
        "update", 
        "external_unit", 
        id, 
        `Updated verification status to ${verificationStatus}`
      );
      
      res.json(unit);
    } catch (error: any) {
      console.error("Error updating verification status:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-units/import-from-sheet - Import units from Google Sheets (TRH specific)
  app.post("/api/external-units/import-from-sheet", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { spreadsheetId, sheetName = 'Renta/Long Term', startRow = 2, limit = 100, dryRun = false } = req.body;
      
      if (!spreadsheetId) {
        return res.status(400).json({ message: "Spreadsheet ID is required" });
      }
      
      // Read data from sheet
      const rawRows = await readTRHUnitsFromSheet(spreadsheetId, sheetName, startRow, limit);
      const parsedUnits = rawRows.map(row => parseTRHRow(row));
      
      // Filter out rows without valid unit numbers
      const validUnits = parsedUnits.filter(u => u.unitNumber && u.condominiumName);
      
      if (dryRun) {
        // Preview mode - return parsed data without inserting
        return res.json({
          success: true,
          dryRun: true,
          totalRows: rawRows.length,
          validUnits: validUnits.length,
          skippedRows: rawRows.length - validUnits.length,
          preview: validUnits.slice(0, 10), // Show first 10 as preview
          condominiums: [...new Set(validUnits.map(u => u.condominiumName))],
        });
      }
      
      // Get or create condominiums
      const condominiumMap: Record<string, string> = {};
      const uniqueCondos = [...new Set(validUnits.map(u => u.condominiumName))];
      
      for (const condoName of uniqueCondos) {
        // Try to find existing condominium
        const existingCondos = await db.select()
          .from(externalCondominiums)
          .where(and(
            eq(externalCondominiums.agencyId, agencyId),
            sql`LOWER(${externalCondominiums.name}) = LOWER(${condoName})`
          ))
          .limit(1);
        
        if (existingCondos.length > 0) {
          condominiumMap[condoName] = existingCondos[0].id;
        } else {
          // Create new condominium
          const [newCondo] = await db.insert(externalCondominiums)
            .values({
              agencyId,
              name: condoName,
              zone: validUnits.find(u => u.condominiumName === condoName)?.zone,
              createdBy: req.user.id,
            })
            .returning();
          condominiumMap[condoName] = newCondo.id;
        }
      }
      
      let imported = 0;
      let updated = 0;
      let errors: string[] = [];
      
      for (const unit of validUnits) {
        try {
          const condominiumId = condominiumMap[unit.condominiumName];
          
          // Check if unit already exists by sheetRowId
          const existingUnit = unit.sheetRowId 
            ? await db.select()
                .from(externalUnits)
                .where(and(
                  eq(externalUnits.agencyId, agencyId),
                  eq(externalUnits.sheetRowId, unit.sheetRowId)
                ))
                .limit(1)
            : [];
          
          if (existingUnit.length > 0) {
            // Update existing unit
            await db.update(externalUnits)
              .set({
                condominiumId,
                unitNumber: unit.unitNumber,
                zone: unit.zone,
          condominiumName: condoName || null,
          unitNumber: unit.unitNumber,
                propertyType: unit.propertyType,
                floor: unit.floor,
                bedrooms: unit.bedrooms,
                bathrooms: unit.bathrooms ? String(unit.bathrooms) : null,
                price: unit.price ? String(unit.price) : null,
                commissionType: unit.commissionType,
                petFriendly: unit.petFriendly,
                allowsSublease: unit.allowsSublease,
                virtualTourUrl: unit.virtualTourUrl,
                googleMapsUrl: unit.googleMapsUrl,
                photosDriveLink: unit.photosDriveLink,
                includedServices: unit.includedServices,
                syncedFromSheet: true,
                lastSheetSync: new Date(),
                updatedAt: new Date(),
              })
              .where(eq(externalUnits.id, existingUnit[0].id));
            updated++;
          } else {
            // Insert new unit
            await db.insert(externalUnits)
              .values({
                agencyId,
                condominiumId,
                unitNumber: unit.unitNumber,
                zone: unit.zone,
          condominiumName: condoName || null,
          unitNumber: unit.unitNumber,
                propertyType: unit.propertyType,
                floor: unit.floor,
                bedrooms: unit.bedrooms,
                bathrooms: unit.bathrooms ? String(unit.bathrooms) : null,
                price: unit.price ? String(unit.price) : null,
                commissionType: unit.commissionType,
                petFriendly: unit.petFriendly,
                allowsSublease: unit.allowsSublease,
                virtualTourUrl: unit.virtualTourUrl,
                googleMapsUrl: unit.googleMapsUrl,
                photosDriveLink: unit.photosDriveLink,
                includedServices: unit.includedServices,
                sheetRowId: unit.sheetRowId,
                syncedFromSheet: true,
                lastSheetSync: new Date(),
                minimumTerm: '6 meses',
                maximumTerm: '5 años',
                createdBy: req.user.id,
              });
            imported++;
          }
        } catch (err: any) {
          errors.push(`Row ${unit.sheetRowId || 'unknown'}: ${err.message}`);
        }
      }
      
      await createAuditLog(
        req, 
        "update", 
        "external_unit", 
        null, 
        `Sheet sync: Imported ${imported} units, updated ${updated} units from Google Sheets`
      );
      
      res.json({
        success: true,
        imported,
        updated,
        errors: errors.length > 0 ? errors.slice(0, 10) : [],
        totalErrors: errors.length,
        totalProcessed: validUnits.length,
      });
    } catch (error: any) {
      console.error("Error importing from sheet:", error);
      handleGenericError(res, error);
    }
  });


  // Configure multer for external unit image uploads
  const externalUnitImageStorage = multer.memoryStorage();
  const uploadExternalUnitImages = multer({
    storage: externalUnitImageStorage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
    fileFilter: (req, file, cb) => {
      const allowedMimes = [
        'image/jpeg', 'image/jpg', 'image/png', 'image/webp',
        'image/avif', 'image/heic', 'image/heif', 'image/gif',
        'image/tiff', 'image/bmp'
      ];
      if (allowedMimes.includes(file.mimetype.toLowerCase())) {
        cb(null, true);
      } else {
        cb(new Error(`Formato no soportado: ${file.mimetype}. Formatos válidos: JPEG, PNG, WebP, HEIC, AVIF, GIF, TIFF, BMP`));
      }
    }
  });

  // POST /api/external-units/:id/upload-images - Upload and convert images for external unit
  app.post("/api/external-units/:id/upload-images", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), uploadExternalUnitImages.array('images', 20), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { imageType = 'primary' } = req.body; // 'primary' or 'secondary'

      // Verify unit exists and user has access
      const existing = await storage.getExternalUnit(id);
      if (!existing) {
        return res.status(404).json({ message: "Unit not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      const files = req.files as Express.Multer.File[];
      if (!files || files.length === 0) {
        return res.status(400).json({ message: "No images provided" });
      }

      const uploadedImages: Array<{ objectPath: string; publicUrl: string; width: number; height: number }> = [];
      const errors: string[] = [];

      for (const file of files) {
        try {
          // Process image (convert to WebP, resize, optimize)
          const processed = await imageProcessor.processImage(file.buffer, file.mimetype, {
            maxDimension: 2000,
            quality: 85,
            outputFormat: 'webp',
          });

          // Upload to object storage
          const result = await imageProcessor.uploadToStorage(
            processed,
            `external-units/${id}/images`
          );

          uploadedImages.push({
            objectPath: result.objectPath,
            publicUrl: result.publicUrl,
            width: result.width,
            height: result.height,
          });

          console.log(`Image uploaded: ${file.originalname} -> ${result.objectPath} (original: ${result.originalSize}, processed: ${result.processedSize})`);
        } catch (error: any) {
          console.error(`Error processing image ${file.originalname}:`, error);
          errors.push(`${file.originalname}: ${error.message}`);
        }
      }

      if (uploadedImages.length === 0) {
        return res.status(400).json({ 
          message: "Failed to process all images",
          errors 
        });
      }

      // Update unit with new images
      const currentPrimary = existing.primaryImages || [];
      const currentSecondary = existing.secondaryImages || [];
      
      const newImageUrls = uploadedImages.map(img => img.publicUrl);
      
      let updateData;
      if (imageType === 'primary') {
        updateData = { primaryImages: [...currentPrimary, ...newImageUrls] };
      } else {
        updateData = { secondaryImages: [...currentSecondary, ...newImageUrls] };
      }

      await storage.updateExternalUnit(id, updateData);

      res.json({
        success: true,
        uploaded: uploadedImages,
        errors: errors.length > 0 ? errors : undefined,
        message: `${uploadedImages.length} imagen(es) subida(s) correctamente`
      });
    } catch (error: any) {
      console.error("Error uploading images:", error);
      res.status(500).json({ message: error.message || "Failed to upload images" });
    }
  });

  // DELETE /api/external-units/:id/images - Remove image from external unit
  app.delete("/api/external-units/:id/images", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { imageUrl, imageType = 'primary' } = req.body;

      if (!imageUrl) {
        return res.status(400).json({ message: "Image URL is required" });
      }

      // Verify unit exists and user has access
      const existing = await storage.getExternalUnit(id);
      if (!existing) {
        return res.status(404).json({ message: "Unit not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      // Remove image from the appropriate array
      let updateData;
      if (imageType === 'primary') {
        const filteredImages = (existing.primaryImages || []).filter(url => url !== imageUrl);
        updateData = { primaryImages: filteredImages };
      } else {
        const filteredImages = (existing.secondaryImages || []).filter(url => url !== imageUrl);
        updateData = { secondaryImages: filteredImages };
      }

      await storage.updateExternalUnit(id, updateData);

      res.json({ success: true, message: "Imagen eliminada" });
    } catch (error: any) {
      console.error("Error deleting image:", error);
      res.status(500).json({ message: error.message || "Failed to delete image" });
    }
  });

  // POST /api/external-units/:id/upload-videos - Upload videos for external unit
  app.post("/api/external-units/:id/upload-videos", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { videoUrls } = req.body;

      if (!videoUrls || !Array.isArray(videoUrls)) {
        return res.status(400).json({ message: "Video URLs array is required" });
      }

      // Verify unit exists and user has access
      const existing = await storage.getExternalUnit(id);
      if (!existing) {
        return res.status(404).json({ message: "Unit not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      // Add new video URLs to existing
      const currentVideos = existing.videos || [];
      const newVideos = [...currentVideos, ...videoUrls];

      await storage.updateExternalUnit(id, { videos: newVideos });

      res.json({ success: true, videos: newVideos, message: "Videos agregados correctamente" });
    } catch (error: any) {
      console.error("Error adding videos:", error);
      res.status(500).json({ message: error.message || "Failed to add videos" });
    }
  });

  // Get services (payment schedules) for a unit - useful to show what services are configured
  app.get("/api/external-units/:id/services", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify unit exists
      const unit = await storage.getExternalUnit(id);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Get all rental contracts for this agency
      const allContracts = await storage.getExternalRentalContractsByAgency(unit.agencyId);
      
      // Filter to find active contract for this unit
      const activeContract = allContracts.find(c => c.unitId === id && c.status === 'active');
      
      if (!activeContract) {
        return res.json([]);
      }
      
      // Get payment schedules for the active contract
      const schedules = await storage.getExternalPaymentSchedulesByContract(activeContract.id);
      
      res.json(schedules);
    } catch (error: any) {
      console.error("Error fetching unit services:", error);
      handleGenericError(res, error);
    }
  });


  // =====================================================
  // Property Activity History - Track all activities on properties
  // =====================================================

  // GET /api/external-units/:id/activity-history - Get activity history for a unit
  app.get("/api/external-units/:id/activity-history", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { limit = "50", offset = "0" } = req.query;
      
      const limitNum = Math.min(parseInt(limit as string, 10) || 50, 100);
      const offsetNum = parseInt(offset as string, 10) || 0;
      
      // Verify unit exists
      const unit = await storage.getExternalUnit(id);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Get activity history for this unit
      const activities = await db.select()
        .from(externalPropertyActivityHistory)
        .where(eq(externalPropertyActivityHistory.unitId, id))
        .orderBy(desc(externalPropertyActivityHistory.createdAt))
        .limit(limitNum)
        .offset(offsetNum);
      
      // Get total count
      const countResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(externalPropertyActivityHistory)
        .where(eq(externalPropertyActivityHistory.unitId, id));
      
      const total = Number(countResult[0]?.count || 0);
      
      res.json({
        activities,
        pagination: {
          total,
          limit: limitNum,
          offset: offsetNum,
          hasMore: offsetNum + limitNum < total
        }
      });
    } catch (error: any) {
      console.error("Error fetching unit activity history:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/property-activity - Log a property activity (internal use)
  app.post("/api/property-activity", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }
      
      const userId = req.user?.claims?.sub || req.user?.id;
      const userDetails = await storage.getUser(userId);
      
      const { unitId, activityType, leadId, clientId, offerTokenId, appointmentId, showingId, contractId, details } = req.body;
      
      if (!unitId || !activityType) {
        return res.status(400).json({ message: "unitId and activityType are required" });
      }
      
      // Verify unit exists and belongs to agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      if (unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get lead/client names if IDs provided
      let leadName = null;
      let clientName = null;
      
      if (leadId) {
        const lead = await storage.getExternalLead(leadId);
        if (lead) {
          leadName = `\${lead.firstName || ''} \${lead.lastName || ''}`.trim() || null;
        }
      }
      
      if (clientId) {
        const client = await storage.getExternalClient(clientId);
        if (client) {
          clientName = `\${client.firstName || ''} \${client.lastName || ''}`.trim() || null;
        }
      }
      
      // Create activity record
      const [activity] = await db.insert(externalPropertyActivityHistory).values({
        agencyId,
        unitId,
        condominiumId: unit.condominiumId || null,
        activityType,
        leadId: leadId || null,
        leadName,
        clientId: clientId || null,
        clientName,
        offerTokenId: offerTokenId || null,
        appointmentId: appointmentId || null,
        showingId: showingId || null,
        contractId: contractId || null,
        performedBy: userId,
        performedByName: userDetails ? `\${userDetails.firstName || ''} \${userDetails.lastName || ''}`.trim() || null : null,
        details: details || null,
      }).returning();
      
      res.status(201).json(activity);
    } catch (error: any) {
      console.error("Error creating property activity:", error);
      handleGenericError(res, error);
    }
  });

  // External Owners - Consolidated endpoint for all agency owners
  app.get("/api/external-owners", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Optimized: Single query to get all owners with their units for the agency
      const owners = await db.select({
        id: externalUnitOwners.id,
        unitId: externalUnitOwners.unitId,
        ownerName: externalUnitOwners.ownerName,
        ownerEmail: externalUnitOwners.ownerEmail,
        ownerPhone: externalUnitOwners.ownerPhone,
        ownershipPercentage: externalUnitOwners.ownershipPercentage,
        isActive: externalUnitOwners.isActive,
        createdBy: externalUnitOwners.createdBy,
        createdAt: externalUnitOwners.createdAt,
        updatedAt: externalUnitOwners.updatedAt,
        // Unit fields
        unit: {
          id: externalUnits.id,
          unitNumber: externalUnits.unitNumber,
          condominiumId: externalUnits.condominiumId,
          rentalStatus: externalUnits.rentalStatus,
          bedroomCount: externalUnits.bedroomCount,
          bathroomCount: externalUnits.bathroomCount,
          unitType: externalUnits.propertyType,
          agencyId: externalUnits.agencyId,
        }
      })
      .from(externalUnitOwners)
      .innerJoin(externalUnits, eq(externalUnitOwners.unitId, externalUnits.id))
      .where(eq(externalUnits.agencyId, agencyId))
      .orderBy(desc(externalUnitOwners.isActive), desc(externalUnitOwners.createdAt));
      
      res.json(owners);
    } catch (error: any) {
      console.error("Error fetching external owners:", error);
      handleGenericError(res, error);
    }
  });


// GET /api/external/portfolio-summary - Optimized endpoint for owner portfolio page
  app.get("/api/external/portfolio-summary", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const { limit = "100", offset = "0", search, minUnits, condominiumId, isActive } = req.query;
      const limitNum = Math.min(parseInt(limit as string, 10) || 100, 500);
      const offsetNum = parseInt(offset as string, 10) || 0;

      const currentYear = new Date().getFullYear();
      const yearStart = new Date(currentYear, 0, 1);
      const yearEnd = new Date(currentYear + 1, 0, 1);

      // Use raw SQL to avoid Drizzle ORM issues with complex joins
      const ownersResult = await db.execute(sql`
        SELECT 
          uo.id,
          uo.unit_id as "unitId",
          uo.owner_name as "ownerName",
          uo.owner_email as "ownerEmail",
          uo.owner_phone as "ownerPhone",
          uo.ownership_percentage as "ownershipPercentage",
          uo.is_active as "isActive",
          
          
          uo.notes,
          uo.created_by as "createdBy",
          uo.created_at as "createdAt",
          uo.updated_at as "updatedAt",
          u.unit_number as "unitNumber",
          u.condominium_id as "condominiumId",
          u.typology as "typology",
          c.name as "condominiumName"
        FROM external_unit_owners uo
        INNER JOIN external_units u ON uo.unit_id = u.id
        LEFT JOIN external_condominiums c ON u.condominium_id = c.id
        WHERE u.agency_id = ${agencyId}
        ORDER BY uo.is_active DESC, uo.created_at DESC
      `);

      const ownersWithUnits = ownersResult.rows as any[];

      if (ownersWithUnits.length === 0) {
        return res.json({ data: [], total: 0, page: Math.floor(offsetNum / limitNum) + 1, pageSize: limitNum });
      }

      // Get contracts using raw SQL
      const contractsResult = await db.execute(sql`
        SELECT id, unit_id as "unitId", start_date as "startDate", end_date as "endDate", status
        FROM external_rental_contracts
        WHERE agency_id = ${agencyId}
      `);
      const allContracts = contractsResult.rows as any[];

      // Get financial transactions using raw SQL
      const transactionsResult = await db.execute(sql`
        SELECT owner_id as "ownerId", unit_id as "unitId", direction, payee_role as "payeeRole", payer_role as "payerRole", gross_amount as "grossAmount"
        FROM external_financial_transactions
        WHERE agency_id = ${agencyId}
      `);
      const rawTransactions = transactionsResult.rows as any[];

      // Aggregate financial data in JavaScript
      const summaryMap = new Map<string, { ownerId: string | null; unitId: string | null; direction: string; payeeRole: string; payerRole: string; totalAmount: number }>();
      for (const tx of rawTransactions) {
        const key = `${tx.ownerId || 'null'}_${tx.unitId || 'null'}_${tx.direction}_${tx.payeeRole}_${tx.payerRole}`;
        if (!summaryMap.has(key)) {
          summaryMap.set(key, {
            ownerId: tx.ownerId,
            unitId: tx.unitId,
            direction: tx.direction,
            payeeRole: tx.payeeRole,
            payerRole: tx.payerRole,
            totalAmount: 0,
          });
        }
        summaryMap.get(key)!.totalAmount += parseFloat(tx.grossAmount || '0');
      }
      const financialSummary = Array.from(summaryMap.values()).map(s => ({
        ...s,
        totalAmount: s.totalAmount.toFixed(2),
      }));

      // Group owners by name and email
      const ownerGroups = new Map<string, any[]>();
      ownersWithUnits.forEach(owner => {
        const key = `${owner.ownerName.toLowerCase()}_${owner.ownerEmail?.toLowerCase() || ''}`;
        if (!ownerGroups.has(key)) {
          ownerGroups.set(key, []);
        }
        ownerGroups.get(key)!.push(owner);
      });

      const totalYearDays = Math.ceil((yearEnd.getTime() - yearStart.getTime()) / (1000 * 60 * 60 * 24));
      const portfolios: any[] = [];

      ownerGroups.forEach((ownerInstances, _key) => {
        const primaryOwner = ownerInstances.sort((a, b) => 
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        )[0];

        let totalIncome = 0;
        let totalExpenses = 0;
        let activeContracts = 0;
        let totalOccupiedDays = 0;
        const typologies = new Set<string>();
        const condominiumNames = new Set<string>();
        const unitNumbers: string[] = [];

        ownerInstances.forEach(oi => {
          if (oi.propertyType) typologies.add(oi.propertyType);
          if (oi.condominiumName) condominiumNames.add(oi.condominiumName);
          if (oi.unitNumber) unitNumbers.push(oi.unitNumber);

          const unitContracts = allContracts.filter(c => c.unitId === oi.unitId);
          activeContracts += unitContracts.filter(c => c.status === "active").length;

          unitContracts.forEach(contract => {
            if (contract.status === "active" || contract.status === "completed") {
              const contractStart = new Date(Math.max(new Date(contract.startDate).getTime(), yearStart.getTime()));
              const contractEnd = new Date(Math.min(new Date(contract.endDate).getTime(), yearEnd.getTime()));
              if (contractEnd > contractStart) {
                totalOccupiedDays += Math.ceil((contractEnd.getTime() - contractStart.getTime()) / (1000 * 60 * 60 * 24));
              }
            }
          });

          const unitFinancials = financialSummary.filter(fs => fs.unitId === oi.unitId);
          unitFinancials.forEach(uf => {
            if (uf.direction === "income" && uf.payeeRole === "owner") {
              totalIncome += parseFloat(uf.totalAmount);
            } else if (uf.direction === "expense" && uf.payerRole === "owner") {
              totalExpenses += parseFloat(uf.totalAmount);
            }
          });
        });

        const occupancyRate = ownerInstances.length > 0 && totalYearDays > 0
          ? (totalOccupiedDays / (ownerInstances.length * totalYearDays)) * 100
          : 0;

        portfolios.push({
          owner: {
            id: primaryOwner.id,
            unitId: primaryOwner.unitId,
            ownerName: primaryOwner.ownerName,
            ownerEmail: primaryOwner.ownerEmail,
            ownerPhone: primaryOwner.ownerPhone,
            ownershipPercentage: primaryOwner.ownershipPercentage,
            isActive: primaryOwner.isActive,
            notes: primaryOwner.notes,
            createdBy: primaryOwner.createdBy,
            createdAt: primaryOwner.createdAt,
            updatedAt: primaryOwner.updatedAt,
          },
          units: ownerInstances.map(u => ({
            id: u.unitId,
            unitNumber: u.unitNumber,
            condominiumId: u.condominiumId,
            typology: u.typology,
          })),
          totalIncome,
          totalExpenses,
          balance: totalIncome - totalExpenses,
          activeContracts,
          occupancyRate: Math.round(occupancyRate * 100) / 100,
          typologies: Array.from(typologies),
          condominiums: Array.from(condominiumNames),
          unitNumbers,
        });
      });

      let filteredPortfolios = portfolios;

      if (search) {
        const searchLower = (search as string).toLowerCase();
        filteredPortfolios = filteredPortfolios.filter(p =>
          p.owner.ownerName.toLowerCase().includes(searchLower) ||
          p.owner.ownerEmail?.toLowerCase().includes(searchLower) ||
          p.owner.ownerPhone?.includes(search as string)
        );
      }

      if (minUnits) {
        const minUnitsNum = parseInt(minUnits as string, 10);
        if (!isNaN(minUnitsNum) && minUnitsNum > 0) {
          filteredPortfolios = filteredPortfolios.filter(p => p.units.length >= minUnitsNum);
        }
      }

      if (condominiumId) {
        filteredPortfolios = filteredPortfolios.filter(p =>
          p.units.some((u: any) => u.condominiumId === condominiumId)
        );
      }

      if (isActive !== undefined) {
        const activeFilter = isActive === 'true';
        filteredPortfolios = filteredPortfolios.filter(p => p.owner.isActive === activeFilter);
      }

      const paginatedPortfolios = filteredPortfolios.slice(offsetNum, offsetNum + limitNum);

      res.json({
        data: paginatedPortfolios,
        total: filteredPortfolios.length,
        page: Math.floor(offsetNum / limitNum) + 1,
        pageSize: limitNum,
      });
    } catch (error: any) {
      console.error("Error fetching portfolio summary:", error);
      handleGenericError(res, error);
    }
  });


  // External Unit Owners Routes
  app.get("/api/external-unit-owners/by-unit/:unitId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      
      // Verify unit exists and get its agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const owners = await storage.getExternalUnitOwnersByUnit(unitId);
      
      res.json(owners);
    } catch (error: any) {
      console.error("Error fetching unit owners:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-unit-owners/active/:unitId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      
      // Verify unit exists and get its agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Get all owners for this unit and filter only active ones
      const allOwners = await storage.getExternalUnitOwnersByUnit(unitId);
      const activeOwners = allOwners.filter(owner => owner.isActive);
      
      res.json(activeOwners);
    } catch (error: any) {
      console.error("Error fetching active unit owners:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-unit-owners/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const owner = await storage.getExternalUnitOwner(id);
      
      if (!owner) {
        return res.status(404).json({ message: "Unit owner not found" });
      }
      
      // Verify unit ownership through unit
      const unit = await storage.getExternalUnit(owner.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      res.json(owner);
    } catch (error: any) {
      console.error("Error fetching external unit owner:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-unit-owners", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalUnitOwnerSchema.parse(req.body);
      const owner = await storage.createExternalUnitOwner({
        ...validatedData,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_unit_owner", owner.id, "Created external unit owner");
      res.status(201).json(owner);
    } catch (error: any) {
      console.error("Error creating external unit owner:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-unit-owners/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify owner exists
      const existing = await storage.getExternalUnitOwner(id);
      if (!existing) {
        return res.status(404).json({ message: "Unit owner not found" });
      }
      
      // Verify unit ownership through unit
      const unit = await storage.getExternalUnit(existing.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Validate update data
      const validatedData = updateExternalUnitOwnerSchema.parse(req.body);
      
      // Prevent unitId and createdBy modification
      const updateData = { ...validatedData };
      delete (updateData as any).unitId;
      delete (updateData as any).createdBy;
      
      const owner = await storage.updateExternalUnitOwner(id, updateData);
      
      await createAuditLog(req, "update", "external_unit_owner", id, "Updated external unit owner");
      res.json(owner);
    } catch (error: any) {
      console.error("Error updating external unit owner:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-unit-owners/:unitId/set-active/:ownerId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { unitId, ownerId } = req.params;
      
      // Verify unit exists and get its agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const owner = await storage.setActiveExternalUnitOwner(unitId, ownerId);
      
      await createAuditLog(req, "update", "external_unit_owner", ownerId, `Set as active owner for unit ${unitId}`);
      res.json(owner);
    } catch (error: any) {
      console.error("Error setting active unit owner:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-unit-owners/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalUnitOwner(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Unit owner not found" });
      }
      
      // Verify unit ownership through unit
      const unit = await storage.getExternalUnit(existing.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalUnitOwner(id);
      
      await createAuditLog(req, "delete", "external_unit_owner", id, "Deleted external unit owner");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external unit owner:", error);
      handleGenericError(res, error);
    }
  });

  // External Unit Access Controls Routes
  app.get("/api/external-unit-access-controls/by-unit/:unitId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      const { isActive } = req.query;
      
      // Verify unit exists and get its agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const filters: any = {};
      if (isActive !== undefined) filters.isActive = isActive === 'true';
      
      const controls = await storage.getExternalUnitAccessControlsByUnit(unitId, filters);
      
      // Decrypt sensitive data for all controls in response
      const controlsResponse = controls.map(control => {
        const decrypted = { ...control };
        if (decrypted.accessCode) {
          try {
            decrypted.accessCode = decrypt(decrypted.accessCode);
          } catch (e) {
            console.error('Failed to decrypt accessCode for access control:', control.id);
            decrypted.accessCode = ''; // Return empty if decryption fails
          }
        }
        return decrypted;
      });
      
      res.json(controlsResponse);
    } catch (error: any) {
      console.error("Error fetching unit access controls:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external-unit-access-controls/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const control = await storage.getExternalUnitAccessControl(id);
      
      if (!control) {
        return res.status(404).json({ message: "Access control not found" });
      }
      
      // Verify unit ownership through unit
      const unit = await storage.getExternalUnit(control.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Decrypt sensitive data for response
      const controlResponse = { ...control };
      if (controlResponse.accessCode) {
        try {
          controlResponse.accessCode = decrypt(controlResponse.accessCode);
        } catch (e) {
          console.error('Failed to decrypt accessCode for control:', control.id);
          controlResponse.accessCode = '';
        }
      }
      
      res.json(controlResponse);
    } catch (error: any) {
      console.error("Error fetching external unit access control:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-unit-access-controls", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const validatedData = insertExternalUnitAccessControlSchema.parse(req.body);
      
      
      // Verify unit exists and user has agency access (tenant isolation)
      const unit = await storage.getExternalUnit(validatedData.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      // Encrypt sensitive data before storing
      const dataToStore: any = {
        ...validatedData,
        createdBy: req.user.id,
      };
      
      if (dataToStore.accessCode) {
        dataToStore.accessCode = encrypt(dataToStore.accessCode);
      }
      
      const control = await storage.createExternalUnitAccessControl(dataToStore);
      
      // Decrypt for response
      const controlResponse = { ...control };
      if (controlResponse.accessCode) {
        try {
          controlResponse.accessCode = decrypt(controlResponse.accessCode);
        } catch (e) {
          console.error('Failed to decrypt accessCode for control:', control.id);
          controlResponse.accessCode = '';
        }
      }
      
      await createAuditLog(req, "create", "external_unit_access_control", control.id, "Created external unit access control", {
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });
      res.status(201).json(controlResponse);
    } catch (error: any) {
      console.error("Error creating external unit access control:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-unit-access-controls/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify access control exists
      const existing = await storage.getExternalUnitAccessControl(id);
      if (!existing) {
        return res.status(404).json({ message: "Access control not found" });
      }
      
      // Verify unit ownership through unit
      const unit = await storage.getExternalUnit(existing.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Validate update data
      const validatedData = updateExternalUnitAccessControlSchema.parse(req.body);
      
      // Prevent unitId and createdBy modification
      const updateData: any = { ...validatedData };
      delete updateData.unitId;
      delete updateData.createdBy;
      
      // Encrypt sensitive data before storing
      if (updateData.accessCode) {
        updateData.accessCode = encrypt(updateData.accessCode);
      }
      
      const control = await storage.updateExternalUnitAccessControl(id, updateData);
      
      // Decrypt for response
      const controlResponse = { ...control };
      if (controlResponse.accessCode) {
        try {
          controlResponse.accessCode = decrypt(controlResponse.accessCode);
        } catch (e) {
          console.error('Failed to decrypt accessCode for control:', control.id);
          controlResponse.accessCode = '';
        }
      }
      
      await createAuditLog(req, "update", "external_unit_access_control", id, "Updated external unit access control", {
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });
      res.json(controlResponse);
    } catch (error: any) {
      console.error("Error updating external unit access control:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-unit-access-controls/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalUnitAccessControl(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Access control not found" });
      }
      
      // Verify unit ownership through unit
      const unit = await storage.getExternalUnit(existing.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalUnitAccessControl(id);
      
      await createAuditLog(req, "delete", "external_unit_access_control", id, "Deleted external unit access control");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external unit access control:", error);
      handleGenericError(res, error);
    }
  });


  // External Unit Legal Documents Routes
  // GET /api/external-unit-documents/by-unit/:unitId - Get all documents for a unit
  app.get("/api/external-unit-documents/by-unit/:unitId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      
      // Verify unit exists and user has access
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const documents = await storage.getExternalUnitDocumentsByUnit(unitId);
      res.json(documents);
    } catch (error: any) {
      console.error("Error fetching unit documents:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-unit-documents/:id - Get a single document by ID
  app.get("/api/external-unit-documents/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const document = await storage.getExternalUnitDocument(id);
      
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      // Verify ownership through unit
      const unit = await storage.getExternalUnit(document.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      res.json(document);
    } catch (error: any) {
      console.error("Error fetching unit document:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-unit-documents - Create a new document
  app.post("/api/external-unit-documents", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { unitId, documentType, documentName, documentUrl, description, expirationDate } = req.body;
      
      if (!unitId || !documentType || !documentName || !documentUrl) {
        return res.status(400).json({ message: "Unit ID, document type, name, and URL are required" });
      }
      
      // Verify unit exists and user has access
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const document = await storage.createExternalUnitDocument({
        unitId,
        agencyId: unit.agencyId,
        documentType,
        documentName,
        documentUrl,
        description: description || null,
        expirationDate: expirationDate ? new Date(expirationDate) : null,
        uploadedBy: req.user?.id || null,
      });
      
      await createAuditLog(req, "create", "external_unit_document", document.id, "Created unit document: " + documentName);
      res.status(201).json(document);
    } catch (error: any) {
      console.error("Error creating unit document:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-unit-documents/:id - Update a document
  app.patch("/api/external-unit-documents/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalUnitDocument(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      // Verify ownership through unit
      const unit = await storage.getExternalUnit(existing.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const { documentType, documentName, documentUrl, description, expirationDate, isActive } = req.body;
      
      const updates: any = {};
      if (documentType !== undefined) updates.documentType = documentType;
      if (documentName !== undefined) updates.documentName = documentName;
      if (documentUrl !== undefined) updates.documentUrl = documentUrl;
      if (description !== undefined) updates.description = description;
      if (expirationDate !== undefined) updates.expirationDate = expirationDate ? new Date(expirationDate) : null;
      if (isActive !== undefined) updates.isActive = isActive;
      
      const document = await storage.updateExternalUnitDocument(id, updates);
      
      await createAuditLog(req, "update", "external_unit_document", id, "Updated unit document");
      res.json(document);
    } catch (error: any) {
      console.error("Error updating unit document:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-unit-documents/:id - Delete a document
  app.delete("/api/external-unit-documents/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalUnitDocument(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      // Verify ownership through unit
      const unit = await storage.getExternalUnit(existing.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Associated unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalUnitDocument(id);
      
      await createAuditLog(req, "delete", "external_unit_document", id, "Deleted unit document");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting unit document:", error);
      handleGenericError(res, error);
    }
  });
  // External Check-Out Reports Routes
  // GET /api/external-checkout-reports/:contractId - Get checkout report by contract
  app.get("/api/external-checkout-reports/contract/:contractId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { contractId } = req.params;
      
      // Verify contract exists and user has access
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      const report = await storage.getExternalCheckoutReportByContract(contractId);
      res.json(report || null);
    } catch (error: any) {
      console.error("Error fetching checkout report:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-checkout-reports/:id - Get specific checkout report
  app.get("/api/external-checkout-reports/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const report = await storage.getExternalCheckoutReport(id);
      
      if (!report) {
        return res.status(404).json({ message: "Checkout report not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, report.agencyId);
      if (!hasAccess) return;
      
      res.json(report);
    } catch (error: any) {
      console.error("Error fetching checkout report:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-checkout-reports - Get all checkout reports for agency
  app.get("/api/external-checkout-reports", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { status } = req.query;
      const reports = await storage.getExternalCheckoutReportsByAgency(agencyId, {
        status: status as string | undefined,
      });
      
      res.json(reports);
    } catch (error: any) {
      console.error("Error fetching checkout reports:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-checkout-reports - Create new checkout report
  app.post("/api/external-checkout-reports", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      // Verify contract exists and belongs to agency
      const contract = await storage.getExternalRentalContract(req.body.contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      if (contract.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Check if checkout report already exists for this contract
      const existing = await storage.getExternalCheckoutReportByContract(req.body.contractId);
      if (existing) {
        return res.status(400).json({ message: "Checkout report already exists for this contract" });
      }
      
      const report = await storage.createExternalCheckoutReport({
        ...req.body,
        agencyId,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_checkout_report", report.id, "Created checkout report");
      res.status(201).json(report);
    } catch (error: any) {
      console.error("Error creating checkout report:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-checkout-reports/:id - Update checkout report
  app.patch("/api/external-checkout-reports/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalCheckoutReport(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Checkout report not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      const report = await storage.updateExternalCheckoutReport(id, req.body);
      
      await createAuditLog(req, "update", "external_checkout_report", id, "Updated checkout report");
      res.json(report);
    } catch (error: any) {
      console.error("Error updating checkout report:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-checkout-reports/:id/complete - Complete checkout report
  app.post("/api/external-checkout-reports/:id/complete", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalCheckoutReport(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Checkout report not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      const report = await storage.completeExternalCheckoutReport(id);
      
      await createAuditLog(req, "update", "external_checkout_report", id, "Completed checkout report");
      res.json(report);
    } catch (error: any) {
      console.error("Error completing checkout report:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-checkout-reports/:id - Delete checkout report
  app.delete("/api/external-checkout-reports/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalCheckoutReport(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Checkout report not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalCheckoutReport(id);
      
      await createAuditLog(req, "delete", "external_checkout_report", id, "Deleted checkout report");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting checkout report:", error);
      handleGenericError(res, error);
    }
  });

  // ==============================
  // External Clients Routes
  // ==============================

  // GET /api/external-clients - Get all clients for agency (with pagination, search, and sorting)
  app.get("/api/external-clients", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { status, isVerified, search, sortField, sortOrder, limit = '50', offset = '0' } = req.query;
      
      // Validate and parse limit/offset
      // Allow up to 10000 for dialog selection scenarios (most agencies have < 10k clients)
      const limitNum = Math.max(1, Math.min(parseInt(limit as string, 10) || 50, 10000));
      const offsetNum = Math.max(0, parseInt(offset as string, 10) || 0);
      
      const filters = {
        status: status as string | undefined,
        isVerified: isVerified === 'true' ? true : isVerified === 'false' ? false : undefined,
        search: search as string | undefined,
        sortField: sortField as string | undefined,
        sortOrder: (sortOrder === 'asc' || sortOrder === 'desc') ? sortOrder : 'desc' as 'asc' | 'desc',
        limit: limitNum,
        offset: offsetNum,
      };
      
      const [clients, total] = await Promise.all([
        storage.getExternalClientsByAgency(agencyId, filters),
        storage.getExternalClientsCountByAgency(agencyId, {
          status: filters.status,
          isVerified: filters.isVerified,
          search: filters.search,
          sellerId: filters.sellerId,
          sellerScope: filters.sellerScope,
          expiringDays: filters.expiringDays,
        }),
      ]);
      
      res.json({
        data: clients,
        total,
        limit: limitNum,
        offset: offsetNum,
        hasMore: offsetNum + clients.length < total,
      });
    } catch (error: any) {
      console.error("Error fetching external clients:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-clients/:id - Get specific client
  app.get("/api/external-clients/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const client = await storage.getExternalClient(id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      res.json(client);
    } catch (error: any) {
      console.error("Error fetching external client:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-clients - Create new client
  app.post("/api/external-clients", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const validatedData = insertExternalClientSchema.parse(req.body);
      
      // Check for duplicates before creating
      const duplicate = await storage.checkExternalClientDuplicate(
        agencyId,
        validatedData.firstName,
        validatedData.lastName,
        validatedData.phone
      );
      
      if (duplicate) {
        return res.status(409).json({ 
          message: "Duplicate client detected",
          detail: `A client with the name ${duplicate.firstName} ${duplicate.lastName} and matching phone number last 4 digits already exists in your agency.`,
          duplicate: {
            id: duplicate.id,
            firstName: duplicate.firstName,
            lastName: duplicate.lastName,
            phone: duplicate.phone,
            email: duplicate.email,
          }
        });
      }
      
      const client = await storage.createExternalClient({
        ...validatedData,
        agencyId,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_client", client.id, "Created new client");
      res.status(201).json(client);
    } catch (error: any) {
      console.error("Error creating external client:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-clients/:id - Update client
  app.patch("/api/external-clients/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalClient(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      const validatedData = updateExternalClientSchema.parse(req.body);
      const client = await storage.updateExternalClient(id, validatedData);
      
      await createAuditLog(req, "update", "external_client", id, "Updated client");
      res.json(client);
    } catch (error: any) {
      console.error("Error updating external client:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-clients/:id - Delete client
  app.delete("/api/external-clients/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalClient(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalClient(id);
      
      await createAuditLog(req, "delete", "external_client", id, "Deleted client");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external client:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-clients/:id/convert-to-lead - Convert client back to lead
  app.post("/api/external-clients/:id/convert-to-lead", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body; // manual, rental_ended, etc.
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const client = await storage.getExternalClient(id);
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }

      // Verify agency ownership
      if (client.agencyId !== agencyId) {
        return res.status(403).json({ message: "No access to this client" });
      }

      // Check if already converted
      if (client.convertedBackToLeadId) {
        return res.status(400).json({ message: "Este cliente ya fue reconvertido a lead" });
      }

      // Get agency name for seller assignment
      const agencyResult = await db.select({
        name: externalAgencies.name,
      })
      .from(externalAgencies)
      .where(eq(externalAgencies.id, agencyId))
      .limit(1);
      
      const agencyName = agencyResult[0]?.name || 'Agencia';

      // Create new lead from client data
      const leadData = {
        agencyId,
        registrationType: 'seller' as const,
        firstName: client.firstName,
        lastName: client.lastName,
        email: client.email || undefined,
        phone: client.phone || undefined,
        status: 'nuevo_lead' as const,
        source: `reconversion_cliente_${reason || 'manual'}`,
        notes: `Reconvertido desde cliente: ${client.firstName} ${client.lastName}. Razón: ${reason || 'manual'}. Cliente original ID: ${client.id}`,
        bedroomsText: client.bedroomsPreference?.toString() || undefined,
        sellerName: agencyName, // Assign agency as the seller
        createdBy: req.user.id,
      };

      const newLead = await storage.createExternalLead(leadData);

      // Update client to mark as converted back
      await storage.updateExternalClient(id, {
        status: 'archived',
        convertedBackToLeadId: newLead.id,
        convertedBackToLeadAt: new Date(),
        convertedBackReason: reason || 'manual',
      });

      await createAuditLog(req, "create", "external_lead", newLead.id, `Reconverted from client ${client.id}`);
      await createAuditLog(req, "update", "external_client", id, `Converted back to lead ${newLead.id}`);
      
      res.status(201).json({ 
        lead: newLead,
        message: "Cliente reconvertido a lead exitosamente" 
      });
    } catch (error: any) {
      console.error("Error converting client to lead:", error);
      handleGenericError(res, error);
    }
  });

  // ==============================
  // GET /api/external-sellers - Get sellers for agency (for lead assignment dropdown)
  app.get("/api/external-sellers", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      // Get agency info to include as first seller option
      const agency = await db.select({
        id: externalAgencies.id,
        name: externalAgencies.name,
      })
      .from(externalAgencies)
      .where(eq(externalAgencies.id, agencyId))
      .limit(1);
      
      // Get all sellers for this agency
      const sellers = await db.select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        email: users.email,
      })
      .from(users)
      .where(and(
        eq(users.externalAgencyId, agencyId),
        eq(users.role, 'external_agency_seller'),
        eq(users.isSuspended, false)
      ))
      .orderBy(users.firstName);
      
      // Include agency as first option (using agency ID prefixed with 'agency_')
      const agencyAsSeller = agency[0] ? {
        id: `agency_${agency[0].id}`,
        firstName: agency[0].name,
        lastName: '',
        email: '',
        isAgency: true
      } : null;
      
      const result = agencyAsSeller ? [agencyAsSeller, ...sellers] : sellers;
      
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching external sellers:", error);
      handleGenericError(res, error);
    }
  });

  // External Leads Routes
  // ==============================

  // GET /api/external-leads - Get all leads for agency
  app.get("/api/external-leads", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { status, registrationType, sellerId, expiringDays, search, sortField, sortOrder, limit = '50', offset = '0' } = req.query;
      
      const limitNum = Math.max(1, Math.min(parseInt(limit as string, 10) || 50, 1000));
      const offsetNum = Math.max(0, parseInt(offset as string, 10) || 0);
      
      // Security: Force seller scoping for seller users - they can only see their own leads
      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      const isSeller = userRole === 'external_agency_seller';
      const effectiveSellerId = isSeller ? userId : (sellerId as string | undefined);
      console.log("[DEBUG] external-leads filter:", { userId, userRole, isSeller, effectiveSellerId, agencyId });
      
      const filters = {
        status: status as string | undefined,
        registrationType: registrationType as string | undefined,
        sellerId: effectiveSellerId,
        sellerScope: isSeller,
        expiringDays: expiringDays ? parseInt(expiringDays as string, 10) : undefined,
        search: search as string | undefined,
        sortField: sortField as string | undefined,
        sortOrder: (sortOrder === 'asc' || sortOrder === 'desc') ? sortOrder : 'desc' as 'asc' | 'desc',
        limit: limitNum,
        offset: offsetNum,
      };
      
      const [leads, total] = await Promise.all([
        storage.getExternalLeadsByAgency(agencyId, filters),
        storage.getExternalLeadsCountByAgency(agencyId, {
          status: filters.status,
          registrationType: filters.registrationType,
          search: filters.search,
          sellerId: filters.sellerId,
          sellerScope: filters.sellerScope,
          expiringDays: filters.expiringDays,
        }),
      ]);
      
      res.json({
        data: leads,
        total,
        limit: limitNum,
        offset: offsetNum,
        hasMore: offsetNum + leads.length < total,
      });
    } catch (error: any) {
      console.error("Error fetching external leads:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-leads/:id - Get specific lead
  app.get("/api/external-leads/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      res.json(lead);
    } catch (error: any) {
      console.error("Error fetching external lead:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-leads - Create new lead
  app.post("/api/external-leads", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      let agencyId = await getUserAgencyId(req);
      
      // Master/admin users can specify agencyId in the body
      if ((userRole === 'master' || userRole === 'admin') && req.body.agencyId) {
        agencyId = req.body.agencyId;
      }
      
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access. Master/Admin users must specify agencyId." });
      }
      
      // Transform checkInDate from ISO string to Date before validation
      const requestData = {
        ...req.body,
        checkInDate: req.body.checkInDate ? new Date(req.body.checkInDate) : undefined,
      };
      
      // Security: Force sellerId for seller users - they can only create their own leads
      const isSeller = userRole === 'external_agency_seller';
      if (isSeller) {
        requestData.sellerId = userId;
        requestData.registrationType = 'seller'; // Force seller type
      }
      
      // Handle agency as seller - agency IDs start with 'agency_'
      // When agency is selected, store agency name in sellerName and clear sellerId
      if (requestData.sellerId && requestData.sellerId.startsWith('agency_')) {
        const realAgencyId = requestData.sellerId.replace('agency_', '');
        const agency = await db.select({ name: externalAgencies.name })
          .from(externalAgencies)
          .where(eq(externalAgencies.id, realAgencyId))
          .limit(1);
        
        if (agency.length > 0) {
          requestData.sellerName = agency[0].name;
        }
        delete requestData.sellerId; // Clear invalid sellerId
      }
      
      console.log("[DEBUG] createExternalLead - requestData.sellerId:", requestData.sellerId, "isSeller:", isSeller);
      const validatedData = insertExternalLeadSchema.parse(requestData);
      
      console.log("[DEBUG] createExternalLead - validatedData.sellerId:", validatedData.sellerId);
      // Check for duplicates before creating (with 3-month expiry logic)
      // For broker type, use phoneLast4; for seller type, extract from phone
      const phoneToCheck = validatedData.registrationType === 'broker' 
        ? validatedData.phoneLast4 
        : validatedData.phone;
        
      const duplicateResult = await storage.checkExternalLeadDuplicateWithExpiry(
        agencyId,
        validatedData.firstName,
        validatedData.lastName,
        phoneToCheck
      );
      
      // If duplicate found and NOT expired (still within 3-month window), reject
      if (duplicateResult && !duplicateResult.isExpired) {
        const { lead: existingLead, daysRemaining, sellerName } = duplicateResult;
        
        // Calculate weeks and days remaining
        const weeksRemaining = Math.floor(daysRemaining / 7);
        const extraDays = daysRemaining % 7;
        let timeRemainingText = '';
        if (weeksRemaining > 0) {
          timeRemainingText = `${weeksRemaining} semana${weeksRemaining > 1 ? 's' : ''}`;
          if (extraDays > 0) {
            timeRemainingText += ` y ${extraDays} día${extraDays > 1 ? 's' : ''}`;
          }
        } else {
          timeRemainingText = `${daysRemaining} día${daysRemaining > 1 ? 's' : ''}`;
        }
        
        return res.status(409).json({ 
          message: "Lead ya registrado",
          detail: sellerName 
            ? `Este lead ya está registrado por ${sellerName}. Podrá ser registrado nuevamente en ${timeRemainingText}.`
            : `Este lead ya está registrado. Podrá ser registrado nuevamente en ${timeRemainingText}.`,
          duplicate: {
            id: existingLead.id,
            firstName: existingLead.firstName,
            lastName: existingLead.lastName,
            registrationType: existingLead.registrationType,
            phoneLast4: existingLead.phoneLast4,
            phone: existingLead.phone,
            email: existingLead.email,
            sellerName,
            daysRemaining,
            timeRemainingText,
          }
        });
      }
      
      const lead = await storage.createExternalLead({
        ...validatedData,
        agencyId,
        createdBy: userId,
      });
      
      // Create initial presentation card from lead data
      try {
        const cardData = normalizePresentationCardFromLead(lead, agencyId, userId);
        await storage.createExternalPresentationCard(cardData);
      } catch (cardError) {
        console.error("Error creating initial presentation card:", cardError);
      }
      
      // Log activity for lead registration (if created by seller)
      if (isSeller) {
        const user = await storage.getUser(userId);
        const actorName = user ? `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.username || "Unknown" : "Unknown";
        logSellerActivity({
          agencyId,
          actorId: userId,
          actorName,
          actorRole: userRole,
          actionType: "lead_registered",
          subjectType: "lead",
          subjectId: lead.id,
          subjectName: `${lead.firstName} ${lead.lastName}`,
          subjectInfo: { email: lead.email, phone: lead.phone },
        }).catch(err => console.error("Activity logging error:", err));
      }

      await createAuditLog(req, "create", "external_lead", lead.id, "Created new lead");
      res.status(201).json(lead);
    } catch (error: any) {
      console.error("Error creating external lead:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-leads/:id - Update lead
  app.patch("/api/external-leads/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalLead(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      // Security: Block sellers from modifying leads in locked statuses
      const lockedStatuses = ["proceso_renta", "renta_concretada"];
      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      const isSeller = userRole === 'external_agency_seller';
      
      // If seller and lead is in locked status, block ALL modifications
      if (isSeller && lockedStatuses.includes(existing.status)) {
        return res.status(403).json({ 
          message: "No puedes modificar un lead en proceso de renta o renta concretada. El administrador de la agencia es responsable de este lead." 
        });
      }
      
      // Transform date strings to Date objects before validation
      const bodyWithDates = { ...req.body };
      if (bodyWithDates.checkInDate && typeof bodyWithDates.checkInDate === 'string') {
        bodyWithDates.checkInDate = new Date(bodyWithDates.checkInDate);
      }
      if (bodyWithDates.checkOutDate && typeof bodyWithDates.checkOutDate === 'string') {
        bodyWithDates.checkOutDate = new Date(bodyWithDates.checkOutDate);
      }
      
      const validatedData = updateExternalLeadSchema.parse(bodyWithDates);
      
      // Security: Block sellers from setting status TO locked statuses (after validation)
      if (isSeller && validatedData.status && lockedStatuses.includes(validatedData.status)) {
        return res.status(403).json({ 
          message: "No puedes cambiar el estado a proceso de renta o renta concretada. Solo el administrador de la agencia puede hacerlo." 
        });
      }
      
      // Track status change for history
      const oldStatus = existing.status;
      const statusChanged = validatedData.status && oldStatus !== validatedData.status;
      
      const lead = await storage.updateExternalLead(id, validatedData);
      
      // Log status change to history if status changed
      if (statusChanged && req.user?.id) {
        await storage.createExternalLeadStatusHistory({
          leadId: id,
          agencyId: existing.agencyId,
          fromStatus: oldStatus,
          toStatus: validatedData.status!,
          changedBy: req.user.id,
        });
        
        // Create activity entry for the status change
        await storage.createExternalLeadActivity({
          leadId: id,
          agencyId: existing.agencyId,
          activityType: "status_change",
          title: `Cambio de estado: ${oldStatus} → ${validatedData.status}`,
          createdBy: req.user.id,
        });
      }
      
      await createAuditLog(req, "update", "external_lead", id, "Updated lead");
      res.json(lead);
    } catch (error: any) {
      console.error("Error updating external lead:", error);
      handleGenericError(res, error);
    }
  });


  // POST /api/external-leads/backfill-presentation-cards - Create initial cards for leads without them
  app.post("/api/external-leads/backfill-presentation-cards", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency assigned" });
      }

      // Get all leads for this agency
      const leads = await storage.getExternalLeadsByAgency(agencyId, {});
      
      let created = 0;
      let skipped = 0;
      const errors: string[] = [];

      for (const lead of leads) {
        // Check if lead already has a presentation card
        const existingCards = await storage.getExternalPresentationCards(agencyId, undefined, lead.id);
        
        if (existingCards.length > 0) {
          skipped++;
          continue;
        }

        // Create initial presentation card
        try {
          const cardData = normalizePresentationCardFromLead(lead, agencyId, req.user.id);
          await storage.createExternalPresentationCard(cardData);
          created++;
        } catch (cardError: any) {
          errors.push(`Lead ${lead.id}: ${cardError.message}`);
        }
      }

      await createAuditLog(req, "update", "external_presentation_card", "backfill", `Backfilled ${created} initial cards, skipped ${skipped}, errors ${errors.length}`);

      res.json({
        message: `Backfill completado: ${created} tarjetas creadas, ${skipped} leads ya tenían tarjetas`,
        created,
        skipped,
        errors: errors.length > 0 ? errors : undefined,
      });
    } catch (error: any) {
      console.error("Error in backfill:", error);
      handleGenericError(res, error);
    }
  });

    // POST /api/external-leads/:id/reassign - Reassign lead to different seller
  app.post("/api/external-leads/:id/reassign", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, "external_agency_seller"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { newSellerId, newSellerName } = req.body;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      // Verify lead belongs to this agency
      const existingLead = await storage.getExternalLead(id);
      if (!existingLead || existingLead.agencyId !== agencyId) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      // Determine if reassigning to agency or to a seller
      let updateData: any = {};
      
      if (newSellerId?.startsWith('agency_')) {
        // Reassigning to agency (no specific seller)
        updateData = {
          
          sellerId: null,
          sellerName: newSellerName || null,
        };
      } else if (newSellerId) {
        // Reassigning to a specific seller
        const seller = await db.select().from(users).where(eq(users.id, newSellerId)).limit(1);
        if (!seller[0] || seller[0].externalAgencyId !== agencyId) {
          return res.status(400).json({ message: "Invalid seller" });
        }
        updateData = {
          
          sellerId: newSellerId,
          sellerName: `${seller[0].firstName} ${seller[0].lastName}`,
        };
      } else {
        return res.status(400).json({ message: "New seller ID is required" });
      }
      
      const updatedLead = await storage.updateExternalLead(id, updateData);
      
      // Log the reassignment
      await storage.createAuditLog({
        userId: req.user.id,
        action: "update",
        entityType: "external_lead",
        entityId: id,
        details: `Lead reasignado a ${newSellerName || 'nuevo vendedor'}`,
      });
      
      // Create notification for the new seller when reassigned to a specific seller
      if (newSellerId && !newSellerId.startsWith('agency_')) {
        await db.insert(externalNotifications).values({
          agencyId: agencyId,
          type: "system",
          priority: "high",
          title: "Nuevo lead asignado",
          message: `Se te ha asignado un nuevo lead: ${existingLead.firstName} ${existingLead.lastName}`,
          recipientUserId: newSellerId,
          isRead: false,
        });
      }
      
      res.json(updatedLead);
    } catch (error: any) {
      console.error("Error reassigning lead:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-leads/:id - Delete lead (admin only)
  app.delete("/api/external-leads/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalLead(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      // Security: Block deleting leads in locked statuses
      const lockedStatuses = ["proceso_renta", "renta_concretada"];
      if (lockedStatuses.includes(existing.status)) {
        return res.status(403).json({ 
          message: "No puedes eliminar un lead en proceso de renta o renta concretada" 
        });
      }
      
      await storage.deleteExternalLead(id);
      
      await createAuditLog(req, "delete", "external_lead", id, "Deleted lead");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting external lead:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-leads/:id/unassign - Unassign lead from seller (seller can unassign their own leads)
  app.post("/api/external-leads/:id/unassign", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalLead(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      const isSeller = userRole === 'external_agency_seller';
      
      // Sellers can only unassign leads that are assigned to them (sellerId matches their ID)
      if (isSeller && existing.sellerId !== userId) {
        return res.status(403).json({ 
          message: "Solo puedes desasignar leads que te están asignados" 
        });
      }
      
      // Security: Block unassigning leads in locked statuses
      const lockedStatuses = ["proceso_renta", "renta_concretada"];
      if (lockedStatuses.includes(existing.status)) {
        return res.status(403).json({ 
          message: "No puedes desasignar un lead en proceso de renta o renta concretada" 
        });
      }
      
      // Unassign the lead by setting sellerId to null
      const lead = await storage.updateExternalLead(id, { 
        sellerId: null,
        sellerName: null
      });
      
      await createAuditLog(req, "unassign", "external_lead", id, 
        `Seller ${userId} unassigned lead from themselves`);
      
      res.json(lead);
    } catch (error: any) {
      console.error("Error unassigning external lead:", error);
      handleGenericError(res, error);
    }
  });

  // External Lead Registration Links Endpoints

  // POST /api/external-leads/import - Bulk import leads from CSV/Excel
  app.post("/api/external-leads/import", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized: User ID not found" });
      }

      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User not associated with any agency" });
      }

      const { leads: importData, registrationType = 'seller' } = req.body;
      
      if (!Array.isArray(importData) || importData.length === 0) {
        return res.status(400).json({ message: "No leads to import" });
      }

      // Map status from Excel to system status
      const statusMap: Record<string, string> = {
        'nuevo': 'nuevo_lead',
        'en proceso': 'en_proceso',
        'contactado': 'contactado',
        'cita agendada': 'cita_agendada',
        'visita realizada': 'visita_realizada',
        'negociando': 'negociando',
        'cerrado': 'cerrado',
        'lead muerto': 'no_interesado',
        'perdido': 'no_interesado',
        '': 'nuevo_lead',
      };

      const results = {
        imported: 0,
        duplicates: 0,
        errors: [] as Array<{ row: number; name: string; error: string }>,
      };

      for (let i = 0; i < importData.length; i++) {
        const row = importData[i];
        try {
          // Parse name into firstName and lastName
          const fullName = (row.nombre || row.name || '').trim();
          const nameParts = fullName.split(' ');
          const firstName = nameParts[0] || 'Sin nombre';
          const lastName = nameParts.slice(1).join(' ') || '-';

          // Clean phone number
          let phone = (row.telefono || row.phone || '').toString().replace(/[^\d+]/g, '');
          if (!phone || phone.length < 4) {
            phone = '0000';
          }

          // Parse budget
          let estimatedRentCost: number | null = null;
          let estimatedRentCostText = (row.presupuesto || row.budget || '').toString();
          const budgetMatch = estimatedRentCostText.match(/[\d,]+/);
          if (budgetMatch) {
            estimatedRentCost = parseInt(budgetMatch[0].replace(/,/g, ''), 10);
          }

          // Parse bedrooms
          let bedrooms: number | null = null;
          let bedroomsText = (row.recamaras || row.bedrooms || '').toString();
          const bedroomsMatch = bedroomsText.match(/^\d+/);
          if (bedroomsMatch) {
            bedrooms = parseInt(bedroomsMatch[0], 10);
          }

          // Parse original created date
          let originalCreatedAt: Date | null = null;
          const dateStr = (row.fecha || row.date || '').toString();
          if (dateStr) {
            const datePatterns = [
              /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,
              /^(\d{1,2})\/(\d{1,2})\/(\d{2})$/,
              /^(\d{1,2})\/(\d{1,2})$/,
            ];
            for (const pattern of datePatterns) {
              const match = dateStr.match(pattern);
              if (match) {
                let day = parseInt(match[1], 10);
                let month = parseInt(match[2], 10) - 1;
                let year = match[3] ? (match[3].length === 2 ? 2000 + parseInt(match[3], 10) : parseInt(match[3], 10)) : new Date().getFullYear();
                originalCreatedAt = new Date(year, month, day);
                break;
              }
            }
          }

          // Calculate validUntil (3 months from original date or now)
          const baseDate = originalCreatedAt || new Date();
          const validUntil = new Date(baseDate);
          validUntil.setMonth(validUntil.getMonth() + 3);

          // Check for duplicates
          const normalizedName = fullName.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, '');
          const phoneLast4 = phone.slice(-4);
          
          const existingLeads = await db.select()
            .from(externalLeads)
            .where(and(
              eq(externalLeads.agencyId, agencyId),
              gte(externalLeads.validUntil, new Date())
            ));

          const isDuplicate = existingLeads.some(lead => {
            const existingNormalizedName = `${lead.firstName}${lead.lastName}`.toLowerCase()
              .normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, '');
            const existingPhoneLast4 = (lead.phone || lead.phoneLast4 || '').slice(-4);
            return existingNormalizedName === normalizedName && existingPhoneLast4 === phoneLast4;
          });

          if (isDuplicate) {
            results.duplicates++;
            continue;
          }

          // Map status
          const rawStatus = (row.estado || row.status || '').toString().toLowerCase().trim();
          const status = statusMap[rawStatus] || 'nuevo_lead';

          // Create lead
          const leadData = {
            agencyId,
            registrationType: registrationType as 'broker' | 'seller',
            firstName,
            lastName,
            phone,
            phoneLast4,
            email: row.email || null,
            contractDuration: row.duracion || row.contractDuration || null,
            checkInDateText: row.mudanza || row.checkInDate || null,
            hasPets: row.mascotas || row.pets || null,
            estimatedRentCost,
            estimatedRentCostText: estimatedRentCostText || null,
            bedrooms,
            bedroomsText: bedroomsText || null,
            desiredUnitType: row.tipo || row.unitType || null,
            desiredProperty: row.propiedad || row.property || null,
            desiredNeighborhood: row.zona || row.neighborhood || null,
            sellerName: row.vendedor || row.seller || null,
            assistantSellerName: row.vendedorSecundario || row.assistantSeller || null,
            notes: row.notas || row.notes || null,
            status: status as any,
            source: 'import',
            validUntil,
            originalCreatedAt,
            createdBy: userId,
          };

          await db.insert(externalLeads).values(leadData);
          results.imported++;

        } catch (rowError: any) {
          results.errors.push({
            row: i + 1,
            name: row.nombre || row.name || 'Unknown',
            error: rowError.message || 'Unknown error',
          });
        }
      }

      await createAuditLog(req, "create", "external_lead_import", null, 
        `Imported ${results.imported} leads (${results.duplicates} duplicates skipped, ${results.errors.length} errors)`);

      res.json({
        success: true,
        imported: results.imported,
        duplicates: results.duplicates,
        errors: results.errors,
        total: importData.length,
      });
    } catch (error: any) {
      console.error("Error importing external leads:", error);
      handleGenericError(res, error);
    }
  });
  // POST /api/external-lead-registration-links - Create registration link
  app.post("/api/external-lead-registration-links", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      // Solo requiere registrationType del frontend
      const { registrationType } = createLeadRegistrationLinkSchema.parse(req.body);
      
      // Obtener userId del usuario autenticado
      const userId = req.user?.claims?.sub || req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized: User ID not found" });
      }
      
      // Obtener agencyId del usuario autenticado
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User not associated with any agency" });
      }
      
      // Obtener nombre de la agencia
      const agency = await storage.getExternalAgency(agencyId);
      if (!agency) {
        return res.status(404).json({ message: "Agency not found" });
      }
      
      // Generate unique token
      const token = crypto.randomBytes(32).toString('base64url');
      
      // Set expiration to 7 days from now
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7);
      
      const registrationToken = await storage.createExternalLeadRegistrationToken({
        token,
        agencyId,
        agencyName: agency.name,
        registrationType,
        expiresAt,
        createdBy: userId,
      });
      
      await createAuditLog(req, "create", "external_lead_registration_token", registrationToken.id, 
        `Created ${registrationType} registration link`);
      
      res.status(201).json(registrationToken);
    } catch (error: any) {
      console.error("Error creating registration link:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-lead-registration-links - List all registration links for agency
  app.get("/api/external-lead-registration-links", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User not associated with any agency" });
      }
      
      const links = await storage.getExternalLeadRegistrationTokensByAgency(agencyId);
      res.json(links);
    } catch (error: any) {
      console.error("Error fetching registration links:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-lead-registration-links/:id/regenerate - Regenerate expired link
  app.post("/api/external-lead-registration-links/:id/regenerate", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existingToken = await storage.getExternalLeadRegistrationToken(id);
      
      if (!existingToken) {
        return res.status(404).json({ message: "Registration link not found" });
      }
      
      // Verify agency ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existingToken.agencyId);
      if (!hasAccess) return;
      
      // Delete old token
      await storage.deleteExternalLeadRegistrationToken(id);
      
      // Create new token with same settings
      const newToken = crypto.randomBytes(32).toString('base64url');
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7);
      
      const regeneratedToken = await storage.createExternalLeadRegistrationToken({
        agencyId: existingToken.agencyId,
        agencyName: existingToken.agencyName,
        registrationType: existingToken.registrationType,
        token: newToken,
        expiresAt,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_lead_registration_token", regeneratedToken.id, 
        `Regenerated ${existingToken.registrationType} registration link`);
      
      res.json(regeneratedToken);
    } catch (error: any) {
      console.error("Error regenerating registration link:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-lead-registration-links/:id - Delete registration link
  app.delete("/api/external-lead-registration-links/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existingToken = await storage.getExternalLeadRegistrationToken(id);
      
      if (!existingToken) {
        return res.status(404).json({ message: "Registration link not found" });
      }
      
      // Verify agency ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existingToken.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalLeadRegistrationToken(id);
      
      await createAuditLog(req, "delete", "external_lead_registration_token", id, 
        `Deleted ${existingToken.registrationType} registration link`);
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting registration link:", error);
      handleGenericError(res, error);
    }
  });

  // ========================================
  // CRM ROUTES - Lead & Client Activity Tracking
  // ========================================

  // GET /api/external-leads/:id/activities - Get all activities for a lead
  app.get("/api/external-leads/:id/activities", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const activities = await storage.getExternalLeadActivities(id);
      res.json(activities);
    } catch (error: any) {
      console.error("Error fetching lead activities:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-leads/:id/activities - Create activity for a lead
  app.post("/api/external-leads/:id/activities", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const validatedData = insertExternalLeadActivitySchema.omit({ leadId: true, agencyId: true, createdBy: true }).parse(req.body);
      const activity = await storage.createExternalLeadActivity({
        ...validatedData,
        leadId: id,
        agencyId: lead.agencyId,
        createdBy: req.user.id,
      });
      // Update lead's lastContactDate
      await storage.updateExternalLead(id, { lastContactDate: new Date() });
      
      await createAuditLog(req, "create", "external_lead_activity", activity.id, "Created lead activity");
      res.status(201).json(activity);
    } catch (error: any) {
      console.error("Error creating lead activity:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-leads/:id/status-history - Get status history for a lead
  app.get("/api/external-leads/:id/status-history", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const history = await storage.getExternalLeadStatusHistory(id);
      res.json(history);
    } catch (error: any) {
      console.error("Error fetching lead status history:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-leads/:id/showings - Get all showings for a lead
  app.get("/api/external-leads/:id/showings", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const showings = await storage.getExternalLeadShowings(id);
      res.json(showings);
    } catch (error: any) {
      console.error("Error fetching lead showings:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-leads/:id/showings - Create showing for a lead
  app.post("/api/external-leads/:id/showings", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const validatedShowing = insertExternalLeadShowingSchema.omit({ leadId: true, agencyId: true, createdBy: true }).parse(req.body);
      const showing = await storage.createExternalLeadShowing({
        ...validatedShowing,
        leadId: id,
        agencyId: lead.agencyId,
        createdBy: req.user.id,
      });
      
      // Create activity entry for the showing
      await storage.createExternalLeadActivity({
        leadId: id,
        agencyId: lead.agencyId,
        activityType: 'showing',
        title: `Recorrido programado: ${showing.propertyName || 'Propiedad'}`,
        description: `Recorrido programado para ${new Date(showing.scheduledAt).toLocaleDateString('es-MX')}`,
        scheduledAt: showing.scheduledAt,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_lead_showing", showing.id, "Created lead showing");
      res.status(201).json(showing);
    } catch (error: any) {
      console.error("Error creating lead showing:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-lead-showings/:id - Update showing
  app.patch("/api/external-lead-showings/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const showing = await storage.getExternalLeadShowing(id);
      
      if (!showing) {
        return res.status(404).json({ message: "Showing not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, showing.agencyId);
      if (!hasAccess) return;
      
      const updated = await storage.updateExternalLeadShowing(id, req.body);
      
      await createAuditLog(req, "update", "external_lead_showing", id, "Updated lead showing");
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating lead showing:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-lead-showings/:id - Delete showing
  app.delete("/api/external-lead-showings/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const showing = await storage.getExternalLeadShowing(id);
      
      if (!showing) {
        return res.status(404).json({ message: "Showing not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, showing.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalLeadShowing(id);
      
      await createAuditLog(req, "delete", "external_lead_showing", id, "Deleted lead showing");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting lead showing:", error);
      handleGenericError(res, error);
    }
  });

  // ================== LEAD PROPERTY SENT ENDPOINTS ==================

  // ================== LEAD REMINDERS ENDPOINTS ==================
  
  // GET /api/external-leads/:id/reminders - Get all reminders for a lead
  app.get("/api/external-leads/:id/reminders", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const sellerId = req.user?.claims?.sub || req.user?.id;
      
      // Get reminders - sellers only see their own reminders (private)
      const reminders = await db.select()
        .from(externalLeadReminders)
        .where(and(
          eq(externalLeadReminders.leadId, id),
          eq(externalLeadReminders.sellerId, sellerId)
        ))
        .orderBy(desc(externalLeadReminders.reminderDate));
      
      res.json(reminders);
    } catch (error: any) {
      console.error("Error fetching lead reminders:", error);
      handleGenericError(res, error);
    }
  });
  
  // POST /api/external-leads/:id/reminders - Create a reminder for a lead
  app.post("/api/external-leads/:id/reminders", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const sellerId = req.user?.claims?.sub || req.user?.id;
      
      // Validate input - only allow safe fields, strip any sensitive fields
      const allowedFields = insertExternalLeadReminderSchema.omit({
        id: true,
        leadId: true,
        agencyId: true,
        sellerId: true,
        isPrivate: true,
        isNotified: true,
        completedAt: true,
        createdAt: true,
        updatedAt: true,
      });
      
      const validatedData = allowedFields.parse(req.body);
      
      const reminderData = {
        ...validatedData,
        leadId: id,
        agencyId: lead.agencyId,
        sellerId: sellerId,
        isPrivate: true,
      };
      
      const [reminder] = await db.insert(externalLeadReminders)
        .values(reminderData)
        .returning();
      
      await createAuditLog(req, "create", "external_lead_reminder", reminder.id, `Created reminder for lead ${lead.firstName} ${lead.lastName}`);
      
      res.status(201).json(reminder);
    } catch (error: any) {
      console.error("Error creating lead reminder:", error);
      handleGenericError(res, error);
    }
  });
  
  // PATCH /api/external-lead-reminders/:id - Update a reminder
  app.patch("/api/external-lead-reminders/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const sellerId = req.user?.claims?.sub || req.user?.id;
      
      const [existing] = await db.select()
        .from(externalLeadReminders)
        .where(eq(externalLeadReminders.id, id));
      
      if (!existing) {
        return res.status(404).json({ message: "Reminder not found" });
      }
      
      // Sellers can only update their own reminders
      if (existing.sellerId !== sellerId) {
        return res.status(403).json({ message: "You can only update your own reminders" });
      }
      
      // Validate input - only allow safe fields, strip sensitive fields
      const allowedUpdateFields = updateExternalLeadReminderSchema.omit({
        id: true,
        leadId: true,
        agencyId: true,
        sellerId: true,
        isPrivate: true,
        isNotified: true,
        createdAt: true,
      });
      
      const validatedData = allowedUpdateFields.parse(req.body);
      
      const updateData: any = {
        ...validatedData,
        updatedAt: new Date(),
      };
      
      // If marking as completed, set completedAt
      if (validatedData.status === 'completed' && existing.status !== 'completed') {
        updateData.completedAt = new Date();
      }
      
      const [updated] = await db.update(externalLeadReminders)
        .set(updateData)
        .where(eq(externalLeadReminders.id, id))
        .returning();
      
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating lead reminder:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-lead-reminders/:id - Delete a reminder
  app.delete("/api/external-lead-reminders/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const sellerId = req.user?.claims?.sub || req.user?.id;
      
      const [existing] = await db.select()
        .from(externalLeadReminders)
        .where(eq(externalLeadReminders.id, id));
      
      if (!existing) {
        return res.status(404).json({ message: "Reminder not found" });
      }
      
      // Sellers can only delete their own reminders
      if (existing.sellerId !== sellerId) {
        return res.status(403).json({ message: "You can only delete your own reminders" });
      }
      
      await db.delete(externalLeadReminders)
        .where(eq(externalLeadReminders.id, id));
      
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error deleting lead reminder:", error);
      handleGenericError(res, error);
    }
  });
  
  // GET /api/external-seller/reminders - Get all reminders for the seller (for calendar)
  app.get("/api/external-seller/reminders", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const sellerId = req.user?.claims?.sub || req.user?.id;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { status, from, to } = req.query;
      
      let conditions = [
        eq(externalLeadReminders.sellerId, sellerId),
        eq(externalLeadReminders.agencyId, agencyId)
      ];
      
      if (status && status !== 'all') {
        conditions.push(eq(externalLeadReminders.status, status as string));
      }
      
      if (from) {
        conditions.push(gte(externalLeadReminders.reminderDate, new Date(from as string)));
      }
      
      if (to) {
        conditions.push(lte(externalLeadReminders.reminderDate, new Date(to as string)));
      }
      
      const results = await db.select({
        reminder: externalLeadReminders,
        lead: {
          id: externalLeads.id,
          firstName: externalLeads.firstName,
          lastName: externalLeads.lastName,
          phone: externalLeads.phone,
          email: externalLeads.email,
        }
      })
        .from(externalLeadReminders)
        .leftJoin(externalLeads, eq(externalLeadReminders.leadId, externalLeads.id))
        .where(and(...conditions))
        .orderBy(asc(externalLeadReminders.reminderDate));
      
      // Flatten the response to match frontend expectations
      const reminders = results.map(r => ({
        id: r.reminder.id,
        leadId: r.reminder.leadId,
        reminderType: r.reminder.reminderType,
        title: r.reminder.title,
        description: r.reminder.description,
        dueDate: r.reminder.reminderDate, // Map reminderDate to dueDate for frontend
        priority: r.reminder.priority,
        status: r.reminder.status,
        lead: r.lead ? {
          firstName: r.lead.firstName,
          lastName: r.lead.lastName,
        } : null,
      }));
      
      res.json(reminders);
    } catch (error: any) {
      console.error("Error fetching seller reminders:", error);
      handleGenericError(res, error);
    }
  });
  // GET /api/external-leads/:id/properties-sent - Get all properties sent to a lead
  app.get("/api/external-leads/:id/properties-sent", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const propertiesSent = await storage.getExternalLeadPropertiesSent(id);
      res.json(propertiesSent);
    } catch (error: any) {
      console.error("Error fetching lead properties sent:", error);
      handleGenericError(res, error);
    }
  });
  
  // POST /api/external-leads/:id/properties-sent - Send/share property to a lead
  app.post("/api/external-leads/:id/properties-sent", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const lead = await storage.getExternalLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      // Get property details for snapshot
      let propertySnapshot: any = {};
      if (req.body.unitId) {
        const unit = await storage.getExternalUnit(req.body.unitId);
        if (unit) {
          const property = await storage.getExternalProperty(unit.propertyId);
          propertySnapshot = {
            propertyName: property?.name || '',
            unitNumber: unit.unitNumber,
            rentPrice: unit.rentPrice?.toString(),
            bedrooms: unit.bedrooms,
            zone: property?.zone || '',
          };
        }
      } else if (req.body.propertyId) {
        const property = await storage.getExternalProperty(req.body.propertyId);
        if (property) {
          propertySnapshot = {
            propertyName: property.name,
            zone: property.zone || '',
          };
        }
      }
      
      // Get seller info for activity logging
      const sellerIdForActivity = req.user.claims?.sub || req.user.id;
      const [sellerForActivity] = await db.select().from(users).where(eq(users.id, sellerIdForActivity)).limit(1);
      const sellerNameForActivity = sellerForActivity?.firstName && sellerForActivity?.lastName 
        ? `${sellerForActivity.firstName} ${sellerForActivity.lastName}`
        : sellerForActivity?.username || 'Vendedor';
      
      const propertySent = await storage.createExternalLeadPropertySent({
        ...req.body,
        ...propertySnapshot,
        leadId: id,
        agencyId: lead.agencyId,
        sentBy: req.user.id,
      });
      
      // Build property info for activity
      const propertyInfoForActivity = `${propertySnapshot.propertyName || 'Propiedad'}${propertySnapshot.unitNumber ? ' - ' + propertySnapshot.unitNumber : ''}`;
      const priceInfoForActivity = propertySnapshot.rentPrice ? ` (${Number(propertySnapshot.rentPrice).toLocaleString()} MXN/mes)` : '';
      
      // Create activity entry with seller name
      await storage.createExternalLeadActivity({
        leadId: id,
        agencyId: lead.agencyId,
        activityType: 'whatsapp',
        title: `Propiedad enviada: ${propertyInfoForActivity}`,
        description: `${sellerNameForActivity} compartió la propiedad ${propertyInfoForActivity}${priceInfoForActivity}`,
        relatedPropertyId: req.body.propertyId,
        relatedUnitId: req.body.unitId,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_lead_property_sent", propertySent.id, "Sent property to lead");
      res.status(201).json(propertySent);
    } catch (error: any) {
      console.error("Error sending property to lead:", error);
      handleGenericError(res, error);
    }
  });
  
  // POST /api/external-leads/:id/offer - Generate rental offer link for a lead (seller flow)
  app.post("/api/external-leads/:id/offer", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id: leadId } = req.params;
      const { externalUnitId } = req.body;
      
      // Validate lead exists and belongs to agency
      const lead = await storage.getExternalLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      // Validate unit exists and belongs to same agency
      if (!externalUnitId) {
        return res.status(400).json({ message: "externalUnitId is required" });
      }
      
      const unit = await storage.getExternalUnit(externalUnitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      if (String(unit.agencyId) !== String(lead.agencyId)) {
        return res.status(403).json({ message: "Unit does not belong to the same agency" });
      }
      
      // Get user info for createdByName
      const userId = req.user.claims?.sub || req.user.id;
      const [user] = await db.select().from(users).where(eq(users.id, userId)).limit(1);
      const createdByName = user?.firstName && user?.lastName 
        ? `${user.firstName} ${user.lastName}`
        : user?.username || 'Unknown';
      
      // Generate token
      const tokenValue = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7); // 7 days validity
      
      // Create the offer token
      const [newToken] = await db.insert(offerTokens).values({
        token: tokenValue,
        externalUnitId: String(externalUnitId),
        externalLeadId: leadId,
        createdBy: userId,
        createdByName,
        expiresAt,
        isUsed: false,
      }).returning();
      
      // Get unit and property details for response
      const property = unit.propertyId ? await storage.getExternalProperty(unit.propertyId) : null;
      
      // Generate the offer URL
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : req.protocol;
      const host = req.get('host');
      const offerUrl = `${protocol}://${host}/offer/${tokenValue}`;
      
      // Create activity entry with seller name
      await storage.createExternalLeadActivity({
        leadId,
        agencyId: lead.agencyId,
        activityType: 'whatsapp',
        title: `Oferta de Renta generada: ${property?.name || 'Propiedad'} - ${unit.unitNumber || ''}`,
        description: `${createdByName} generó link de oferta de renta para ${property?.name || 'Propiedad'} - ${unit.unitNumber || ''}${unit.price ? ` (${Number(unit.price).toLocaleString()} ${unit.currency || 'MXN'}/mes)` : ''}`,
        relatedPropertyId: unit.propertyId,
        relatedUnitId: externalUnitId,
        createdBy: userId,
      });
      
      await createAuditLog(req, "create", "offer_token", newToken.id, `Created rental offer link for lead ${leadId}`);
      // Log seller activity for offer sent
      const userRole = req.user?.cachedRole || req.user?.role;
      if (userRole === "external_agency_seller") {
        logSellerActivity({
          agencyId: lead.agencyId,
          actorId: userId,
          actorName: createdByName,
          actorRole: userRole,
          actionType: "offer_sent",
          subjectType: "lead",
          subjectId: leadId,
          subjectName: `${lead.firstName || ""} ${lead.lastName || ""}`.trim(),
          subjectInfo: { unitNumber: unit.unitNumber, propertyName: property?.name },
        }).catch(err => console.error("Activity logging error:", err));
      }

      
      res.status(201).json({
        ...newToken,
        offerUrl,
        leadName: lead.fullName,
        propertyName: property?.name,
        unitNumber: unit.unitNumber,
        createdByName,
      });
    } catch (error: any) {
      console.error("Error creating rental offer for lead:", error);
      handleGenericError(res, error);
    }
  });
  
  // GET /api/external-leads/:id/rental-forms - Get rental form tokens for a lead
  app.get("/api/external-leads/:id/rental-forms", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id: leadId } = req.params;
      
      const lead = await storage.getExternalLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      // Get rental form tokens for this lead
      const tokens = await db
        .select({
          id: tenantRentalFormTokens.id,
          token: tenantRentalFormTokens.token,
          recipientType: tenantRentalFormTokens.recipientType,
          isUsed: tenantRentalFormTokens.isUsed,
          expiresAt: tenantRentalFormTokens.expiresAt,
          createdAt: tenantRentalFormTokens.createdAt,
          createdByName: tenantRentalFormTokens.createdByName,
          unitNumber: externalUnits.unitNumber,
          condoName: externalCondominiums.name,
        })
        .from(tenantRentalFormTokens)
        .leftJoin(externalUnits, eq(tenantRentalFormTokens.externalUnitId, externalUnits.id))
        .leftJoin(externalCondominiums, eq(externalUnits.condominiumId, externalCondominiums.id))
        .where(eq(tenantRentalFormTokens.externalLeadId, leadId))
        .orderBy(desc(tenantRentalFormTokens.createdAt));
      
      const formatted = tokens.map(t => ({
        ...t,
        propertyTitle: t.unitNumber 
          ? (t.condoName ? `${t.condoName} - ${t.unitNumber}` : t.unitNumber)
          : 'Sin unidad',
      }));
      
      res.json(formatted);
    } catch (error: any) {
      console.error("Error fetching lead rental forms:", error);
      handleGenericError(res, error);
    }
  });
  
  // POST /api/external-leads/:id/offers - Generate offer token for a lead
  app.post("/api/external-leads/:id/offers", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id: leadId } = req.params;
      const { externalUnitId } = req.body;
      
      const lead = await storage.getExternalLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      if (!externalUnitId) {
        return res.status(400).json({ message: "externalUnitId is required" });
      }
      
      const unit = await storage.getExternalUnit(externalUnitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      if (String(unit.agencyId) !== String(lead.agencyId)) {
        return res.status(403).json({ message: "Unit does not belong to the same agency" });
      }
      
      const userId = req.user.claims?.sub || req.user.id;
      const [user] = await db.select().from(users).where(eq(users.id, userId)).limit(1);
      const createdByName = user?.firstName && user?.lastName 
        ? `${user.firstName} ${user.lastName}`
        : user?.username || 'Unknown';
      
      const tokenValue = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24);
      
      // Create offer token
      const [newToken] = await db.insert(offerTokens).values({
        token: tokenValue,
        externalUnitId,
        externalClientId: null,
        leadId: null,
        createdBy: userId,
        expiresAt,
        isUsed: false,
      }).returning();
      
      // Get agency and unit info for URL generation
      const [agency] = await db.select({ slug: externalAgencies.slug })
        .from(externalAgencies)
        .where(eq(externalAgencies.id, unit.agencyId))
        .limit(1);
      
      const property = unit.propertyId ? await storage.getExternalProperty(unit.propertyId) : null;
      const condo = unit.condominiumId ? await storage.getExternalCondominium(unit.condominiumId) : null;
      
      // Generate URL
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : req.protocol;
      const host = req.get('host');
      const offerUrl = agency?.slug && unit.slug 
        ? `${protocol}://${host}/${agency.slug}/oferta/${unit.slug}`
        : `${protocol}://${host}/offer/${tokenValue}`;
      
      // Log lead activity
      await storage.createExternalLeadActivity({
        leadId,
        agencyId: lead.agencyId,
        activityType: 'email',
        title: `Oferta generada: ${condo?.name || 'Propiedad'} - ${unit.unitNumber || ''}`,
        description: `Se generó oferta para ${lead.fullName}`,
        relatedPropertyId: unit.propertyId,
        relatedUnitId: externalUnitId,
        createdBy: userId,
      });
      
      // Log property activity
      try {
        await db.insert(externalPropertyActivityHistory).values({
          agencyId: lead.agencyId,
          unitId: externalUnitId,
          condominiumId: unit.condominiumId || null,
          activityType: 'offer_sent',
          leadId: leadId,
          leadName: lead.fullName || null,
          clientId: null,
          clientName: null,
          offerTokenId: newToken.id,
          performedBy: userId,
          performedByName: createdByName,
          details: {
            recipientType: 'tenant',
            channel: 'link',
            notes: `Oferta generada para lead ${lead.fullName}`
          },
        });
      } catch (activityError) {
        console.error("Error logging property activity for lead offer:", activityError);
      }
      
      await createAuditLog(req, "create", "offer_token", newToken.id, `Created offer for lead ${leadId}`);
      
      res.status(201).json({
        ...newToken,
        offerUrl,
        leadName: lead.fullName,
        propertyName: property?.name || condo?.name,
        unitNumber: unit.unitNumber,
        createdByName,
        agencySlug: agency?.slug,
        unitSlug: unit.slug,
      });
    } catch (error: any) {
      console.error("Error creating offer for lead:", error);
      handleGenericError(res, error);
    }
  });

  
  // POST /api/external-leads/:id/rental-forms - Generate rental form token for a lead
  app.post("/api/external-leads/:id/rental-forms", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id: leadId } = req.params;
      const { externalUnitId, recipientType = 'tenant' } = req.body;
      
      const lead = await storage.getExternalLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      if (!externalUnitId) {
        return res.status(400).json({ message: "externalUnitId is required" });
      }
      
      const unit = await storage.getExternalUnit(externalUnitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      if (String(unit.agencyId) !== String(lead.agencyId)) {
        return res.status(403).json({ message: "Unit does not belong to the same agency" });
      }
      
      const userId = req.user.claims?.sub || req.user.id;
      const [user] = await db.select().from(users).where(eq(users.id, userId)).limit(1);
      const createdByName = user?.firstName && user?.lastName 
        ? `${user.firstName} ${user.lastName}`
        : user?.username || 'Unknown';
      
      const tokenValue = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7);
      
      const [newToken] = await db.insert(tenantRentalFormTokens).values({
        token: tokenValue,
        recipientType,
        externalUnitId,
        externalLeadId: leadId,
        createdBy: userId,
        createdByName,
        expiresAt,
        isUsed: false,
      }).returning();
      
      const property = unit.propertyId ? await storage.getExternalProperty(unit.propertyId) : null;
      
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : req.protocol;
      const host = req.get('host');
      const formUrl = `${protocol}://${host}/rental-form/${tokenValue}`;
      
      await storage.createExternalLeadActivity({
        leadId,
        agencyId: lead.agencyId,
        activityType: 'whatsapp',
        title: `Formato de Renta generado: ${property?.name || 'Propiedad'} - ${unit.unitNumber || ''}`,
        description: `Se generó formato de renta (${recipientType}) para ${lead.fullName}`,
        relatedPropertyId: unit.propertyId,
        relatedUnitId: externalUnitId,
        createdBy: userId,
      });
      
      await createAuditLog(req, "create", "tenant_rental_form_token", newToken.id, `Created rental form for lead ${leadId}`);
      // Log seller activity for rental form sent
      const userRole = req.user?.cachedRole || req.user?.role;
      if (userRole === "external_agency_seller") {
        logSellerActivity({
          agencyId: lead.agencyId,
          actorId: userId,
          actorName: createdByName,
          actorRole: userRole,
          actionType: "rental_form_sent",
          subjectType: "lead",
          subjectId: leadId,
          subjectName: `${lead.firstName || ""} ${lead.lastName || ""}`.trim(),
          subjectInfo: { unitNumber: unit.unitNumber, propertyName: property?.name },
        }).catch(err => console.error("Activity logging error:", err));
      }


      // Log property activity for the unit
      if (unit) {
        try {
          await db.insert(externalPropertyActivityHistory).values({
            agencyId: lead.agencyId,
            unitId: externalUnitId,
            condominiumId: unit.condominiumId || null,
            activityType: 'rental_form_sent',
            leadId: leadId,
            leadName: lead.fullName || null,
            clientId: null,
            clientName: null,
            offerTokenId: null,
            appointmentId: null,
            showingId: null,
            contractId: null,
            performedBy: userId,
            performedByName: createdByName,
            details: {
              recipientType,
              channel: 'link',
              notes: `Formato de renta generado para ${lead.fullName}`
            },
          });
        } catch (activityError) {
          console.error("Error logging property activity for rental form:", activityError);
        }
      }

      
      res.status(201).json({
        ...newToken,
        formUrl,
        leadName: lead.fullName,
        propertyName: property?.name,
        unitNumber: unit.unitNumber,
        createdByName,
      });
    } catch (error: any) {
      console.error("Error creating rental form for lead:", error);
      handleGenericError(res, error);
    }
  });
  
  // PATCH /api/external-lead-properties-sent/:id - Update property sent (e.g., lead response)
  app.patch("/api/external-lead-properties-sent/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const propertySent = await storage.getExternalLeadPropertySent(id);
      
      if (!propertySent) {
        return res.status(404).json({ message: "Property sent record not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, propertySent.agencyId);
      if (!hasAccess) return;
      
      const updated = await storage.updateExternalLeadPropertySent(id, {
        ...req.body,
        respondedAt: req.body.leadResponse ? new Date() : undefined,
      });
      
      await createAuditLog(req, "update", "external_lead_property_sent", id, "Updated lead property sent");
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating lead property sent:", error);
      handleGenericError(res, error);
    }
  });


  // GET /api/external-clients/:id/activities - Get all activities for a client
  app.get("/api/external-clients/:id/activities", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const client = await storage.getExternalClient(id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const activities = await storage.getExternalClientActivities(id);
      res.json(activities);
    } catch (error: any) {
      console.error("Error fetching client activities:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-clients/:id/activities - Create activity for a client
  app.post("/api/external-clients/:id/activities", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const client = await storage.getExternalClient(id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const validatedActivity = insertExternalClientActivitySchema.omit({ clientId: true, agencyId: true, createdBy: true }).parse(req.body);
      const activity = await storage.createExternalClientActivity({
        ...validatedActivity,
        clientId: id,
        agencyId: client.agencyId,
        createdBy: req.user.id,
      });
      
      // Update client's lastContactDate
      await storage.updateExternalClient(id, { lastContactDate: new Date() });
      
      await createAuditLog(req, "create", "external_client_activity", activity.id, "Created client activity");
      res.status(201).json(activity);
    } catch (error: any) {
      console.error("Error creating client activity:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external-clients/:id/property-history - Get property history for a client
  app.get("/api/external-clients/:id/property-history", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const { id } = req.params;
      const client = await storage.getExternalClient(id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const history = await storage.getExternalClientPropertyHistory(id);
      res.json(history);
    } catch (error: any) {
      console.error("Error fetching client property history:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-clients/:id/property-history - Add property history entry
  app.post("/api/external-clients/:id/property-history", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const client = await storage.getExternalClient(id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const validatedHistory = insertExternalClientPropertyHistorySchema.omit({ clientId: true, agencyId: true, createdBy: true }).parse(req.body);
      const history = await storage.createExternalClientPropertyHistory({
        ...validatedHistory,
        clientId: id,
        agencyId: client.agencyId,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_client_property_history", history.id, "Created client property history");
      res.status(201).json(history);
    } catch (error: any) {
      console.error("Error creating client property history:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-clients/:id/blacklist - Update client blacklist status
  app.patch("/api/external-clients/:id/blacklist", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const client = await storage.getExternalClient(id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const { blacklistStatus, blacklistReason } = req.body;
      
      const updates: any = {
        blacklistStatus,
        blacklistReason,
      };
      
      if (blacklistStatus === 'blacklisted') {
        updates.blacklistedAt = new Date();
        updates.blacklistedBy = req.user.id;
      } else if (blacklistStatus === 'none') {
        updates.blacklistedAt = null;
        updates.blacklistedBy = null;
        updates.blacklistReason = null;
      }
      
      const updated = await storage.updateExternalClient(id, updates);
      
      // Log activity for blacklist change
      await storage.createExternalClientActivity({
        clientId: id,
        agencyId: client.agencyId,
        activityType: 'note',
        title: `Estado de blacklist cambiado a: ${blacklistStatus}`,
        description: blacklistReason || undefined,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "update", "external_client", id, `Updated blacklist status to ${blacklistStatus}`);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating client blacklist:", error);
      handleGenericError(res, error);
    }
  });


  // Public simplified lead registration endpoints (no tokens required)
  // POST /api/public/leads/vendedor - Public vendedor registration
  app.post("/api/public/leads/vendedor", publicLeadRegistrationLimiter, async (req, res) => {
    try {
      const { 
        firstName, 
        lastName, 
        email, 
        phone,
        contractDuration,
        checkInDate,
        hasPets,
        estimatedRentCost,
        bedrooms,
        desiredUnitType,
        desiredNeighborhood,
        interestedCondominiumId,
        interestedUnitId,
        sellerId,
        sellerName,
        source, 
        notes 
      } = req.body;
      
      // Basic validation - email is optional
      if (!firstName || !lastName || !phone) {
        return res.status(400).json({ message: "Faltan campos requeridos (nombre, apellido, teléfono)" });
      }
      
      // For now, we'll assign to first available external agency
      const agencies = await storage.getExternalAgencies();
      if (!agencies || agencies.length === 0) {
        return res.status(500).json({ message: "No hay agencias disponibles" });
      }
      
      const agencyId = agencies[0].id;
      
      // Check for duplicate lead with 3-month expiry
      const phoneLast4 = phone.slice(-4);
      const duplicateCheck = await storage.checkExternalLeadDuplicateWithExpiry(
        agencyId, firstName, lastName, phoneLast4
      );
      
      if (duplicateCheck && !duplicateCheck.isExpired) {
        return res.status(409).json({
          message: `Este lead ya fue registrado por ${duplicateCheck.sellerName || "otro vendedor"}. Quedan ${duplicateCheck.daysRemaining} días para que expire.`,
          detail: `Este lead ya fue registrado por ${duplicateCheck.sellerName || "otro vendedor"}. Quedan ${duplicateCheck.daysRemaining} días para que expire.`,
          duplicate: {
            sellerName: duplicateCheck.sellerName,
            daysRemaining: duplicateCheck.daysRemaining
          }
        });
      }
      
      // Create lead
      const lead = await storage.createExternalLead({
        agencyId,
        firstName,
        lastName,
        email: email || null,
        phone,
        phoneLast4: phone.slice(-4),
        contractDuration: contractDuration || null,
        checkInDate: checkInDate ? new Date(checkInDate) : null,
        hasPets: hasPets || null,
        estimatedRentCost: estimatedRentCost ? parseInt(estimatedRentCost) : null,
        bedrooms: bedrooms ? parseInt(bedrooms) : null,
        desiredUnitType: desiredUnitType || null,
        desiredNeighborhood: desiredNeighborhood || null,
        interestedCondominiumId: interestedCondominiumId || null,
        interestedUnitId: interestedUnitId || null,
        sellerId: sellerId || null,
        sellerName: sellerName || null,
        registrationType: "seller",
        status: "nuevo_lead",
        source: source || "public_web_vendedor",
        notes,
      });
      
      res.status(201).json({ success: true, leadId: lead.id });
    } catch (error) {
      console.error("Error creating vendedor lead:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/public/leads/broker - Public broker registration
  app.post("/api/public/leads/broker", publicLeadRegistrationLimiter, async (req, res) => {
    try {
      const { 
        firstName, 
        lastName, 
        email,
        phone,
        phoneLast4,
        contractDuration,
        checkInDate,
        hasPets,
        estimatedRentCost,
        bedrooms,
        desiredUnitType,
        desiredNeighborhood,
        sellerName,
        source, 
        notes,
        interestedCondominiumId,
        interestedUnitId
      } = req.body;
      
      // Basic validation
      if (!firstName || !lastName || !phoneLast4) {
        return res.status(400).json({ message: "Faltan campos requeridos" });
      }
      
      // For now, we'll assign to first available external agency
      const agencies = await storage.getExternalAgencies();
      if (!agencies || agencies.length === 0) {
        return res.status(500).json({ message: "No hay agencias disponibles" });
      }
      
      const agencyId = agencies[0].id;
      
      
      // Check for duplicate lead with 3-month expiry
      const duplicateCheck = await storage.checkExternalLeadDuplicateWithExpiry(
        agencyId, firstName, lastName, phoneLast4
      );
      
      if (duplicateCheck && !duplicateCheck.isExpired) {
        return res.status(409).json({
          message: `Este lead ya fue registrado por ${duplicateCheck.sellerName || "otro vendedor"}. Quedan ${duplicateCheck.daysRemaining} días para que expire.`,
          detail: `Este lead ya fue registrado por ${duplicateCheck.sellerName || "otro vendedor"}. Quedan ${duplicateCheck.daysRemaining} días para que expire.`,
          duplicate: {
            sellerName: duplicateCheck.sellerName,
            daysRemaining: duplicateCheck.daysRemaining
          }
        });
      }
      // Create lead
      const lead = await storage.createExternalLead({
        agencyId,
        firstName,
        lastName,
        email: email || null,
        phone: phone || null,
        phoneLast4,
        contractDuration: contractDuration || null,
        checkInDate: checkInDate ? new Date(checkInDate) : null,
        hasPets: hasPets || null,
        estimatedRentCost: estimatedRentCost ? parseInt(estimatedRentCost) : null,
        bedrooms: bedrooms ? parseInt(bedrooms) : null,
        desiredUnitType: desiredUnitType || null,
        desiredNeighborhood: desiredNeighborhood || null,
        sellerName: sellerName || null,
        registrationType: "broker",
        status: "nuevo_lead",
        source: source || "public_web_broker",
        interestedCondominiumId: interestedCondominiumId || null,
        interestedUnitId: interestedUnitId || null,
        notes,
      });
      
      res.status(201).json({ success: true, leadId: lead.id });
    } catch (error: any) {
      console.error("Error creating broker lead:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/public/agency - Get public agency info (name, logo)
  app.get("/api/public/agency", async (req, res) => {
    try {
      const agencies = await storage.getExternalAgencies({ isActive: true });
      if (!agencies || agencies.length === 0) {
        return res.json({ name: "", logoUrl: "" });
      }
      const agency = agencies[0];
      res.json({
        id: agency.id,
        name: agency.name,
        logoUrl: agency.agencyLogoUrl || ""
      });
    } catch (error: any) {
      console.error("Error fetching public agency:", error);
      res.json({ name: "", logoUrl: "" });
    }
  });

  // GET /api/public/external-units/:id - Public endpoint to view external unit details
  app.get("/api/public/external-units/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const unit = await storage.getExternalUnit(id);
      
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Get condominium name if condominiumId exists
      let condominiumName = unit.condominiumName || null;
      if (!condominiumName && unit.condominiumId) {
        const condoResult = await db.select({ name: externalCondominiums.name })
          .from(externalCondominiums)
          .where(eq(externalCondominiums.id, unit.condominiumId))
          .limit(1);
        condominiumName = condoResult[0]?.name || null;
      }
      
      // Calculate public availability based on publication rules
      const isPubliclyAvailable = Boolean(
        unit.publishToMain && 
        unit.publishStatus === 'approved' && 
        unit.isActive !== false
      );
      
      // Return only public-safe information
      res.json({
        id: unit.id,
        name: unit.name,
        unitNumber: unit.unitNumber,
        zone: unit.zone,
        unitType: unit.unitType,
        bedrooms: unit.bedrooms,
        bathrooms: unit.bathrooms,
        monthlyRent: unit.price,
        currency: unit.currency,
        salePrice: unit.salePrice || null,
        saleCurrency: unit.saleCurrency || 'MXN',
        status: unit.status,
        isPubliclyAvailable,
        images: unit.images,
        primaryImages: unit.primaryImages || [],
        secondaryImages: unit.secondaryImages || [],
        videos: unit.videos || [],
        virtualTourUrl: unit.virtualTourUrl,
        googleMapsUrl: unit.googleMapsUrl,
        amenities: unit.amenities,
        condominiumName,
        squareMeters: unit.area,
        hasFurniture: unit.hasFurniture,
        hasParking: unit.hasParking,
        petsAllowed: unit.petFriendly,
        description: unit.description,
        includesWater: unit.includesWater,
        includesElectricity: unit.includesElectricity,
        includesInternet: unit.includesInternet,
        includesGas: unit.includesGas,
      });
    } catch (error: any) {
      console.error("Error fetching public unit:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/public/sellers - Get public list of sellers for lead registration dropdown
  // GET /api/public/resolve-offer-token/:agencySlug/:unitSlug - Resolve offer token by slugs
  app.get("/api/public/resolve-offer-token/:agencySlug/:unitSlug", async (req, res) => {
    try {
      const { agencySlug, unitSlug } = req.params;
      
      // Find agency by slug
      const agency = await db.select()
        .from(externalAgencies)
        .where(and(
          eq(externalAgencies.slug, agencySlug),
          eq(externalAgencies.isActive, true)
        ))
        .limit(1);
      
      if (!agency.length) {
        return res.status(404).json({ message: "Agencia no encontrada" });
      }
      
      // Find unit by slug and agency
      const unit = await db.select()
        .from(externalUnits)
        .where(and(
          eq(externalUnits.slug, unitSlug),
          eq(externalUnits.agencyId, agency[0].id)
        ))
        .limit(1);
      
      if (!unit.length) {
        return res.status(404).json({ message: "Unidad no encontrada" });
      }
      
      // Find active offer token for this unit
      const token = await db.select()
        .from(offerTokens)
        .where(and(
          eq(offerTokens.externalUnitId, unit[0].id),
          eq(offerTokens.status, "active")
        ))
        .orderBy(desc(offerTokens.createdAt))
        .limit(1);
      
      if (!token.length) {
        return res.status(404).json({ message: "No hay oferta activa para esta propiedad" });
      }
      
      res.json({ token: token[0].token });
    } catch (error: any) {
      console.error("Error resolving offer token:", error);
      res.status(500).json({ message: "Error interno del servidor" });
    }
  });

  // GET /api/public/resolve-rental-form-token/:agencySlug/:unitSlug - Resolve rental form token by slugs
  app.get("/api/public/resolve-rental-form-token/:agencySlug/:unitSlug", async (req, res) => {
    try {
      const { agencySlug, unitSlug } = req.params;
      
      // Find agency by slug
      const agency = await db.select()
        .from(externalAgencies)
        .where(and(
          eq(externalAgencies.slug, agencySlug),
          eq(externalAgencies.isActive, true)
        ))
        .limit(1);
      
      if (!agency.length) {
        return res.status(404).json({ message: "Agencia no encontrada" });
      }
      
      // Find unit by slug and agency
      const unit = await db.select()
        .from(externalUnits)
        .where(and(
          eq(externalUnits.slug, unitSlug),
          eq(externalUnits.agencyId, agency[0].id)
        ))
        .limit(1);
      
      if (!unit.length) {
        return res.status(404).json({ message: "Unidad no encontrada" });
      }
      
      // Find active rental form token for this unit (recipient type 'tenant')
      const token = await db.select()
        .from(rentalFormTokens)
        .where(and(
          eq(rentalFormTokens.externalUnitId, unit[0].id),
          eq(rentalFormTokens.status, "active"),
          eq(rentalFormTokens.recipientType, "tenant")
        ))
        .orderBy(desc(rentalFormTokens.createdAt))
        .limit(1);
      
      if (!token.length) {
        return res.status(404).json({ message: "No hay formato de renta activo para esta propiedad" });
      }
      
      res.json({ token: token[0].token });
    } catch (error: any) {
      console.error("Error resolving rental form token:", error);
      res.status(500).json({ message: "Error interno del servidor" });
    }
  });

  app.get("/api/public/sellers", async (req, res) => {
    try {
      const agencies = await storage.getExternalAgencies({ isActive: true });
      if (!agencies || agencies.length === 0) {
        return res.json([]);
      }
      const agencyId = agencies[0].id;
      
      // Get all sellers for this agency directly from database
      const sellers = await db.select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
      })
      .from(users)
      .where(and(
        eq(users.externalAgencyId, agencyId),
        eq(users.role, 'external_agency_seller'),
        eq(users.status, 'approved')
      ))
      .orderBy(users.firstName);
      
      const publicSellers = sellers.map(s => ({
        id: s.id,
        fullName: `${s.firstName} ${s.lastName}`
      }));
      res.json(publicSellers);
    } catch (error: any) {
      console.error("Error fetching public sellers:", error);
      res.json([]);
    }
  });


  // GET /api/public/external-properties - Public list of approved external properties with pagination
  app.get("/api/public/external-properties", async (req, res) => {
    try {
      const { page = 1, limit = 24, q, location, status, propertyType, minPrice, maxPrice, bedrooms, bathrooms, petFriendly, featured } = req.query;
      const pageNum = Math.max(1, parseInt(page as string) || 1);
      const limitNum = Math.min(Math.max(1, parseInt(limit as string) || 24), 50);
      const offset = (pageNum - 1) * limitNum;
      
      // Build where conditions - base conditions
      const conditions: any[] = [
        eq(externalUnits.publishToMain, true),
        eq(externalUnits.publishStatus, 'approved'),
        eq(externalUnits.isActive, true)
      ];
      
      // Apply filter: status (rent/sale/both)
      if (status && typeof status === 'string' && status !== 'all') {
        if (status === 'rent') {
          conditions.push(or(eq(externalUnits.listingType, 'rent'), eq(externalUnits.listingType, 'both')));
        } else if (status === 'sale') {
          conditions.push(or(eq(externalUnits.listingType, 'sale'), eq(externalUnits.listingType, 'both')));
        }
      }
      
      // Apply filter: pet-friendly
      if (petFriendly === 'true' || petFriendly === '1') {
        conditions.push(eq(externalUnits.petsAllowed, true));
      }
      
      // Apply filter: featured - Note: external units don't have a dedicated featured field
      // For now, featured filter is not applicable to external units
      // TODO: Add featured field to externalUnits schema if needed
      
      // Apply filter: location/zone search
      if (location && typeof location === 'string' && location.trim()) {
        const locationTerm = `%${location.trim()}%`;
        conditions.push(or(
          ilike(externalUnits.zone, locationTerm),
          ilike(externalUnits.title, locationTerm),
          ilike(externalUnits.description, locationTerm)
        ));
      }
      
      // Apply filter: property type
      if (propertyType && typeof propertyType === 'string' && propertyType !== 'all') {
        conditions.push(ilike(externalUnits.propertyType, propertyType));
      }
      
      // Apply filter: bedrooms
      if (bedrooms && typeof bedrooms === 'string') {
        const bedroomsNum = parseInt(bedrooms);
        if (!isNaN(bedroomsNum) && bedroomsNum > 0) {
          conditions.push(gte(externalUnits.bedrooms, bedroomsNum));
        }
      }
      
      // Apply filter: bathrooms
      if (bathrooms && typeof bathrooms === 'string') {
        const bathroomsNum = parseFloat(bathrooms);
        if (!isNaN(bathroomsNum) && bathroomsNum > 0) {
          conditions.push(gte(externalUnits.bathrooms, bathroomsNum));
        }
      }
      
      // Apply filter: min price
      if (minPrice && typeof minPrice === 'string') {
        const minPriceNum = parseFloat(minPrice);
        if (!isNaN(minPriceNum) && minPriceNum > 0) {
          conditions.push(gte(sql`CAST(${externalUnits.price} AS numeric)`, minPriceNum));
        }
      }
      
      // Apply filter: max price
      if (maxPrice && typeof maxPrice === 'string') {
        const maxPriceNum = parseFloat(maxPrice);
        if (!isNaN(maxPriceNum) && maxPriceNum > 0) {
          conditions.push(lte(sql`CAST(${externalUnits.price} AS numeric)`, maxPriceNum));
        }
      }
      
      // Apply filter: search query (title, description, zone, condominium name)
      // For condominium name search, we use a subquery approach
      if (q && typeof q === 'string' && q.trim()) {
        const searchTerm = `%${q.trim()}%`;
        // Get condominium IDs that match the search term
        const matchingCondominiums = await db
          .select({ id: externalCondominiums.id })
          .from(externalCondominiums)
          .where(ilike(externalCondominiums.name, searchTerm));
        const matchingCondoIds = matchingCondominiums.map(c => c.id);
        
        // Search in unit fields OR match condominium IDs
        if (matchingCondoIds.length > 0) {
          conditions.push(or(
            ilike(externalUnits.title, searchTerm),
            ilike(externalUnits.description, searchTerm),
            ilike(externalUnits.zone, searchTerm),
            ilike(externalUnits.unitNumber, searchTerm),
            inArray(externalUnits.condominiumId, matchingCondoIds)
          ));
        } else {
          conditions.push(or(
            ilike(externalUnits.title, searchTerm),
            ilike(externalUnits.description, searchTerm),
            ilike(externalUnits.zone, searchTerm),
            ilike(externalUnits.unitNumber, searchTerm)
          ));
        }
      }
      
      // Get total count with filters applied
      const countResult = await db
        .select({ count: sql<number>`count(*)` })
        .from(externalUnits)
        .where(and(...conditions));
      const totalCount = Number(countResult[0]?.count || 0);
      
      // Get paginated units
      const approvedUnits = await db
        .select()
        .from(externalUnits)
        .where(and(...conditions))
        .orderBy(desc(externalUnits.createdAt))
        .limit(limitNum)
        .offset(offset);
      
      // Transform to property-like format for frontend compatibility
      // Helper to generate slug
const generateSlug = (str: string) => str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");

      const properties = await Promise.all(approvedUnits.map(async (unit) => {
        let location = "Tulum, Quintana Roo";
        if (unit.condominiumId) {
          const condos = await db
            .select({ name: externalCondominiums.name, zone: externalCondominiums.zone })
            .from(externalCondominiums)
            .where(eq(externalCondominiums.id, unit.condominiumId))
            .limit(1);
          if (condos.length > 0) {
            const condo = condos[0];
            location = condo.zone ? `${condo.name}, ${condo.zone}` : condo.name;
          }
        }
        
        // Get agency info for slug
        const agencyData = await db.select({ name: externalAgencies.name, slug: externalAgencies.slug })
          .from(externalAgencies).where(eq(externalAgencies.id, unit.agencyId)).limit(1);
        const agency = agencyData[0];
        const agencySlug = agency?.slug || generateSlug(agency?.name || 'agency');
        
        // Get condominium name for unique slug generation
        let condoName = '';
        if (unit.condominiumId) {
          const condoForSlug = await db
            .select({ name: externalCondominiums.name })
            .from(externalCondominiums)
            .where(eq(externalCondominiums.id, unit.condominiumId))
            .limit(1);
          condoName = condoForSlug[0]?.name || '';
        }
        
        // Use stored slug if exists, otherwise generate unique slug with condominium name
        let unitSlug: string;
        if (unit.slug) {
          unitSlug = unit.slug;
        } else if (condoName) {
          // Include condominium name in slug for uniqueness
          unitSlug = generateSlug(`${condoName}-${unit.unitNumber}`);
        } else {
          // Fallback: use property type + unit number + partial ID for uniqueness
          const unitTitle = unit.title || `${unit.propertyType || 'propiedad'}-${unit.unitNumber}`;
          unitSlug = generateSlug(`${unitTitle}-${unit.id.substring(0, 8)}`);
        }
        
        return {
          id: unit.id,
          title: unit.title || `${unit.propertyType || 'Propiedad'} ${unit.unitNumber}`,
          description: unit.description || null,
          location: location,
          price: parseFloat(unit.price || '0') || 0,
          salePrice: unit.salePrice ? parseFloat(unit.salePrice) : null,
          status: unit.listingType === 'sale' ? 'sale' : unit.listingType === 'both' ? 'both' : 'rent',
          listingType: unit.listingType || 'rent',
          bedrooms: unit.bedrooms || 0,
          bathrooms: unit.bathrooms || 0,
          area: unit.area ? parseFloat(unit.area) : 0,
          primaryImages: unit.primaryImages || [],
          amenities: unit.amenities || [],
          featured: false,
          isExternal: true,
          propertyType: unit.propertyType,
          agencySlug: agencySlug,
          unitSlug: unitSlug,
          currency: unit.currency || 'MXN',
          saleCurrency: unit.saleCurrency || 'MXN',
          minimumTerm: unit.minimumTerm,
          hasFurniture: unit.hasFurniture,
          hasParking: unit.hasParking,
          petsAllowed: unit.petFriendly,
          zone: unit.zone,
          condominiumName: condoName || null,
          unitNumber: unit.unitNumber,
          condominiumId: unit.condominiumId,
        };
      }));
      
      res.json({
        data: properties,
        pagination: {
          page: pageNum,
          limit: limitNum,
          totalCount,
          totalPages: Math.ceil(totalCount / limitNum),
        }
      });
    } catch (error: any) {
      console.error("Error fetching public external properties:", error);
      res.status(500).json({ message: "Error al obtener propiedades" });
    }
  });


  // =============================================================================
  // PUBLIC CHATBOT ENDPOINTS - AI assistant for homepage
  // =============================================================================

  // POST /api/public/chat/start - Start a new chatbot conversation
  app.post("/api/public/chat/start", async (req, res) => {
    try {
      const { sessionId } = req.body;
      
      if (!sessionId) {
        return res.status(400).json({ message: "Session ID is required" });
      }

      // Get the first external agency (Tulum Rental Homes)
      const agencies = await storage.getExternalAgencies();
      if (!agencies || agencies.length === 0) {
        return res.status(404).json({ message: "No agency configured" });
      }
      const agencyId = agencies[0].id;

      // Check if there's an existing active conversation for this session
      let conversation = await storage.getPublicChatbotConversationBySession(agencyId, sessionId);
      
      if (!conversation) {
        // Create new conversation with welcome message
        const { createPublicChatConversation } = await import("./services/publicChatbot");
        conversation = await createPublicChatConversation(agencyId, sessionId);
      }

      res.json({
        conversationId: conversation.id,
        messages: conversation.messages,
      });
    } catch (error: any) {
      console.error("Error starting chatbot conversation:", error);
      res.status(500).json({ message: "Error al iniciar conversación" });
    }
  });

  // POST /api/public/chat/message - Send a message to the chatbot
  app.post("/api/public/chat/message", async (req, res) => {
    try {
      const { conversationId, message } = req.body;

      if (!conversationId || !message) {
        return res.status(400).json({ message: "Conversation ID and message are required" });
      }

      // Get the first external agency (Tulum Rental Homes)
      const agencies = await storage.getExternalAgencies();
      if (!agencies || agencies.length === 0) {
        return res.status(404).json({ message: "No agency configured" });
      }
      const agencyId = agencies[0].id;

      const { processPublicChatMessage } = await import("./services/publicChatbot");
      const response = await processPublicChatMessage(conversationId, message, agencyId);

      res.json(response);
    } catch (error: any) {
      console.error("Error processing chatbot message:", error);
      res.status(500).json({ message: "Error al procesar mensaje" });
    }
  });


  // GET /api/public/condominiums - Public list of condominiums for lead registration
  app.get("/api/public/condominiums", async (req, res) => {
    try {
      const agencies = await storage.getExternalAgencies();
      if (!agencies || agencies.length === 0) {
        return res.json([]);
      }
      const agencyId = agencies[0].id;
      const condominiums = await storage.getExternalCondominiumsByAgency(agencyId);
      const publicCondos = condominiums.map(c => ({
        id: c.id,
        name: c.name,
        neighborhood: c.neighborhood
      }));
      res.json(publicCondos);
    } catch (error: any) {
      console.error("Error fetching public condominiums:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/public/condominiums/:condominiumId/units - Public list of units
  app.get("/api/public/condominiums/:condominiumId/units", async (req, res) => {
    try {
      const { condominiumId } = req.params;
      // Basic UUID validation to prevent injection
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(condominiumId)) {
        return res.json([]);
      }
      const units = await storage.getExternalUnitsByCondominium(condominiumId);
      const publicUnits = units.map(u => ({
        id: u.id,
        unitNumber: u.unitNumber,
        type: u.type
      }));
      res.json(publicUnits);
    } catch (error: any) {
      console.error("Error fetching public units:", error);
      handleGenericError(res, error);
    }
  });
  // GET /api/public/external/terms-and-conditions/active - Public endpoint to get active terms
  app.get("/api/public/external/terms-and-conditions/active", async (req, res) => {
    try {
      const { agencyId, type } = req.query;

      if (!agencyId || !type) {
        return res.status(400).json({ message: "Agency ID and type (tenant or owner) are required" });
      }

      if (type !== 'tenant' && type !== 'owner') {
        return res.status(400).json({ message: "Type must be 'tenant' or 'owner'" });
      }

      const terms = await storage.getActiveExternalTermsAndConditions(agencyId as string, type as 'tenant' | 'owner');
      res.json(terms || null);
    } catch (error: any) {
      console.error("Error fetching active terms:", error);
      handleGenericError(res, error);
    }
  });

  // Public endpoint - GET registration form data (legacy token-based system)
  app.get("/api/leads/:token", async (req, res) => {
    try {
      const { token } = req.params;
      const registrationToken = await storage.getExternalLeadRegistrationToken(token);
      
      if (!registrationToken) {
        return res.status(404).json({ message: "Registration link not found" });
      }
      
      // Check if expired
      if (new Date() > new Date(registrationToken.expiresAt)) {
        return res.status(410).json({ message: "Registration link has expired" });
      }
      
      // Check if already completed
      if (registrationToken.completedAt) {
        return res.status(410).json({ message: "Registration link has already been used" });
      }
      
      // Return only necessary data for form display
      res.json({
        agencyName: registrationToken.agencyName,
        registrationType: registrationToken.registrationType,
        expiresAt: registrationToken.expiresAt,
      });

    } catch (error: any) {
      console.error("Error fetching registration form:", error);
      handleGenericError(res, error);
    }
  });
  // Public endpoint - GET unit characteristics for registration form
  app.get("/api/leads/:token/characteristics", async (req, res) => {
    try {
      const { token } = req.params;
      const registrationToken = await storage.getExternalLeadRegistrationToken(token);
      
      if (!registrationToken) {
        return res.status(404).json({ message: "Registration link not found" });
      }
      
      // Check if expired
      if (new Date() > new Date(registrationToken.expiresAt)) {
        return res.status(410).json({ message: "Registration link has expired" });
      }
      
      // Get unit characteristics for the agency
      const characteristics = await storage.getExternalUnitCharacteristics(registrationToken.agencyId);
      res.json(characteristics);
    } catch (error: any) {
      console.error("Error fetching characteristics:", error);
      handleGenericError(res, error);
    }
  });

  // Public endpoint - GET amenities for registration form
  app.get("/api/leads/:token/amenities", async (req, res) => {
    try {
      const { token } = req.params;
      const registrationToken = await storage.getExternalLeadRegistrationToken(token);
      
      if (!registrationToken) {
        return res.status(404).json({ message: "Registration link not found" });
      }
      
      // Check if expired
      if (new Date() > new Date(registrationToken.expiresAt)) {
        return res.status(410).json({ message: "Registration link has expired" });
      }
      
      // Get amenities for the agency
      const amenities = await storage.getExternalAmenities(registrationToken.agencyId);
      res.json(amenities);
    } catch (error: any) {
      console.error("Error fetching amenities:", error);
      handleGenericError(res, error);
    }
  });

  // Public endpoint - Submit registration form
  app.post("/api/leads/:token", async (req, res) => {
    try {
      const { token } = req.params;
      const registrationToken = await storage.getExternalLeadRegistrationToken(token);
      
      if (!registrationToken) {
        return res.status(404).json({ message: "Registration link not found" });
      }
      
      // Check if expired
      if (new Date() > new Date(registrationToken.expiresAt)) {
        return res.status(410).json({ message: "Registration link has expired" });
      }
      
      // Check if already completed
      if (registrationToken.completedAt) {
        return res.status(410).json({ message: "Registration link has already been used" });
      }
      
      // Validate form data based on registration type
      const { firstName, lastName, email, phone, phoneLast4, notes } = req.body;
      
      if (!firstName || firstName.trim().length === 0) {
        return res.status(400).json({ message: "First name is required" });
      }
      
      if (!lastName || lastName.trim().length === 0) {
        return res.status(400).json({ message: "Last name is required" });
      }
      
      // Different validation for seller vs broker
      if (registrationToken.registrationType === 'seller') {
        if (!email || !phone) {
          return res.status(400).json({ message: "Seller must provide email and phone" });
        }
      } else if (registrationToken.registrationType === 'broker') {
        if (!phoneLast4 || phoneLast4.length !== 4) {
          return res.status(400).json({ message: "Broker must provide last 4 digits of phone" });
        }
      }
      
      // Create lead
      const lead = await storage.createExternalLead({
        agencyId: registrationToken.agencyId,
        registrationType: registrationToken.registrationType,
        firstName: firstName.trim(),
        lastName: lastName.trim(),
        email: email || null,
        phone: phone || null,
        phoneLast4: phoneLast4 || null,
        notes: notes || null,
        status: 'new',
        source: 'public_registration',
        createdBy: null, // Public registration, no user
      });
      
      // Mark token as completed
      await storage.completeExternalLeadRegistrationToken(registrationToken.id, lead.id);
      
      res.status(201).json({ 
        message: "Registration successful",
        leadId: lead.id 
      });
    } catch (error: any) {
      console.error("Error submitting registration:", error);
      handleGenericError(res, error);
    }
  });

  // External Client Documents Endpoints
  // GET /api/external-clients/:clientId/documents - Get all documents for a client
  app.get("/api/external-clients/:clientId/documents", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { clientId } = req.params;
      const client = await storage.getExternalClient(clientId);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const documents = await storage.getExternalClientDocuments(clientId);
      res.json(documents);
    } catch (error: any) {
      console.error("Error fetching client documents:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-clients/:clientId/documents/upload-url - Get upload URL for document
  app.post("/api/external-clients/:clientId/documents/upload-url", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { clientId } = req.params;
      const client = await storage.getExternalClient(clientId);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const { ObjectStorageService } = await import("./objectStorage");
      const objectStorageService = new ObjectStorageService();
      const { uploadURL, objectPath } = await objectStorageService.getObjectEntityUploadURL("client-documents");
      
      res.json({ uploadURL, objectPath });
    } catch (error: any) {
      console.error("Error generating upload URL:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-clients/:clientId/documents - Create document record after upload
  app.post("/api/external-clients/:clientId/documents", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { clientId } = req.params;
      const client = await storage.getExternalClient(clientId);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const { ObjectStorageService } = await import("./objectStorage");
      const objectStorageService = new ObjectStorageService();
      const storageKey = req.body.objectPath;
      
      const validatedData = insertExternalClientDocumentSchema.parse({
        ...req.body,
        clientId,
        storageKey,
        uploadedBy: req.user.id,
      });
      
      const document = await storage.createExternalClientDocument(validatedData);
      await createAuditLog(req, "create", "external_client_document", document.id, `Uploaded document: ${document.fileName}`);
      
      res.status(201).json(document);
    } catch (error: any) {
      console.error("Error creating client document:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-client-documents/:id - Delete document
  app.delete("/api/external-client-documents/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const document = await storage.getExternalClientDocument(id);
      
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      const client = await storage.getExternalClient(document.clientId);
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalClientDocument(id);
      await createAuditLog(req, "delete", "external_client_document", id, "Deleted client document");
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting client document:", error);
      handleGenericError(res, error);
    }
  });

  // External Client Incidents Endpoints
  // GET /api/external-clients/:clientId/incidents - Get all incidents for a client
  app.get("/api/external-clients/:clientId/incidents", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { clientId } = req.params;
      const client = await storage.getExternalClient(clientId);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const { severity, status } = req.query;
      const incidents = await storage.getExternalClientIncidents(clientId, {
        severity: severity as string | undefined,
        status: status as string | undefined,
      });
      
      res.json(incidents);
    } catch (error: any) {
      console.error("Error fetching client incidents:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external-clients/:clientId/incidents - Create new incident
  app.post("/api/external-clients/:clientId/incidents", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { clientId } = req.params;
      const client = await storage.getExternalClient(clientId);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const validatedData = insertExternalClientIncidentSchema.parse({
        ...req.body,
        clientId,
        reportedBy: req.user.id,
      });
      
      const incident = await storage.createExternalClientIncident(validatedData);
      await createAuditLog(req, "create", "external_client_incident", incident.id, `Created incident: ${incident.title}`);
      
      res.status(201).json(incident);
    } catch (error: any) {
      console.error("Error creating client incident:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external-client-incidents/:id - Update incident
  app.patch("/api/external-client-incidents/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const incident = await storage.getExternalClientIncident(id);
      
      if (!incident) {
        return res.status(404).json({ message: "Incident not found" });
      }
      
      const client = await storage.getExternalClient(incident.clientId);
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const validatedData = updateExternalClientIncidentSchema.parse(req.body);
      const updatedIncident = await storage.updateExternalClientIncident(id, validatedData);
      
      await createAuditLog(req, "update", "external_client_incident", id, "Updated client incident");
      res.json(updatedIncident);
    } catch (error: any) {
      console.error("Error updating client incident:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external-client-incidents/:id - Delete incident
  app.delete("/api/external-client-incidents/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const incident = await storage.getExternalClientIncident(id);
      
      if (!incident) {
        return res.status(404).json({ message: "Incident not found" });
      }
      
      const client = await storage.getExternalClient(incident.clientId);
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalClientIncident(id);
      await createAuditLog(req, "delete", "external_client_incident", id, "Deleted client incident");
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting client incident:", error);
      handleGenericError(res, error);
    }
  });
  // ==============================

  // ==============================
  // External Referral Network Routes
  // ==============================

  // GET /api/external/referral-network - Get referral network for agency
  app.get("/api/external/referral-network", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      // Get all units with referido commission type and group by referrer
      const result = await db.execute(sql`
        SELECT 
          u.id,
          u.unit_number as "unitNumber",
          u.referrer_name as "referrerName",
          u.referrer_phone as "referrerPhone",
          u.referrer_email as "referrerEmail",
          u.price as "monthlyRent12",
          COALESCE(u.publish_status, 'draft') as status,
          c.name as "condominiumName"
        FROM external_units u
        LEFT JOIN external_condominiums c ON u.condominium_id = c.id
        WHERE u.agency_id = ${agencyId}
          -- Removed: AND u.commission_type = 'referido' (show all referrers)
          AND u.referrer_name IS NOT NULL
          AND u.referrer_name != ''
        ORDER BY u.referrer_name, u.unit_number
      `);

      const units = result.rows as any[];

      // Group units by referrer
      const referrerMap = new Map<string, {
        referrerName: string;
        referrerPhone: string | null;
        referrerEmail: string | null;
        units: any[];
        totalUnits: number;
        estimatedCommission: number;
      }>();

      for (const unit of units) {
        const referrerName = unit.referrerName;
        
        if (!referrerMap.has(referrerName)) {
          referrerMap.set(referrerName, {
            referrerName,
            referrerPhone: unit.referrerPhone,
            referrerEmail: unit.referrerEmail,
            units: [],
            totalUnits: 0,
            estimatedCommission: 0,
          });
        }

        const referrer = referrerMap.get(referrerName)!;
        referrer.units.push({
          id: unit.id,
          unitNumber: unit.unitNumber,
          condominiumName: unit.condominiumName,
          monthlyRent12: unit.monthlyRent12,
          status: unit.status,
        });
        referrer.totalUnits++;
        
        // Calculate estimated commission (20% of monthly rent)
        if (unit.monthlyRent12) {
          referrer.estimatedCommission += Number(unit.monthlyRent12) * 0.20;
        }
      }

      const referrers = Array.from(referrerMap.values()).sort((a, b) => 
        b.totalUnits - a.totalUnits
      );

      res.json(referrers);
    } catch (error) {
      console.error("Error fetching referral network:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/referral-network/bulk-assign - Bulk assign referrer to multiple units
  app.post("/api/external/referral-network/bulk-assign", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { referrerName, referrerEmail, referrerPhone, unitIds, commissionType } = req.body;

      // Validate and sanitize referrer name
      const sanitizedName = typeof referrerName === 'string' ? referrerName.trim() : '';
      if (!sanitizedName || sanitizedName.length > 200) {
        return res.status(400).json({ message: "Valid referrer name is required (max 200 characters)" });
      }

      // Validate unitIds is an array of valid UUIDs
      if (!unitIds || !Array.isArray(unitIds) || unitIds.length === 0) {
        return res.status(400).json({ message: "At least one unit ID is required" });
      }
      
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      const validUnitIds = unitIds.filter((id: any) => typeof id === 'string' && uuidRegex.test(id));
      if (validUnitIds.length !== unitIds.length) {
        return res.status(400).json({ message: "Invalid unit ID format detected" });
      }

      // Sanitize optional fields
      const sanitizedEmail = typeof referrerEmail === 'string' ? referrerEmail.trim().slice(0, 254) : null;
      const sanitizedPhone = typeof referrerPhone === 'string' ? referrerPhone.trim().slice(0, 50) : null;
      const validCommissionType = ['completa', 'referido'].includes(commissionType) ? commissionType : 'referido';

      // Verify all units belong to this agency before updating
      const verifyResult = await db.execute(sql`
        SELECT COUNT(*) as count FROM external_units 
        WHERE id = ANY(${validUnitIds}) AND agency_id = ${agencyId}
      `);
      const verifiedCount = parseInt((verifyResult.rows[0] as any)?.count || '0', 10);
      if (verifiedCount !== validUnitIds.length) {
        return res.status(403).json({ message: "Some units do not belong to your agency" });
      }

      // Update all verified units with referrer info using parameterized query
      await db.execute(sql`
        UPDATE external_units 
        SET referrer_name = ${sanitizedName}, 
            referrer_email = ${sanitizedEmail}, 
            referrer_phone = ${sanitizedPhone}, 
            commission_type = ${validCommissionType}, 
            updated_at = NOW() 
        WHERE id = ANY(${validUnitIds}) AND agency_id = ${agencyId}
      `);

      res.json({ 
        success: true, 
        message: `Referrer assigned to ${validUnitIds.length} unit(s)`, 
        updatedCount: validUnitIds.length 
      });
    } catch (error: any) {
      console.error("Error bulk assigning referrer:", error);
      res.status(500).json({ message: "An error occurred while assigning referrer" });
    }
  });

  // GET /api/external/referral-network/referrers - Get list of unique referrers
  app.get("/api/external/referral-network/referrers", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const result = await db.execute(sql`SELECT DISTINCT referrer_name as "name", referrer_email as "email", referrer_phone as "phone" FROM external_units WHERE agency_id = ${agencyId} AND referrer_name IS NOT NULL AND referrer_name != '' ORDER BY referrer_name`);

      res.json(result.rows);
    } catch (error: any) {
      console.error("Error fetching referrers:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/referral-network/available-units - Get units available for referral assignment
  app.get("/api/external/referral-network/available-units", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const result = await db.execute(sql`SELECT u.id, u.unit_number as "unitNumber", c.name as "condominiumName", u.referrer_name as "currentReferrer" FROM external_units u LEFT JOIN external_condominiums c ON u.condominium_id = c.id WHERE u.agency_id = ${agencyId} ORDER BY c.name, u.unit_number`);

      res.json(result.rows);
    } catch (error: any) {
      console.error("Error fetching available units:", error);
      res.status(500).json({ message: error.message });
    }
  });
  // External Presentation Cards Routes
  // ==============================

  // GET /api/external/presentation-cards - Get all presentation cards for agency
  app.get("/api/external/presentation-cards", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { status, leadId, clientId } = req.query;
      const filters: { status?: string; leadId?: string; clientId?: string } = {};
      if (status) filters.status = status;
      if (leadId) filters.leadId = leadId;
      if (clientId) filters.clientId = clientId;
      
      const cards = await storage.getExternalPresentationCardsByAgency(agencyId, filters);
      res.json(cards);
    } catch (error: any) {
      console.error("Error fetching presentation cards:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/presentation-cards/lead/:leadId - Get presentation cards for lead
  app.get("/api/external/presentation-cards/lead/:leadId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { leadId } = req.params;
      const lead = await storage.getExternalLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, lead.agencyId);
      if (!hasAccess) return;
      
      const cards = await storage.getExternalPresentationCardsByLead(leadId);
      res.json(cards);
    } catch (error: any) {
      console.error("Error fetching lead presentation cards:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/presentation-cards/client/:clientId - Get presentation cards for client
  app.get("/api/external/presentation-cards/client/:clientId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { clientId } = req.params;
      const client = await storage.getExternalClient(clientId);
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, client.agencyId);
      if (!hasAccess) return;
      
      const cards = await storage.getExternalPresentationCardsByClient(clientId);
      res.json(cards);
    } catch (error: any) {
      console.error("Error fetching client presentation cards:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/presentation-cards/:id - Get single presentation card
  app.get("/api/external/presentation-cards/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const card = await storage.getExternalPresentationCard(id);
      
      if (!card) {
        return res.status(404).json({ message: "Presentation card not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, card.agencyId);
      if (!hasAccess) return;
      
      res.json(card);
    } catch (error: any) {
      console.error("Error fetching presentation card:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/presentation-cards - Create presentation card
  app.post("/api/external/presentation-cards", isAuthenticated, requireRole(EXTERNAL_SELLER_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const cardData = { ...req.body, agencyId, createdBy: req.user.id };
      
      if (cardData.leadId) {
        const lead = await storage.getExternalLead(cardData.leadId);
        if (!lead || lead.agencyId !== agencyId) {
          return res.status(404).json({ message: "Lead not found" });
        }
        // Check limit of 3 cards per lead
        const existingCards = await db.select({ count: sql`count(*)` })
          .from(externalPresentationCards)
          .where(and(
            eq(externalPresentationCards.leadId, cardData.leadId),
            eq(externalPresentationCards.agencyId, agencyId)
          ));
        const cardCount = Number(existingCards[0]?.count || 0);
        if (cardCount >= 3) {
          return res.status(400).json({ message: "Maximum 3 presentation cards per lead allowed" });
        }
        cardData.cardNumber = cardCount + 1;
      }
      if (cardData.clientId) {
        const client = await storage.getExternalClient(cardData.clientId);
        if (!client || client.agencyId !== agencyId) {
          return res.status(404).json({ message: "Client not found" });
        }
        // Check limit of 3 cards per client
        const existingClientCards = await db.select({ count: sql`count(*)` })
          .from(externalPresentationCards)
          .where(and(
            eq(externalPresentationCards.clientId, cardData.clientId),
            eq(externalPresentationCards.agencyId, agencyId)
          ));
        const clientCardCount = Number(existingClientCards[0]?.count || 0);
        if (clientCardCount >= 3) {
          return res.status(400).json({ message: "Maximum 3 presentation cards per client allowed" });
        }
        cardData.cardNumber = clientCardCount + 1;
      }
      
      const card = await storage.createExternalPresentationCard(cardData);
      await createAuditLog(req, "create", "external_presentation_card", card.id, "Created presentation card");
      
      res.status(201).json(card);
    } catch (error: any) {
      console.error("Error creating presentation card:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/presentation-cards/:id - Update presentation card
  app.patch("/api/external/presentation-cards/:id", isAuthenticated, requireRole(EXTERNAL_SELLER_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const card = await storage.getExternalPresentationCard(id);
      
      if (!card) {
        return res.status(404).json({ message: "Presentation card not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, card.agencyId);
      if (!hasAccess) return;
      
      // Validate leadId/clientId if being changed to prevent cross-tenant tampering
      const { leadId, clientId, ...otherUpdates } = req.body;
      
      if (leadId !== undefined && leadId !== card.leadId) {
        if (leadId) {
          const lead = await storage.getExternalLead(leadId);
          if (!lead || lead.agencyId !== agencyId) {
            return res.status(403).json({ message: "Cannot link to lead from another agency" });
          }
        }
      }
      
      if (clientId !== undefined && clientId !== card.clientId) {
        if (clientId) {
          const client = await storage.getExternalClient(clientId);
          if (!client || client.agencyId !== agencyId) {
            return res.status(403).json({ message: "Cannot link to client from another agency" });
          }
        }
      }
      
      const updated = await storage.updateExternalPresentationCard(id, req.body);
      await createAuditLog(req, "update", "external_presentation_card", id, "Updated presentation card");
      
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating presentation card:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/presentation-cards/:id - Delete presentation card
  app.delete("/api/external/presentation-cards/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const card = await storage.getExternalPresentationCard(id);
      
      if (!card) {
        return res.status(404).json({ message: "Presentation card not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, card.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalPresentationCard(id);
      await createAuditLog(req, "delete", "external_presentation_card", id, "Deleted presentation card");
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting presentation card:", error);
      handleGenericError(res, error);
    }
  });

  // ==============================
  // External Property Showings Routes
  // ==============================

  // GET /api/external/property-showings - Get all showings for agency
  app.get("/api/external/property-showings", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { outcome, startDate, endDate, leadId, clientId } = req.query;
      const filters: { outcome?: string; startDate?: Date; endDate?: Date; leadId?: string; clientId?: string } = {};
      if (outcome) filters.outcome = outcome;
      if (startDate) filters.startDate = new Date(startDate);
      if (endDate) filters.endDate = new Date(endDate);
      if (leadId) filters.leadId = leadId;
      if (clientId) filters.clientId = clientId;
      
      const showings = await storage.getExternalPropertyShowingsByAgency(agencyId, filters);
      res.json(showings);
    } catch (error: any) {
      console.error("Error fetching property showings:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/property-showings/card/:cardId - Get showings for a presentation card
  app.get("/api/external/property-showings/card/:cardId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { cardId } = req.params;
      const card = await storage.getExternalPresentationCard(cardId);
      if (!card) {
        return res.status(404).json({ message: "Presentation card not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, card.agencyId);
      if (!hasAccess) return;
      
      const showings = await storage.getExternalPropertyShowingsByCard(cardId);
      res.json(showings);
    } catch (error: any) {
      console.error("Error fetching card showings:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/property-showings/unit/:unitId - Get showings for a unit
  app.get("/api/external/property-showings/unit/:unitId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const showings = await storage.getExternalPropertyShowingsByUnit(unitId);
      res.json(showings);
    } catch (error: any) {
      console.error("Error fetching unit showings:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/property-showings/:id - Get single showing
  app.get("/api/external/property-showings/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const showing = await storage.getExternalPropertyShowing(id);
      
      if (!showing) {
        return res.status(404).json({ message: "Property showing not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, showing.agencyId);
      if (!hasAccess) return;
      
      res.json(showing);
    } catch (error: any) {
      console.error("Error fetching property showing:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/property-showings - Create property showing
  app.post("/api/external/property-showings", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const showingData = { ...req.body, agencyId, recordedBy: req.user.id };
      
      const unit = await storage.getExternalUnit(showingData.unitId);
      if (!unit || unit.agencyId !== agencyId) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Validate leadId/clientId ownership to prevent cross-tenant tampering
      if (showingData.leadId) {
        const lead = await storage.getExternalLead(showingData.leadId);
        if (!lead || lead.agencyId !== agencyId) {
          return res.status(403).json({ message: "Cannot link to lead from another agency" });
        }
      }
      
      if (showingData.clientId) {
        const client = await storage.getExternalClient(showingData.clientId);
        if (!client || client.agencyId !== agencyId) {
          return res.status(403).json({ message: "Cannot link to client from another agency" });
        }
      }
      
      if (showingData.presentationCardId) {
        const card = await storage.getExternalPresentationCard(showingData.presentationCardId);
        if (!card || card.agencyId !== agencyId) {
          return res.status(403).json({ message: "Cannot link to presentation card from another agency" });
        }
        await storage.incrementPresentationCardUsage(showingData.presentationCardId);
      }
      
      const showing = await storage.createExternalPropertyShowing(showingData);
      await createAuditLog(req, "create", "external_property_showing", showing.id, "Created property showing record");
      
      res.status(201).json(showing);
    } catch (error: any) {
      console.error("Error creating property showing:", error);
      handleGenericError(res, error);
    }
  });
  // PATCH /api/external/property-showings/:id - Update property showing
  app.patch("/api/external/property-showings/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const showing = await storage.getExternalPropertyShowing(id);
      
      if (!showing) {
        return res.status(404).json({ message: "Property showing not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, showing.agencyId);
      if (!hasAccess) return;
      
      // Validate leadId/clientId/presentationCardId if being changed to prevent cross-tenant tampering
      const { leadId, clientId, presentationCardId, unitId, ...otherUpdates } = req.body;
      
      if (leadId !== undefined && leadId !== showing.leadId) {
        if (leadId) {
          const lead = await storage.getExternalLead(leadId);
          if (!lead || lead.agencyId !== agencyId) {
            return res.status(403).json({ message: "Cannot link to lead from another agency" });
          }
        }
      }
      
      if (clientId !== undefined && clientId !== showing.clientId) {
        if (clientId) {
          const client = await storage.getExternalClient(clientId);
          if (!client || client.agencyId !== agencyId) {
            return res.status(403).json({ message: "Cannot link to client from another agency" });
          }
        }
      }
      
      if (presentationCardId !== undefined && presentationCardId !== showing.presentationCardId) {
        if (presentationCardId) {
          const card = await storage.getExternalPresentationCard(presentationCardId);
          if (!card || card.agencyId !== agencyId) {
            return res.status(403).json({ message: "Cannot link to presentation card from another agency" });
          }
        }
      }
      
      if (unitId !== undefined && unitId !== showing.unitId) {
        if (unitId) {
          const unit = await storage.getExternalUnit(unitId);
          if (!unit || unit.agencyId !== agencyId) {
            return res.status(403).json({ message: "Cannot link to unit from another agency" });
          }
        }
      }
      
      const updated = await storage.updateExternalPropertyShowing(id, req.body);
      await createAuditLog(req, "update", "external_property_showing", id, "Updated property showing record");
      
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating property showing:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/property-showings/:id - Delete property showing
  app.delete("/api/external/property-showings/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const showing = await storage.getExternalPropertyShowing(id);
      
      if (!showing) {
        return res.status(404).json({ message: "Property showing not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, showing.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalPropertyShowing(id);
      await createAuditLog(req, "delete", "external_property_showing", id, "Deleted property showing record");
      
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting property showing:", error);
      handleGenericError(res, error);
    }
  });



  // ==============================
  // External Token Routes (Contracts Section)
  // ==============================

  // GET /api/external/offer-tokens - Get offer tokens for agency (optimized single query)
  app.get("/api/external/offer-tokens", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      // Use optimized single-query method that includes all joined data
      const tokens = await storage.getExternalOfferTokenSummariesByAgency(agencyId);
      res.json(tokens);
    } catch (error: any) {
      console.error("Error fetching external offer tokens:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/offer-tokens/:tokenId/regenerate - Regenerate offer token (delete old active ones, preserve completed)
  app.post("/api/offer-tokens/:tokenId/regenerate", isAuthenticated, tokenRegenerationLimiter, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { tokenId } = req.params;
      
      // Get the current token
      const [currentToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.id, tokenId))
        .limit(1);
        
      if (!currentToken) {
        return res.status(404).json({ message: "Token not found" });
      }

      // Validate it belongs to the agency
      if (currentToken.externalUnitId) {
        const unit = await storage.getExternalUnit(currentToken.externalUnitId);
        if (!unit || unit.agencyId !== agencyId) {
          return res.status(403).json({ message: "Unauthorized" });
        }
      }

      // Cannot regenerate completed tokens
      if (currentToken.isUsed) {
        return res.status(400).json({ message: "Cannot regenerate completed token" });
      }

      const clientId = currentToken.externalClientId;
      if (!clientId) {
        return res.status(400).json({ message: "Invalid token: missing client" });
      }

      // Create new token with same details but new expiration
      const newTokenValue = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now
      
      // Get user ID from authentication (handles both Replit Auth and local sessions)
      const userId = req.user?.claims?.sub || req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const [newToken] = await db.insert(offerTokens).values({
        token: newTokenValue,
        propertyId: currentToken.propertyId,
        externalUnitId: currentToken.externalUnitId,
        externalClientId: currentToken.externalClientId,
        leadId: null,
        createdBy: userId,
        expiresAt,
        isUsed: false,
      }).returning();

      // Now delete all OTHER active (non-completed) tokens for this client
      // This preserves completed tokens (isUsed = true) and the new token we just created
      await db.delete(offerTokens)
        .where(
          and(
            eq(offerTokens.externalClientId, clientId),
            eq(offerTokens.isUsed, false),
            ne(offerTokens.id, newToken.id)
          )
        );

      res.json(newToken);
    } catch (error: any) {
      console.error("Error regenerating offer token:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/rental-form-tokens - Get rental form tokens for agency (optimized)
  app.get("/api/external/rental-form-tokens", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      console.log("[Rental Form Tokens] Request from user:", req.user?.claims?.sub || req.user?.id, "cachedAgencyId:", req.user?.cachedAgencyId);
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        console.log("[Rental Form Tokens] AgencyId resolved (null):", agencyId);
        return res.status(403).json({ message: "No agency access" });
      }
      console.log("[Rental Form Tokens] AgencyId resolved:", agencyId);
      
      // Use optimized single-query method that includes unit, condo, client, owner, creator
      const tokens = await storage.getExternalRentalFormTokenSummariesByAgency(agencyId);
      
      // Only need to get dual form status for tokens with rentalFormGroupId
      // This is a much smaller loop than before (only tokens with groups)
      const tokensWithDualStatus = await Promise.all(
        tokens.map(async (token: any) => {
          let dualFormStatus = null;
          
          if (token.rentalFormGroupId) {
            // Find the companion form by linkedTokenId
            const companionForm = await db.query.tenantRentalFormTokens.findFirst({
              where: eq(tenantRentalFormTokens.id, token.rentalFormGroupId),
            });
            
            if (companionForm) {
              dualFormStatus = {
                hasDual: true,
                dualType: companionForm.recipientType,
                dualCompleted: companionForm.isUsed,
              };
            }
          }
          
          return {
            ...token,
            agencyId,
            dualFormStatus,
          };
        })
      );
      
      res.json(tokensWithDualStatus);
    } catch (error: any) {
      console.error("Error fetching external rental form tokens:", error);
      handleGenericError(res, error);
    }
  });


  // Helper function to resolve unit context from rental form token
  async function resolveExternalUnitContext(token: any, agencyId: string) {
    // Validate token is completed - check appropriate data field based on recipientType
    if (token.recipientType === 'tenant') {
      if (!token.isUsed || !token.tenantData) {
        throw { status: 400, message: "El formulario de inquilino aún no ha sido completado" };
      }
    } else if (token.recipientType === 'owner') {
      if (!token.isUsed || !token.ownerData) {
        throw { status: 400, message: "El formulario de propietario aún no ha sido completado" };
      }
    } else {
      throw { status: 400, message: "Tipo de formulario inválido" };
    }

    let unit;
    
    // Resolve unit based on token type
    if (token.externalUnitId) {
      // Tenant token - direct unit reference
      unit = await storage.getExternalUnit(token.externalUnitId);
      if (!unit) {
        throw { status: 404, message: "Unidad no encontrada" };
      }
      if (unit.agencyId !== agencyId) {
        throw { status: 403, message: "Unauthorized" };
      }
    } else if (token.externalUnitOwnerId) {
      // Owner token - get unit from owner record
      const owner = await storage.getExternalUnitOwner(token.externalUnitOwnerId);
      if (!owner) {
        throw { status: 404, message: "Propietario no encontrado" };
      }
      
      // SECURITY: Validate that owner belongs to the correct agency
      // First get the unit to check agency
      unit = await storage.getExternalUnit(owner.unitId);
      if (!unit) {
        throw { status: 404, message: "Unidad no encontrada" };
      }
      if (unit.agencyId !== agencyId) {
        throw { status: 403, message: "Unauthorized - agency mismatch" };
      }
    } else {
      throw { status: 400, message: "Este token no es del sistema externo" };
    }

    // Get condominium info
    const condo = unit.condominiumId ? await storage.getExternalCondominium(unit.condominiumId) : null;
    const propertyTitle = `${condo?.name || ''} - Unidad ${unit.unitNumber}`;

    return {
      unit,
      condo,
      propertyTitle,
      propertyForPDF: {
        id: unit.id,
        title: propertyTitle,
        address: condo?.address || '',
        city: condo?.city || 'Tulum',
        state: condo?.state || 'Quintana Roo',
        country: condo?.country || 'México',
      }
    };
  }
  // GET /api/external/rental-forms/:id/pdf - Generate PDF for rental form
  app.get("/api/external/rental-forms/:id/pdf", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { id } = req.params;

      // Get rental form token
      const [rentalFormToken] = await db
        .select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.id, id))
        .limit(1);

      if (!rentalFormToken) {
        return res.status(404).json({ message: "Formulario de renta no encontrado" });
      }


      // Resolve unit context using helper function
      const { propertyForPDF } = await resolveExternalUnitContext(rentalFormToken, agencyId);

      // Get agency info for branding
      const agency = await storage.getExternalAgency(agencyId);
      const agencyName = agency?.name || '';
      const templateStyle = (agency?.pdfTemplateStyle as 'professional' | 'modern' | 'elegant') || 'professional';
      const agencyLogoUrl = agency?.agencyLogoUrl || null;

      // Generate appropriate PDF based on recipient type
      let pdfBuffer;
      if (rentalFormToken.recipientType === 'tenant') {
        pdfBuffer = await generateRentalFormPDF(rentalFormToken.tenantData, propertyForPDF, agencyName, agencyLogoUrl, templateStyle);
      } else {
        // For owner forms, use owner-specific PDF generator if available
        pdfBuffer = await generateOwnerFormPDF(rentalFormToken.tenantData, propertyForPDF, agencyName, agencyLogoUrl, templateStyle);
      }

      // Set headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="formulario-${rentalFormToken.recipientType}-${rentalFormToken.id}.pdf"`);
      res.send(pdfBuffer);
    } catch (error: any) {
      console.error("Error generating rental form PDF:", error);
      if (error.status) {
        return res.status(error.status).json({ message: error.message });
      }
      res.status(500).json({ message: "Error al generar PDF" });
    }
  });

  // PATCH /api/external/rental-forms/:id - Update completed rental form data
  app.patch("/api/external/rental-forms/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { id } = req.params;

      // Get rental form token
      const [rentalFormToken] = await db
        .select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.id, id))
        .limit(1);

      if (!rentalFormToken) {
        return res.status(404).json({ message: "Formulario de renta no encontrado" });
      }

      // Verify token belongs to user's agency
      if (rentalFormToken.externalUnitId) {
        const unit = await storage.getExternalUnit(rentalFormToken.externalUnitId);
        if (!unit || unit.agencyId !== agencyId) {
          return res.status(403).json({ message: "Unauthorized" });
        }
      } else if (rentalFormToken.externalUnitOwnerId) {
        // For owner forms, verify via owner's agency
        const owner = await storage.getExternalUnitOwner(rentalFormToken.externalUnitOwnerId);
        if (!owner || owner.agencyId !== agencyId) {
          return res.status(403).json({ message: "Unauthorized" });
        }
      } else {
        return res.status(400).json({ message: "Este token no es del sistema externo" });
      }

      // Must be a completed form to edit
      if (!rentalFormToken.isUsed) {
        return res.status(400).json({ message: "Solo se pueden editar formularios completados" });
      }

      // Define validation schemas for tenant and owner forms
      const tenantFieldsSchema = z.object({
        fullName: z.string().optional(),
        email: z.string().email().optional().or(z.literal("")),
        whatsapp: z.string().optional(),
        nationality: z.string().optional(),
        age: z.number().optional(),
        maritalStatus: z.string().optional(),
        timeInTulum: z.string().optional(),
        address: z.string().optional(),
        // Employment fields
        jobPosition: z.string().optional(),
        companyName: z.string().optional(),
        workAddress: z.string().optional(),
        workPhone: z.string().optional(),
        monthlyIncome: z.number().optional(),
        // Rental preferences
        desiredMoveInDate: z.string().optional(),
        desiredMoveOutDate: z.string().optional(),
        numberOfOccupants: z.number().optional(),
        hasPets: z.boolean().optional(),
        hasVehicle: z.boolean().optional(),
      }).passthrough();

      const ownerFieldsSchema = z.object({
        fullName: z.string().optional(),
        email: z.string().email().optional().or(z.literal("")),
        whatsapp: z.string().optional(),
        nationality: z.string().optional(),
        age: z.number().optional(),
        address: z.string().optional(),
        // Owner-specific fields
        bankName: z.string().optional(),
        accountNumber: z.string().optional(),
        clabe: z.string().optional(),
        paymentPreference: z.string().optional(),
        minimumRentalPeriod: z.string().optional(),
        maximumOccupants: z.number().optional(),
        petsAllowed: z.boolean().optional(),
      }).passthrough();

      // Use appropriate schema based on recipientType
      const schema = rentalFormToken.recipientType === 'owner' ? ownerFieldsSchema : tenantFieldsSchema;
      const validatedData = schema.parse(req.body.formData || {});

      // Deep merge function to preserve nested structures
      const deepMerge = (target: any, source: any) => {
        const output = { ...target };
        for (const key in source) {
          if (source[key] !== undefined && source[key] !== null) {
            // Only update if source has a defined value
            if (Array.isArray(source[key])) {
              // For arrays, preserve existing if source is empty, otherwise replace
              output[key] = source[key].length > 0 ? source[key] : (target[key] || []);
            } else if (typeof source[key] === 'object' && !Array.isArray(source[key])) {
              // For objects, deep merge
              output[key] = deepMerge(target[key] || {}, source[key]);
            } else {
              // For primitives, use source value
              output[key] = source[key];
            }
          }
        }
        return output;
      };

      // Merge validated data with existing data to preserve all fields
      const currentData = rentalFormToken.tenantData || {};
      const updatedData = deepMerge(currentData, validatedData);

      // Update tenant data
      const [updated] = await db
        .update(tenantRentalFormTokens)
        .set({ 
          tenantData: updatedData,
          updatedAt: new Date(),
        })
        .where(eq(tenantRentalFormTokens.id, id))
        .returning();

      await createAuditLog(
        req,
        "update",
        "tenant_rental_form_token",
        id,
        `Updated completed rental form data (${rentalFormToken.recipientType})`
      );

      res.json(updated);
    } catch (error) {
      console.error("Error updating rental form:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Datos inválidos", errors: error.errors });
      }
      res.status(500).json({ message: "Error al actualizar formulario" });
    }
  });

  // GET /api/external/offers/:id/pdf - Generate PDF for external offer
  app.get("/api/external/offers/:id/pdf", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { id } = req.params;

      // Get offer token
      const [offerToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.id, id))
        .limit(1);

      if (!offerToken) {
        return res.status(404).json({ message: "Token de oferta no encontrado" });
      }

      // Verify token belongs to user's agency
      if (offerToken.externalUnitId) {
        const unit = await storage.getExternalUnit(offerToken.externalUnitId);
        if (!unit || unit.agencyId !== agencyId) {
          return res.status(403).json({ message: "Unauthorized" });
        }
      } else {
        return res.status(400).json({ message: "Este token no es del sistema externo" });
      }

      if (!offerToken.isUsed || !offerToken.offerData) {
        return res.status(400).json({ message: "La oferta aún no ha sido completada" });
      }

      // Get unit info
      const unit = await storage.getExternalUnit(offerToken.externalUnitId);
      if (!unit) {
        return res.status(404).json({ message: "Unidad no encontrada" });
      }

      // Get condominium info
      const condo = await storage.getExternalCondominium(unit.condominiumId);
      const propertyTitle = `${condo?.name || ''} - Unidad ${unit.unitNumber}`;

      // Create a property-like object for PDF generation
      const propertyForPDF = {
        id: unit.id,
        title: propertyTitle,
        address: condo?.address || '',
        city: condo?.city || 'Tulum',
        state: condo?.state || 'Quintana Roo',
        country: condo?.country || 'México',
      };

      // Generate PDF
      const pdfBuffer = await generateOfferPDF(offerToken.offerData, propertyForPDF);

      // Set headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="oferta-${offerToken.id}.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Error generating PDF:", error);
      res.status(500).json({ message: "Error al generar PDF" });
    }
  });

  // PATCH /api/external/offers/:id - Update completed offer data
  app.patch("/api/external/offers/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { id } = req.params;

      // Get offer token
      const [offerToken] = await db
        .select()
        .from(offerTokens)
        .where(eq(offerTokens.id, id))
        .limit(1);

      if (!offerToken) {
        return res.status(404).json({ message: "Token de oferta no encontrado" });
      }

      // Verify token belongs to user's agency
      if (offerToken.externalUnitId) {
        const unit = await storage.getExternalUnit(offerToken.externalUnitId);
        if (!unit || unit.agencyId !== agencyId) {
          return res.status(403).json({ message: "Unauthorized" });
        }
      } else {
        return res.status(400).json({ message: "Este token no es del sistema externo" });
      }

      // Must be a completed offer to edit
      if (!offerToken.isUsed) {
        return res.status(400).json({ message: "Solo se pueden editar ofertas completadas" });
      }

      // Update offer data
      const [updated] = await db
        .update(offerTokens)
        .set({ 
          offerData: req.body.offerData,
          updatedAt: new Date(),
        })
        .where(eq(offerTokens.id, id))
        .returning();

      await createAuditLog(
        req,
        "update",
        "offer_token",
        id,
        "Updated completed offer data"
      );

      res.json(updated);
    } catch (error) {
      console.error("Error updating offer:", error);
      res.status(500).json({ message: "Error al actualizar oferta" });
    }
  });

  // POST /api/rental-form-tokens/:tokenId/regenerate - Regenerate rental form token (delete old active ones, preserve completed)
  app.post("/api/rental-form-tokens/:tokenId/regenerate", isAuthenticated, tokenRegenerationLimiter, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { tokenId } = req.params;
      
      // Get the current token
      const [currentToken] = await db.select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.id, tokenId))
        .limit(1);
      
      if (!currentToken) {
        return res.status(404).json({ message: "Token not found" });
      }

      // Validate it belongs to the agency
      if (currentToken.externalUnitId) {
        const unit = await storage.getExternalUnit(currentToken.externalUnitId);
        if (!unit || unit.agencyId !== agencyId) {
          return res.status(403).json({ message: "Unauthorized" });
        }
      }

      // Cannot regenerate completed tokens
      if (currentToken.isUsed) {
        return res.status(400).json({ message: "Cannot regenerate completed token" });
      }

      const clientId = currentToken.externalClientId;
      if (!clientId) {
        return res.status(400).json({ message: "Invalid token: missing client" });
      }

      // Create new token with same details but new expiration
      const newTokenValue = crypto.randomBytes(8).toString('hex');
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24); // 24 hours from now
      
      // Get user ID from authentication (handles both Replit Auth and local sessions)
      const userId = req.user?.claims?.sub || req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const [newToken] = await db.insert(tenantRentalFormTokens).values({
        token: newTokenValue,
        propertyId: currentToken.propertyId,
        externalUnitId: currentToken.externalUnitId,
        externalClientId: currentToken.externalClientId,
        leadId: currentToken.leadId,
        createdBy: userId,
        expiresAt,
        isUsed: false,
      }).returning();

      // Now delete all OTHER active (non-completed) tokens for this client
      // This preserves completed tokens (isUsed = true) and the new token we just created
      await db.delete(tenantRentalFormTokens)
        .where(
          and(
            eq(tenantRentalFormTokens.externalClientId, clientId),
            eq(tenantRentalFormTokens.isUsed, false),
            ne(tenantRentalFormTokens.id, newToken.id)
          )
        );

      res.json(newToken);
    } catch (error: any) {
      console.error("Error regenerating rental form token:", error);
      handleGenericError(res, error);
    }
  });

  // Optimized endpoints for rental filters
  // Get distinct condominiums for filter dropdowns
  app.get("/api/external-condominiums-for-filters", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      // Get only id and name for filter dropdowns
      const condominiums = await db.select({
        id: externalCondominiums.id,
        name: externalCondominiums.name,
      })
        .from(externalCondominiums)
        .where(eq(externalCondominiums.agencyId, agencyId))
        .orderBy(asc(externalCondominiums.name));
      
      res.json(condominiums);
    } catch (error: any) {
      console.error("Error fetching condominiums for filters:", error);
      handleGenericError(res, error);
    }
  });

  // Get distinct units for filter dropdowns
  app.get("/api/external-units-for-filters", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { condominiumId } = req.query;
      
      // If condominiumId is provided, verify it belongs to the user's agency
      if (condominiumId) {
        const condominium = await storage.getExternalCondominium(condominiumId as string);
        if (!condominium || condominium.agencyId !== agencyId) {
          return res.status(403).json({ message: "Condominium not found or access denied" });
        }
      }
      
      // Build query with optional condominium filter (already validated above)
      const whereConditions = condominiumId
        ? and(
            eq(externalUnits.agencyId, agencyId),
            eq(externalUnits.condominiumId, condominiumId as string)
          )
        : eq(externalUnits.agencyId, agencyId);
      
      // Get only id, unitNumber, and condominiumId for filter dropdowns
      const units = await db.select({
        id: externalUnits.id,
        unitNumber: externalUnits.unitNumber,
        condominiumId: externalUnits.condominiumId,
      })
        .from(externalUnits)
        .where(whereConditions)
        .orderBy(asc(externalUnits.unitNumber));
      
      res.json(units);
    } catch (error: any) {
      console.error("Error fetching units for filters:", error);
      handleGenericError(res, error);
    }
  });
  // GET /api/external/rentals/overview - Consolidated endpoint for Active Rentals section
  // Returns contracts with details, filter metadata, and statistics in ONE request
  app.get("/api/external/rentals/overview", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { status } = req.query;
      
      // Build conditions for contracts
      const contractConditions = [eq(externalRentalContracts.agencyId, agencyId)];
      if (status && status !== 'all') {
        contractConditions.push(eq(externalRentalContracts.status, status as any));
      }
      
      // Query 1: Get rental contracts with unit and condominium (single JOIN query)
      const contractsWithDetails = await db.select({
        contract: externalRentalContracts,
        unit: externalUnits,
        condominium: externalCondominiums,
      })
        .from(externalRentalContracts)
        .leftJoin(externalUnits, eq(externalRentalContracts.unitId, externalUnits.id))
        .leftJoin(externalCondominiums, eq(externalUnits.condominiumId, externalCondominiums.id))
        .where(and(...contractConditions))
        .orderBy(desc(externalRentalContracts.createdAt));
      
      // Query 2: Get filter metadata (condominiums for this agency)
      const condominiumsData = await db.select({
        id: externalCondominiums.id,
        name: externalCondominiums.name,
      })
        .from(externalCondominiums)
        .where(eq(externalCondominiums.agencyId, agencyId))
        .orderBy(asc(externalCondominiums.name));
      
      // Query 3: Get units for filters (grouped by condo)
      const unitsData = await db.select({
        id: externalUnits.id,
        unitNumber: externalUnits.unitNumber,
        condominiumId: externalUnits.condominiumId,
      })
        .from(externalUnits)
        .where(eq(externalUnits.agencyId, agencyId))
        .orderBy(asc(externalUnits.unitNumber));
      
      // Query 4: Get statistics from ALL contracts (not filtered)
      const allContractsForStats = await db.select({ status: externalRentalContracts.status })
        .from(externalRentalContracts)
        .where(eq(externalRentalContracts.agencyId, agencyId));
      
      const stats = {
        total: allContractsForStats.length,
        active: allContractsForStats.filter(c => c.status === 'active').length,
        completed: allContractsForStats.filter(c => c.status === 'completed').length,
        pending: allContractsForStats.filter(c => c.status === 'pending_validation').length,
      };
      
      // If no contracts, return early with empty data but include filters
      if (contractsWithDetails.length === 0) {
        return res.json({
          contracts: [],
          filters: {
            condominiums: condominiumsData,
            units: unitsData,
          },
          statistics: stats,
        });
      }
      
      // Query 5: Bulk fetch active schedules for all contracts
      const contractIds = contractsWithDetails.map(c => c.contract.id);
      const allSchedules = await db.select()
        .from(externalPaymentSchedules)
        .where(
          and(
            inArray(externalPaymentSchedules.contractId, contractIds),
            eq(externalPaymentSchedules.isActive, true)
          )
        );
      
      // Query 6: Bulk fetch next upcoming payment for all contracts
      const allNextPayments = await db.select()
        .from(externalPayments)
        .where(
          and(
            inArray(externalPayments.contractId, contractIds),
            eq(externalPayments.status, 'pending'),
            sql`${externalPayments.dueDate} >= CURRENT_DATE`
          )
        )
        .orderBy(asc(externalPayments.dueDate));
      
      // Group schedules by contract ID
      const schedulesByContract = allSchedules.reduce((acc, schedule) => {
        if (!acc[schedule.contractId]) {
          acc[schedule.contractId] = [];
        }
        acc[schedule.contractId].push(schedule);
        return acc;
      }, {} as Record<string, typeof allSchedules>);
      
      // Get first payment per contract ID
      const nextPaymentByContract = allNextPayments.reduce((acc, payment) => {
        if (!acc[payment.contractId]) {
          acc[payment.contractId] = payment;
        }
        return acc;
      }, {} as Record<string, typeof allNextPayments[0]>);
      
      // Combine contracts with their services and payment info
      const enhancedContracts = contractsWithDetails.map((item) => {
        const schedules = schedulesByContract[item.contract.id] || [];
        const nextPayment = nextPaymentByContract[item.contract.id];
        
        return {
          ...item,
          activeServices: schedules.map(s => ({
            serviceType: s.serviceType,
            amount: s.amount,
            currency: s.currency,
            dayOfMonth: s.dayOfMonth,
          })),
          nextPaymentDue: nextPayment?.dueDate || null,
          nextPaymentAmount: nextPayment?.amount || null,
          nextPaymentService: nextPayment?.serviceType || null,
        };
      });
      
      res.json({
        contracts: enhancedContracts,
        filters: {
          condominiums: condominiumsData,
          units: unitsData,
        },
        statistics: stats,
      });
    } catch (error: any) {
      console.error("Error fetching rentals overview:", error);
      handleGenericError(res, error);
    }
  });


  // External Rental Contracts Routes
  // Get all rental contracts for user's agency with unit and condominium info
  app.get("/api/external-rental-contracts", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      const { status, limit, offset } = req.query;
      const filters = status ? { status: status as string } : undefined;
      
      // Parse pagination parameters with sensible defaults
      const limitNum = limit ? parseInt(limit as string, 10) : 100;
      const offsetNum = offset ? parseInt(offset as string, 10) : 0;
      
      // Validate pagination parameters
      if (isNaN(limitNum) || limitNum < 1 || limitNum > 500) {
        return res.status(400).json({ message: "Invalid limit parameter (must be 1-500)" });
      }
      if (isNaN(offsetNum) || offsetNum < 0) {
        return res.status(400).json({ message: "Invalid offset parameter (must be >= 0)" });
      }
      
      // Get rental contracts with unit and condominium information using SQL joins
      const contractsWithDetails = await db.select({
        contract: externalRentalContracts,
        unit: externalUnits,
        condominium: externalCondominiums,
      })
        .from(externalRentalContracts)
        .leftJoin(externalUnits, eq(externalRentalContracts.unitId, externalUnits.id))
        .leftJoin(externalCondominiums, eq(externalUnits.condominiumId, externalCondominiums.id))
        .where(
          filters?.status 
            ? and(
                eq(externalRentalContracts.agencyId, agencyId),
                eq(externalRentalContracts.status, filters.status as any)
              )
            : eq(externalRentalContracts.agencyId, agencyId)
        )
        .orderBy(desc(externalRentalContracts.createdAt))
        .limit(limitNum)
        .offset(offsetNum);
      
      if (contractsWithDetails.length === 0) {
        return res.json([]);
      }
      
      // Bulk fetch: Get all active schedules for all contracts in ONE query
      const contractIds = contractsWithDetails.map(c => c.contract.id);
      const allSchedules = await db.select()
        .from(externalPaymentSchedules)
        .where(
          and(
            inArray(externalPaymentSchedules.contractId, contractIds),
            eq(externalPaymentSchedules.isActive, true)
          )
        );
      
      // Bulk fetch: Get next upcoming payment for all contracts in ONE query
      // Use a window function to get first payment per contract
      const allNextPayments = await db.select()
        .from(externalPayments)
        .where(
          and(
            inArray(externalPayments.contractId, contractIds),
            eq(externalPayments.status, 'pending'),
            sql`${externalPayments.dueDate} >= CURRENT_DATE`
          )
        )
        .orderBy(asc(externalPayments.dueDate));
      
      // Group schedules by contract ID
      const schedulesByContract = allSchedules.reduce((acc, schedule) => {
        if (!acc[schedule.contractId]) {
          acc[schedule.contractId] = [];
        }
        acc[schedule.contractId].push(schedule);
        return acc;
      }, {} as Record<string, typeof allSchedules>);
      
      // Get first payment per contract ID
      const nextPaymentByContract = allNextPayments.reduce((acc, payment) => {
        if (!acc[payment.contractId]) {
          acc[payment.contractId] = payment;
        }
        return acc;
      }, {} as Record<string, typeof allNextPayments[0]>);
      
      // Combine data in memory (no additional DB queries)
      const enhancedContracts = contractsWithDetails.map((item) => {
        const schedules = schedulesByContract[item.contract.id] || [];
        const nextPayment = nextPaymentByContract[item.contract.id];
        
        return {
          ...item,
          activeServices: schedules.map(s => ({
            serviceType: s.serviceType,
            amount: s.amount,
            currency: s.currency,
            dayOfMonth: s.dayOfMonth,
          })),
          nextPaymentDue: nextPayment?.dueDate || null,
          nextPaymentAmount: nextPayment?.amount || null,
          nextPaymentService: nextPayment?.serviceType || null,
        };
      });
      
      res.json(enhancedContracts);
    } catch (error: any) {
      console.error("Error fetching rental contracts:", error);
      handleGenericError(res, error);
    }
  });

  // Get individual rental contract by ID
  app.get("/api/external-rental-contracts/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify contract exists
      const existing = await storage.getExternalRentalContract(id);
      if (!existing) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      res.json(existing);
    } catch (error: any) {
      console.error("Error fetching rental contract:", error);
      handleGenericError(res, error);
    }
  });

  // Get rental contract overview with services and payment info
  app.get("/api/external-rental-contracts/:id/overview", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify contract exists
      const contract = await storage.getExternalRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Get unit and condominium info
      const unit = contract.unitId ? await storage.getExternalUnit(contract.unitId) : null;
      const condominium = unit?.condominiumId ? await storage.getExternalCondominium(unit.condominiumId) : null;
      
      // Get active payment schedules for this contract
      const schedules = await db.select()
        .from(externalPaymentSchedules)
        .where(
          and(
            eq(externalPaymentSchedules.contractId, id),
            eq(externalPaymentSchedules.isActive, true)
          )
        );
      
      // Get upcoming payments for this contract (next 30 days, pending only)
      const thirtyDaysFromNow = new Date();
      thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
      
      const upcomingPayments = await db.select()
        .from(externalPayments)
        .where(
          and(
            eq(externalPayments.contractId, id),
            eq(externalPayments.status, 'pending'),
            sql`${externalPayments.dueDate} <= ${thirtyDaysFromNow.toISOString().split('T')[0]}`
          )
        )
        .orderBy(asc(externalPayments.dueDate))
        .limit(10);
      
      // Group upcoming payments by service type with next due date
      const servicePaymentInfo = schedules.map(schedule => {
        const nextPayment = upcomingPayments.find(p => p.serviceType === schedule.serviceType);
        return {
          serviceType: schedule.serviceType,
          amount: schedule.amount,
          currency: schedule.currency,
          dayOfMonth: schedule.dayOfMonth,
          nextDueDate: nextPayment?.dueDate || null,
          paymentId: nextPayment?.id || null,
        };
      });
      
      res.json({
        contract,
        unit,
        condominium,
        services: servicePaymentInfo,
        upcomingPaymentsCount: upcomingPayments.length,
      });
    } catch (error: any) {
      console.error("Error fetching rental contract overview:", error);
      handleGenericError(res, error);
    }
  });
  
  app.get("/api/external-rental-contracts/by-unit/:unitId", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { unitId } = req.params;
      
      // Verify unit exists and get its agency
      const unit = await storage.getExternalUnit(unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      const contracts = await storage.getExternalRentalContractsByProperty(unitId);
      
      res.json(contracts);
    } catch (error: any) {
      console.error("Error fetching rental contracts:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/contracts - Create contract from completed rental forms (tenant + owner)
  app.post("/api/external/contracts", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { rentalFormGroupId } = req.body;
      
      if (!rentalFormGroupId) {
        return res.status(400).json({ message: "rentalFormGroupId is required" });
      }
      
      // Get agency ID from user
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User not associated with any agency" });
      }
      
      // Check if contract already exists for this group
      const existingContract = await db.select()
        .from(externalRentalContracts)
        .where(eq(externalRentalContracts.rentalFormGroupId, rentalFormGroupId))
        .limit(1);
      
      if (existingContract.length > 0) {
        return res.status(400).json({ 
          message: "Contract already exists for this rental form group",
          contractId: existingContract[0].id
        });
      }
      
      // Get both forms (tenant and owner) for this rental group
      const forms = await db.select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.rentalFormGroupId, rentalFormGroupId));
      
      if (forms.length < 2) {
        return res.status(400).json({ 
          message: "Both tenant and owner forms must exist for this group" 
        });
      }
      
      const tenantForm = forms.find((f: any) => f.recipient_type === 'tenant');
      const ownerForm = forms.find((f: any) => f.recipient_type === 'owner');
      
      if (!tenantForm || !ownerForm) {
        return res.status(400).json({ 
          message: "Both tenant and owner forms are required" 
        });
      }
      
      // Verify both forms are completed
      if (!tenantForm.is_used || !ownerForm.is_used) {
        return res.status(400).json({ 
          message: "Both tenant and owner forms must be completed before creating a contract" 
        });
      }
      
      // Get unit to verify it exists and get agency
      const unit = await storage.getExternalUnit(tenantForm.external_unit_id!);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify agency ownership via unit's agency
      if (unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Check if there's already an active contract for this unit
      const activeContractForUnit = await db.select()
        .from(externalRentalContracts)
        .where(
          and(
            eq(externalRentalContracts.unitId, tenantForm.external_unit_id!),
            eq(externalRentalContracts.agencyId, agencyId)
          )
        )
        .limit(1);
      
      if (activeContractForUnit.length > 0) {
        return res.status(400).json({ 
          message: "Ya existe un contrato activo para esta unidad",
          contractId: activeContractForUnit[0].id
        });
      }
      
      // Extract data from forms
      const tenantData = tenantForm.tenant_data as any;
      const ownerData = ownerForm.owner_data as any;
      
      if (!tenantData || !ownerData) {
        return res.status(400).json({ 
          message: "Form data is incomplete" 
        });
      }
      
      // Calculate lease dates from tenant data
      const startDate = new Date(tenantData.desiredMoveInDate || tenantData.preferredMoveInDate || Date.now());
      let leaseDurationMonths = 12; // default
      
      // Try to calculate from move in/out dates if available
      if (tenantData.desiredMoveOutDate && tenantData.desiredMoveInDate) {
        const moveIn = new Date(tenantData.desiredMoveInDate);
        const moveOut = new Date(tenantData.desiredMoveOutDate);
        const diffMonths = (moveOut.getFullYear() - moveIn.getFullYear()) * 12 + (moveOut.getMonth() - moveIn.getMonth());
        leaseDurationMonths = diffMonths > 0 ? diffMonths : 12;
      } else if (tenantData.leaseDuration) {
        leaseDurationMonths = parseInt(tenantData.leaseDuration) || 12;
      }
      
      const endDate = new Date(startDate);
      endDate.setMonth(endDate.getMonth() + leaseDurationMonths);
      
      // Extract monthly rent from tenant data (try multiple field names)
      const monthlyRent = tenantData.proposedMonthlyRent || tenantData.monthlyRent || tenantData.monthlyIncome || '0';
      
      // Create contract
      const contract = await storage.createExternalRentalContract({
        agencyId,
        unitId: tenantForm.external_unit_id!,
        rentalFormGroupId,
        tenantName: tenantData.fullName,
        tenantEmail: tenantData.email,
        tenantPhone: tenantData.whatsapp || tenantData.phone || tenantData.workPhone,
        monthlyRent: String(monthlyRent),
        currency: 'MXN',
        securityDeposit: String(tenantData.securityDeposit || monthlyRent || '0'),
        rentalPurpose: 'living',
        leaseDurationMonths,
        startDate,
        endDate,
        status: 'pending_validation',
        hasPet: tenantData.hasPets === 'yes' || tenantData.hasPets === true || tenantData.hasPets === 'Sí',
        petName: tenantData.petName,
        petPhotoUrl: tenantData.petPhoto || tenantData.petPhotoUrl,
        petDescription: tenantData.petDescription,
        createdBy: req.user.id,
      });
      
      await createAuditLog(
        req, 
        "create", 
        "external_rental_contract", 
        contract.id, 
        `Created contract from completed rental forms (group: ${rentalFormGroupId})`
      );
      
      res.status(201).json(contract);
    } catch (error: any) {
      console.error("Error creating contract from forms:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // GET /api/external/contracts/overview - Consolidated endpoint for all contract-related data (offers, forms, contracts)
  // Reduces multiple API calls to a single request for better performance
  app.get("/api/external/contracts/overview", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }
      
      // Fetch all data in parallel for maximum performance
      const [offers, rentalForms, contractsRaw] = await Promise.all([
        storage.getExternalOfferTokenSummariesByAgency(agencyId),
        storage.getExternalRentalFormTokenSummariesByAgency(agencyId),
        (async () => {
          // Get contracts with joined data
          const contracts = await db
            .select({
              contract: externalRentalContracts,
              unit: externalUnits,
              condominium: externalCondominiums,
            })
            .from(externalRentalContracts)
            .innerJoin(externalUnits, eq(externalRentalContracts.unitId, externalUnits.id))
            .leftJoin(externalCondominiums, eq(externalUnits.condominiumId, externalCondominiums.id))
            .where(eq(externalRentalContracts.agencyId, agencyId))
            .orderBy(desc(externalRentalContracts.createdAt));
          return contracts;
        })()
      ]);
      
      // Get dual form status for rental forms with linkedTokenId (smaller loop)
      const rentalFormsWithDual = await Promise.all(
        rentalForms.map(async (form: any) => {
          let dualFormStatus = null;
          if (form.rentalFormGroupId) {
            const companion = await db.query.tenantRentalFormTokens.findFirst({
              where: eq(tenantRentalFormTokens.id, form.rentalFormGroupId),
            });
            if (companion) {
              dualFormStatus = {
                hasDual: true,
                dualType: companion.recipientType,
                dualCompleted: companion.isUsed,
              };
            }
          }
          return { ...form, agencyId, dualFormStatus };
        })
      );
      
      res.json({
        offers,
        rentalForms: rentalFormsWithDual,
        contracts: contractsRaw,
        meta: {
          offersCount: offers.length,
          rentalFormsCount: rentalFormsWithDual.length,
          contractsCount: contractsRaw.length,
        }
      });
    } catch (error: any) {
      console.error("Error fetching contracts overview:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/contracts - Get all contracts for agency (only completed ones where both tenant AND owner submitted forms)
  app.get("/api/external/contracts", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User not associated with any agency" });
      }
      
      const { status, limit = '50', offset = '0' } = req.query;
      const limitNum = parseInt(limit as string, 10);
      const offsetNum = parseInt(offset as string, 10);
      
      // Subquery to check if both tenant and owner forms are completed
      // A form group is considered complete when:
      // - There is a tenant token with non-null tenant_data
      // - There is an owner token with non-null owner_data
      const completedFormsSubquery = db
        .select({
          rentalFormGroupId: tenantRentalFormTokens.rentalFormGroupId,
          tenantCompleted: sql<boolean>`bool_or(recipient_type = 'tenant' AND tenant_data IS NOT NULL)`.as('tenant_completed'),
          ownerCompleted: sql<boolean>`bool_or(recipient_type = 'owner' AND owner_data IS NOT NULL)`.as('owner_completed'),
        })
        .from(tenantRentalFormTokens)
        .where(isNotNull(tenantRentalFormTokens.rentalFormGroupId))
        .groupBy(tenantRentalFormTokens.rentalFormGroupId)
        .as('completed_forms');
      
      // Main query - get contracts with unit and form completion status
      let whereConditions = [
        eq(externalRentalContracts.agencyId, agencyId),
        // Only show contracts where both forms are completed
        sql`${completedFormsSubquery.tenantCompleted} = true`,
        sql`${completedFormsSubquery.ownerCompleted} = true`,
      ];
      
      // ⚠️ CRITICAL: SOFT DELETE PATTERN - DO NOT FILTER BY cancelledAt ⚠️
      // 
      // Cancelled contracts MUST remain visible in all status-filtered views
      // with a "Cancelado" badge displayed alongside their status badge.
      //
      // Design pattern:
      // - cancelledAt field: Orthogonal flag indicating cancellation (timestamp or null)
      // - status field: Maintains original value (pending_validation, active, etc.)
      // - Frontend: Shows BOTH status badge AND "Cancelado" badge when cancelledAt is set
      //
      // ❌ NEVER add: whereConditions.push(isNull(externalRentalContracts.cancelledAt))
      // ❌ NEVER filter out cancelled contracts from any view
      // ✅ ALWAYS show all contracts regardless of cancelledAt value
      //
      // This ensures:
      // 1. Cancelled contracts remain visible in their original status category
      // 2. Users can track what was cancelled and when
      // 3. Audit trail is preserved
      // 4. No data is lost or hidden
      
      // Filter by status if provided
      // Note: Cancelled contracts retain their original status, so they will appear
      // in the filtered results with a "Cancelado" badge
      if (status) {
        whereConditions.push(eq(externalRentalContracts.status, status as any));
      }
      
      const contracts = await db.select({
        contract: externalRentalContracts,
        unit: externalUnits,
        condominium: externalCondominiums,
      })
        .from(externalRentalContracts)
        .innerJoin(completedFormsSubquery, eq(externalRentalContracts.rentalFormGroupId, completedFormsSubquery.rentalFormGroupId))
        .leftJoin(externalUnits, eq(externalRentalContracts.unitId, externalUnits.id))
        .leftJoin(externalCondominiums, eq(externalUnits.condominiumId, externalCondominiums.id))
        .where(and(...whereConditions))
        .orderBy(desc(externalRentalContracts.createdAt))
        .limit(limitNum)
        .offset(offsetNum);
      
      res.json(contracts);
    } catch (error: any) {
      console.error("Error fetching contracts:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/contracts/:id - Get contract details with forms
  app.get("/api/external/contracts/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Get contract
      const contract = await storage.getExternalRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Get unit details
      const unit = await storage.getExternalUnit(contract.unitId);
      
      // Get forms if rentalFormGroupId exists
      let tenantForm = null;
      let ownerForm = null;
      
      if (contract.rentalFormGroupId) {
        const forms = await db.select()
          .from(tenantRentalFormTokens)
          .where(eq(tenantRentalFormTokens.rentalFormGroupId, contract.rentalFormGroupId));
        
        const rawTenantForm = forms.find((f: any) => f.recipientType === 'tenant');
        const rawOwnerForm = forms.find((f: any) => f.recipientType === 'owner');
        
        // Return data with proper structure - Drizzle returns camelCase already
        tenantForm = rawTenantForm ? {
          ...rawTenantForm,
          // Ensure tenantData and ownerData are exposed properly
          tenantData: rawTenantForm.tenantData,
          ownerData: rawTenantForm.ownerData,
        } : null;
        
        ownerForm = rawOwnerForm ? {
          ...rawOwnerForm,
          // Ensure tenantData and ownerData are exposed properly
          tenantData: rawOwnerForm.tenantData,
          ownerData: rawOwnerForm.ownerData,
        } : null;
      }
      
      res.json({
        contract,
        unit,
        tenantForm,
        ownerForm,
      });
    } catch (error: any) {
      console.error("Error fetching contract details:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/contracts/:id/validate-documents - Validate tenant or owner documents
  app.patch("/api/external/contracts/:id/validate-documents", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { documentType } = req.body; // 'tenant' or 'owner'
      
      if (!['tenant', 'owner'].includes(documentType)) {
        return res.status(400).json({ message: "documentType must be 'tenant' or 'owner'" });
      }
      
      // Get contract
      const contract = await storage.getExternalRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Update validation status
      const updateData: any = {};
      const now = new Date();
      
      if (documentType === 'tenant') {
        updateData.tenantDocsValidated = true;
        updateData.tenantDocsValidatedBy = req.user.id;
        updateData.tenantDocsValidatedAt = now;
      } else {
        updateData.ownerDocsValidated = true;
        updateData.ownerDocsValidatedBy = req.user.id;
        updateData.ownerDocsValidatedAt = now;
      }
      
      // Check if both are now validated and update status
      const bothValidated = 
        (documentType === 'tenant' && contract.ownerDocsValidated) ||
        (documentType === 'owner' && contract.tenantDocsValidated);
      
      if (bothValidated) {
        updateData.status = 'documents_validated';
      }
      
      const updatedContract = await storage.updateExternalRentalContract(id, updateData);
      
      await createAuditLog(
        req, 
        "update", 
        "external_rental_contract", 
        id, 
        `Validated ${documentType} documents`
      );
      
      res.json(updatedContract);
    } catch (error: any) {
      console.error("Error validating documents:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/contracts/:id/upload-contract - Upload elaborated contract file
  app.patch("/api/external/contracts/:id/upload-contract", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { contractUrl } = req.body;
      
      if (!contractUrl) {
        return res.status(400).json({ message: "contractUrl is required" });
      }
      
      // Get contract
      const contract = await storage.getExternalRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Update contract with elaborated contract URL
      const updatedContract = await storage.updateExternalRentalContract(id, {
        elaboratedContractUrl: contractUrl,
        elaboratedContractUploadedBy: req.user.id,
        elaboratedContractUploadedAt: new Date(),
        status: 'contract_uploaded',
      });
      
      await createAuditLog(
        req, 
        "update", 
        "external_rental_contract", 
        id, 
        `Uploaded elaborated contract`
      );
      
      res.json(updatedContract);
    } catch (error: any) {
      console.error("Error uploading contract:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/contracts/:id/update-tenant-data - Update tenant form data
  app.patch("/api/external/contracts/:id/update-tenant-data", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { tenantData } = req.body;
      
      if (!tenantData) {
        return res.status(400).json({ message: "tenantData is required" });
      }
      
      // Get contract
      const contract = await storage.getExternalRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Get tenant form
      if (!contract.rentalFormGroupId) {
        return res.status(400).json({ message: "Contract has no associated rental forms" });
      }
      
      const forms = await db.select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.rentalFormGroupId, contract.rentalFormGroupId));
      
      const tenantForm = forms.find((f: any) => f.recipient_type === 'tenant');
      if (!tenantForm) {
        return res.status(404).json({ message: "Tenant form not found" });
      }
      
      // Update tenant form data
      await db.update(tenantRentalFormTokens)
        .set({ 
          tenant_data: tenantData,
          updated_at: new Date()
        })
        .where(eq(tenantRentalFormTokens.id, tenantForm.id));
      
      // Also update contract fields that come from tenant data
      const updateData: any = {};
      if (tenantData.fullName) updateData.tenantName = tenantData.fullName;
      if (tenantData.email) updateData.tenantEmail = tenantData.email;
      if (tenantData.whatsapp || tenantData.phone) updateData.tenantPhone = tenantData.whatsapp || tenantData.phone;
      
      if (Object.keys(updateData).length > 0) {
        await storage.updateExternalRentalContract(id, updateData);
      }
      
      await createAuditLog(
        req, 
        "update", 
        "external_rental_contract", 
        id, 
        `Updated tenant data`
      );
      
      res.json({ success: true, message: "Tenant data updated" });
    } catch (error: any) {
      console.error("Error updating tenant data:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/contracts/:id/update-owner-data - Update owner form data
  app.patch("/api/external/contracts/:id/update-owner-data", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { ownerData } = req.body;
      
      if (!ownerData) {
        return res.status(400).json({ message: "ownerData is required" });
      }
      
      // Get contract
      const contract = await storage.getExternalRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Get owner form
      if (!contract.rentalFormGroupId) {
        return res.status(400).json({ message: "Contract has no associated rental forms" });
      }
      
      const forms = await db.select()
        .from(tenantRentalFormTokens)
        .where(eq(tenantRentalFormTokens.rentalFormGroupId, contract.rentalFormGroupId));
      
      const ownerForm = forms.find((f: any) => f.recipient_type === 'owner');
      if (!ownerForm) {
        return res.status(404).json({ message: "Owner form not found" });
      }
      
      // Update owner form data
      await db.update(tenantRentalFormTokens)
        .set({ 
          owner_data: ownerData,
          updated_at: new Date()
        })
        .where(eq(tenantRentalFormTokens.id, ownerForm.id));
      
      await createAuditLog(
        req, 
        "update", 
        "external_rental_contract", 
        id, 
        `Updated owner data`
      );
      
      res.json({ success: true, message: "Owner data updated" });
    } catch (error: any) {
      console.error("Error updating owner data:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/contracts/:id/cancel - Cancel contract (soft delete)
  app.patch("/api/external/contracts/:id/cancel", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Get contract
      const contract = await storage.getExternalRentalContract(id);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Check if already cancelled
      if (contract.cancelledAt) {
        return res.status(400).json({ message: "Contract is already cancelled" });
      }
      
      // Cancel contract (soft delete)
      // Note: We do NOT update the status - cancelled contracts retain their original status
      // and appear with a "Cancelado" badge alongside their status badge
      await storage.updateExternalRentalContract(id, {
        cancelledAt: new Date(),
        cancelledBy: req.user.id,
      });
      
      await createAuditLog(
        req, 
        "update", 
        "external_rental_contract", 
        id, 
        `Cancelled contract`
      );
      
      res.json({ success: true, message: "Contract cancelled successfully" });
    } catch (error: any) {
      console.error("Error cancelling contract:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-rental-contracts", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      // Try parsing as extended schema first (with services), fall back to basic schema
      let contractData;
      let additionalServices: any[] = [];
      
      try {
        const validatedRequest = createRentalContractWithServicesSchema.parse(req.body);
        contractData = validatedRequest.contract;
        additionalServices = validatedRequest.additionalServices || [];
      } catch (e) {
        // Fall back to basic schema for backward compatibility
        contractData = insertExternalRentalContractSchema.parse(req.body);
      }
      
      // Verify unit exists and get its agency
      const unit = await storage.getExternalUnit(contractData.unitId);
      if (!unit) {
        return res.status(404).json({ message: "Unit not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, unit.agencyId);
      if (!hasAccess) return;
      
      // Check if there's already an active rental contract for this unit
      const existingActiveContract = await db.select()
        .from(externalRentalContracts)
        .where(
          and(
            eq(externalRentalContracts.unitId, contractData.unitId),
            eq(externalRentalContracts.status, 'active')
          )
        )
        .limit(1);
      
      if (existingActiveContract.length > 0) {
        return res.status(400).json({ 
          message: "Esta unidad ya tiene un contrato de renta activo. Solo puede haber una renta activa por unidad a la vez." 
        });
      }
      
      // Use transaction to atomically create contract + schedules + payments
      const result = await db.transaction(async (tx) => {
        // 1. Create the contract
        const contract = await storage.createExternalRentalContract({
          ...contractData,
          agencyId: unit.agencyId,
          createdBy: req.user.id,
        });
        
        // 2. Prepare all payment schedules (rent + additional services)
        const startDate = new Date(contractData.startDate);
        const defaultDayOfMonth = startDate.getDate();
        
        const allSchedules = [
          // Always create rent schedule
          {
            serviceType: 'rent' as const,
            amount: contractData.monthlyRent,
            currency: contractData.currency,
            dayOfMonth: defaultDayOfMonth,
            sendReminderDaysBefore: 3,
            notes: undefined,
          },
          // Add additional services
          ...additionalServices.map(service => ({
            serviceType: service.serviceType as any,
            amount: String(service.amount), // Convert number to string for decimal type
            currency: service.currency || contractData.currency,
            dayOfMonth: service.dayOfMonth || defaultDayOfMonth,
            sendReminderDaysBefore: service.sendReminderDaysBefore ?? 3,
            notes: service.notes,
          }))
        ];
        
        // 3. Create all schedules and collect first payments
        const createdSchedules = [];
        for (const scheduleData of allSchedules) {
          const schedule = await storage.createExternalPaymentSchedule({
            agencyId: unit.agencyId,
            contractId: contract.id,
            ...scheduleData,
            isActive: true,
            createdBy: req.user.id,
          });
          createdSchedules.push(schedule);
          
          // 4. Generate first payment for each schedule (next month from start date)
          const targetMonth = startDate.getMonth() + 1;
          const targetYear = targetMonth > 11 
            ? startDate.getFullYear() + 1 
            : startDate.getFullYear();
          const adjustedMonth = targetMonth > 11 ? 0 : targetMonth;
          
          const lastDayOfMonth = new Date(targetYear, adjustedMonth + 1, 0).getDate();
          const clampedDay = Math.min(scheduleData.dayOfMonth, lastDayOfMonth);
          const firstPaymentDue = new Date(Date.UTC(targetYear, adjustedMonth, clampedDay, 0, 0, 0, 0));
          
          await tx.insert(externalPayments).values({
            id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
            agencyId: unit.agencyId,
            contractId: contract.id,
            scheduleId: schedule.id,
            serviceType: scheduleData.serviceType,
            amount: scheduleData.amount,
            currency: scheduleData.currency,
            dueDate: firstPaymentDue,
            status: 'pending',
            createdBy: req.user.id,
          });
        }
        
        return { contract, schedules: createdSchedules };
      });
      
      const serviceCount = additionalServices.length;
      await createAuditLog(
        req, 
        "create", 
        "external_rental_contract", 
        result.contract.id, 
        `Created rental contract with ${result.schedules.length} payment schedule(s) (rent + ${serviceCount} additional service(s))`
      );
      
      res.status(201).json({
        contract: result.contract,
        schedules: result.schedules,
      });
    } catch (error: any) {
      console.error("Error creating rental contract:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-rental-contracts/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify contract exists
      const existing = await storage.getExternalRentalContract(id);
      if (!existing) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      const validatedData = updateExternalRentalContractSchema.parse(req.body);
      
      // Prevent agencyId modification
      const updateData = { ...validatedData };
      delete (updateData as any).agencyId;
      delete (updateData as any).createdBy;
      
      const contract = await storage.updateExternalRentalContract(id, updateData);
      
      await createAuditLog(req, "update", "external_rental_contract", id, "Updated external rental contract");
      res.json(contract);
    } catch (error: any) {
      console.error("Error updating rental contract:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-rental-contracts/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalRentalContract(id);
      
      if (!existing) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      await storage.deleteExternalRentalContract(id);
      
      await createAuditLog(req, "delete", "external_rental_contract", id, "Deleted external rental contract");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting rental contract:", error);
      handleGenericError(res, error);
    }
  });

  // Cancel active rental contract
  app.patch("/api/external-rental-contracts/:id/cancel", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify contract exists
      const existing = await storage.getExternalRentalContract(id);
      if (!existing) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;
      
      // Can only cancel active contracts
      if (existing.status !== 'active') {
        return res.status(400).json({ 
          message: "Only active contracts can be cancelled" 
        });
      }
      
      // Update contract status to completed
      await storage.updateExternalRentalContract(id, { status: 'completed' });
      
      // Delete all pending future payments for this contract
      await db.delete(externalPayments)
        .where(
          and(
            eq(externalPayments.contractId, id),
            eq(externalPayments.status, 'pending'),
            sql`${externalPayments.dueDate} > CURRENT_DATE`
          )
        );
      
      await createAuditLog(req, "update", "external_rental_contract", id, "Cancelled rental contract and deleted future pending payments");
      res.json({ message: "Contract cancelled successfully" });
    } catch (error: any) {
      console.error("Error cancelling rental contract:", error);
      handleGenericError(res, error);
    }
  });

  // Rental Notes Routes - Notes and incidents for rental contracts
  // Get all notes for a rental contract
  app.get("/api/external-rental-contracts/:id/notes", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id: contractId } = req.params;
      const { isArchived, noteType } = req.query;
      
      // Verify contract exists and access
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      const filters: any = {};
      if (isArchived !== undefined) filters.isArchived = isArchived === 'true';
      if (noteType) filters.noteType = noteType;
      
      const notes = await storage.getExternalRentalNotesByContract(contractId, filters);
      res.json(notes);
    } catch (error: any) {
      console.error("Error fetching rental notes:", error);
      handleGenericError(res, error);
    }
  });

  // Create a new note for a rental contract
  app.post("/api/external-rental-contracts/:id/notes", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id: contractId } = req.params;
      
      // Verify contract exists
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      const noteData = insertExternalRentalNoteSchema.parse({
        ...req.body,
        agencyId: contract.agencyId,
        contractId,
        createdBy: req.user.id,
      });
      
      const note = await storage.createExternalRentalNote(noteData);
      
      await createAuditLog(req, "create", "external_rental_note", note.id, `Created ${note.noteType} note for rental contract`);
      res.status(201).json(note);
    } catch (error: any) {
      console.error("Error creating rental note:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // Archive/unarchive a rental note
  app.patch("/api/external-rental-notes/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Verify note exists
      const note = await storage.getExternalRentalNote(id);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, note.agencyId);
      if (!hasAccess) return;
      
      const updates = updateExternalRentalNoteSchema.parse(req.body);
      const updatedNote = await storage.updateExternalRentalNote(id, updates);
      
      await createAuditLog(req, "update", "external_rental_note", id, `Updated rental note (archived: ${updatedNote.isArchived})`);
      res.json(updatedNote);
    } catch (error: any) {
      console.error("Error updating rental note:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // Get maintenance tickets for a rental contract
  app.get("/api/external-rental-contracts/:id/maintenance-tickets", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id: contractId } = req.params;
      const { status } = req.query;
      
      // Verify contract exists
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      const filters = status ? { status: status as string } : undefined;
      const tickets = await storage.getExternalMaintenanceTicketsByContract(contractId, filters);
      
      res.json(tickets);
    } catch (error: any) {
      console.error("Error fetching maintenance tickets for contract:", error);
      handleGenericError(res, error);
    }
  });

  // Payment Schedules CRUD for rental contracts
  app.post("/api/external-rental-contracts/:id/schedules", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id: contractId } = req.params;
      
      // Verify contract exists
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Validate request body
      const validatedData = insertExternalPaymentScheduleSchema.parse(req.body);
      
      // Create schedule
      const schedule = await storage.createExternalPaymentSchedule({
        ...validatedData,
        agencyId: contract.agencyId,
        contractId,
        createdBy: req.user.id,
      });
      
      await createAuditLog(req, "create", "external_payment_schedule", schedule.id, `Created payment schedule for service: ${schedule.serviceType}`);
      res.status(201).json(schedule);
    } catch (error: any) {
      console.error("Error creating payment schedule:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-rental-contracts/:id/schedules/:scheduleId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id: contractId, scheduleId } = req.params;
      
      // Verify contract exists
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Get schedule to verify it belongs to this contract
      const existingSchedule = await db.select()
        .from(externalPaymentSchedules)
        .where(eq(externalPaymentSchedules.id, scheduleId))
        .limit(1);
      
      if (existingSchedule.length === 0) {
        return res.status(404).json({ message: "Payment schedule not found" });
      }
      
      if (existingSchedule[0].contractId !== contractId) {
        return res.status(400).json({ message: "Schedule does not belong to this contract" });
      }
      
      // Validate request body
      const validatedData = updateExternalPaymentScheduleSchema.parse(req.body);
      
      // Update schedule
      const schedule = await storage.updateExternalPaymentSchedule(scheduleId, validatedData);
      
      await createAuditLog(req, "update", "external_payment_schedule", scheduleId, `Updated payment schedule for service: ${schedule.serviceType}`);
      res.json(schedule);
    } catch (error: any) {
      console.error("Error updating payment schedule:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-rental-contracts/:id/schedules/:scheduleId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id: contractId, scheduleId } = req.params;
      
      // Verify contract exists
      const contract = await storage.getExternalRentalContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Verify ownership
      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;
      
      // Get schedule to verify it belongs to this contract
      const existingSchedule = await db.select()
        .from(externalPaymentSchedules)
        .where(eq(externalPaymentSchedules.id, scheduleId))
        .limit(1);
      
      if (existingSchedule.length === 0) {
        return res.status(404).json({ message: "Payment schedule not found" });
      }
      
      if (existingSchedule[0].contractId !== contractId) {
        return res.status(400).json({ message: "Schedule does not belong to this contract" });
      }
      
      // Delete schedule
      await storage.deleteExternalPaymentSchedule(scheduleId);
      
      await createAuditLog(req, "delete", "external_payment_schedule", scheduleId, `Deleted payment schedule for service: ${existingSchedule[0].serviceType}`);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting payment schedule:", error);
      handleGenericError(res, error);
    }
  });

  // External Rental Tenants Routes (Additional tenants for contracts)
  app.get("/api/external-rental-tenants", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { contractId } = req.query;
      if (!contractId) {
        return res.status(400).json({ message: "contractId query parameter is required" });
      }

      // Verify contract exists and user has access
      const contract = await storage.getExternalRentalContract(contractId as string);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;

      const tenants = await db.query.externalRentalTenants.findMany({
        where: eq(externalRentalTenants.contractId, contractId as string),
        orderBy: [externalRentalTenants.createdAt],
      });

      res.json(tenants);
    } catch (error: any) {
      console.error("Error fetching rental tenants:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external-rental-tenants", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const data = insertExternalRentalTenantSchema.parse(req.body);

      // Verify contract exists and user has access
      const contract = await storage.getExternalRentalContract(data.contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;

      const [tenant] = await db.insert(externalRentalTenants)
        .values({
          ...data,
          createdBy: req.user.id,
        })
        .returning();

      await createAuditLog(req, "create", "external_rental_tenant", tenant.id, `Added tenant: ${tenant.fullName}`);
      res.status(201).json(tenant);
    } catch (error: any) {
      console.error("Error creating rental tenant:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external-rental-tenants/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;

      // Get existing tenant
      const [existing] = await db.select()
        .from(externalRentalTenants)
        .where(eq(externalRentalTenants.id, id))
        .limit(1);

      if (!existing) {
        return res.status(404).json({ message: "Tenant not found" });
      }

      // Verify contract ownership
      const contract = await storage.getExternalRentalContract(existing.contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;

      const updates = insertExternalRentalTenantSchema.partial().parse(req.body);

      const [updated] = await db.update(externalRentalTenants)
        .set({
          ...updates,
          updatedAt: new Date(),
        })
        .where(eq(externalRentalTenants.id, id))
        .returning();

      await createAuditLog(req, "update", "external_rental_tenant", id, `Updated tenant: ${updated.fullName}`);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating rental tenant:", error);
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external-rental-tenants/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;

      // Get existing tenant
      const [existing] = await db.select()
        .from(externalRentalTenants)
        .where(eq(externalRentalTenants.id, id))
        .limit(1);

      if (!existing) {
        return res.status(404).json({ message: "Tenant not found" });
      }

      // Verify contract ownership
      const contract = await storage.getExternalRentalContract(existing.contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, contract.agencyId);
      if (!hasAccess) return;

      await db.delete(externalRentalTenants)
        .where(eq(externalRentalTenants.id, id));

      await createAuditLog(req, "delete", "external_rental_tenant", id, `Deleted tenant: ${existing.fullName}`);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting rental tenant:", error);
      handleGenericError(res, error);
    }
  });

  // External Agency - Owners Routes
  app.get("/api/external/owners", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Get all units for this agency
      const units = await db.query.externalUnits.findMany({
        where: eq(externalUnits.agencyId, agencyId),
        with: {
          condominium: true,
        },
      });

      // Get all owners for these units
      const owners = await db.query.externalUnitOwners.findMany({
        where: inArray(
          externalUnitOwners.unitId,
          units.map((u) => u.id)
        ),
      });

      // Combine owners with unit info
      const ownersWithUnits = owners.map((owner) => {
        const unit = units.find((u) => u.id === owner.unitId);
        return {
          ...owner,
          unit: unit
            ? {
                id: unit.id,
                unitNumber: unit.unitNumber,
                condominium: {
                  id: unit.condominium.id,
                  name: unit.condominium.name,
                },
              }
            : undefined,
        };
      });

      res.json(ownersWithUnits);
    } catch (error: any) {
      console.error("Error fetching owners:", error);
      handleGenericError(res, error);
    }
  });

  // External Agency - Owner Charges Routes
  app.get("/api/external/owner-charges", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const charges = await db.query.externalOwnerCharges.findMany({
        where: eq(externalOwnerCharges.agencyId, agencyId),
        orderBy: desc(externalOwnerCharges.createdAt),
      });

      res.json(charges);
    } catch (error: any) {
      console.error("Error fetching charges:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external/owner-charges", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const chargeData = insertExternalOwnerChargeSchema.parse(req.body);

      // SECURITY: Verify owner and unit belong to the user's agency
      const [owner] = await db
        .select({ unitId: externalUnitOwners.unitId })
        .from(externalUnitOwners)
        .where(eq(externalUnitOwners.id, chargeData.ownerId))
        .limit(1);

      if (!owner) {
        return res.status(404).json({ message: "Owner not found" });
      }

      // Verify unit belongs to user's agency
      const [unit] = await db
        .select({ agencyId: externalUnits.agencyId })
        .from(externalUnits)
        .where(eq(externalUnits.id, chargeData.unitId))
        .limit(1);

      if (!unit || unit.agencyId !== agencyId) {
        return res.status(403).json({ message: "Forbidden: Cannot create charges for other agencies" });
      }

      const [charge] = await db
        .insert(externalOwnerCharges)
        .values({
          ...chargeData,
          agencyId,
          createdBy: req.user?.id || req.session?.adminUser?.id,
        })
        .returning();

      await createAuditLog(req, "create", "external_owner_charge", charge.id, "Created owner charge");
      res.json(charge);
    } catch (error: any) {
      console.error("Error creating charge:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // External Agency - Owner Notifications Routes

  // External Agency - Agency Notifications Routes (visible in agency config)
  app.get("/api/external/notifications", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const { unreadOnly, limit = "50" } = req.query;
      
      const conditions = [eq(externalNotifications.agencyId, agencyId)];
      if (unreadOnly === "true") {
        conditions.push(eq(externalNotifications.isRead, false));
      }

      const notifications = await db.query.externalNotifications.findMany({
        where: and(...conditions),
        orderBy: [desc(externalNotifications.createdAt)],
        limit: parseInt(limit as string) || 50,
      });

      res.json(notifications);
    } catch (error: any) {
      console.error("Error fetching agency notifications:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external/notifications/count", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const [result] = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(externalNotifications)
        .where(and(
          eq(externalNotifications.agencyId, agencyId),
          eq(externalNotifications.isRead, false)
        ));

      res.json({ unreadCount: result?.count || 0 });
    } catch (error: any) {
      console.error("Error fetching notification count:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external/notifications/:id/read", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const { id } = req.params;

      const [notification] = await db
        .select()
        .from(externalNotifications)
        .where(eq(externalNotifications.id, id))
        .limit(1);

      if (!notification) {
        return res.status(404).json({ message: "Notification not found" });
      }

      if (notification.agencyId !== agencyId) {
        return res.status(403).json({ message: "Forbidden" });
      }

      const [updated] = await db
        .update(externalNotifications)
        .set({ isRead: true, readAt: new Date() })
        .where(eq(externalNotifications.id, id))
        .returning();

      res.json(updated);
    } catch (error: any) {
      console.error("Error marking notification as read:", error);
      handleGenericError(res, error);
    }
  });

  app.patch("/api/external/notifications/mark-all-read", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      await db
        .update(externalNotifications)
        .set({ isRead: true, readAt: new Date() })
        .where(and(
          eq(externalNotifications.agencyId, agencyId),
          eq(externalNotifications.isRead, false)
        ));

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error marking all notifications as read:", error);
      handleGenericError(res, error);
    }
  });

  // External Agency Chatbot - AI assistant with property search and appointment scheduling
  app.post("/api/external/chatbot/message", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const { message, conversationHistory, clientInfo } = req.body;

      if (!message || typeof message !== 'string') {
        return res.status(400).json({ message: "Message is required" });
      }

      const responseText = await processExternalChatbotMessage({
        agencyId,
        message,
        conversationHistory,
        clientInfo
      });

      res.json({
        message: responseText,
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      console.error("Error in external chatbot:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external/owner-notifications", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const notifications = await db.query.externalOwnerNotifications.findMany({
        where: eq(externalOwnerNotifications.agencyId, agencyId),
        orderBy: desc(externalOwnerNotifications.createdAt),
      });

      res.json(notifications);
    } catch (error: any) {
      console.error("Error fetching notifications:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external/owner-notifications", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const notificationData = insertExternalOwnerNotificationSchema.parse(req.body);

      // If no specific owner but condominium is specified, send to all owners in that condominium
      if (!notificationData.ownerId && notificationData.condominiumId) {
        // SECURITY: Verify condominium belongs to user's agency
        const [condo] = await db
          .select({ agencyId: externalCondominiums.agencyId })
          .from(externalCondominiums)
          .where(eq(externalCondominiums.id, notificationData.condominiumId))
          .limit(1);

        if (!condo || condo.agencyId !== agencyId) {
          return res.status(403).json({ message: "Forbidden: Cannot send notifications for other agencies" });
        }

        const units = await db.query.externalUnits.findMany({
          where: and(
            eq(externalUnits.agencyId, agencyId),
            eq(externalUnits.condominiumId, notificationData.condominiumId)
          ),
        });

        const owners = await db.query.externalUnitOwners.findMany({
          where: inArray(
            externalUnitOwners.unitId,
            units.map((u) => u.id)
          ),
        });

        // Create notification for each owner
        const notifications = await Promise.all(
          owners.map((owner) =>
            db
              .insert(externalOwnerNotifications)
              .values({
                ...notificationData,
                agencyId,
                ownerId: owner.id,
                unitId: owner.unitId,
                createdBy: req.user?.id || req.session?.adminUser?.id,
              })
              .returning()
          )
        );

        await createAuditLog(
          req,
          "create",
          "external_owner_notification",
          "bulk",
          `Created ${notifications.length} notifications`
        );

        return res.json({ count: notifications.length, notifications: notifications.flat() });
      }

      // Single notification
      // SECURITY: Verify owner/unit belong to user's agency if specified
      if (notificationData.ownerId) {
        const [owner] = await db
          .select({ unitId: externalUnitOwners.unitId })
          .from(externalUnitOwners)
          .where(eq(externalUnitOwners.id, notificationData.ownerId))
          .limit(1);

        if (!owner) {
          return res.status(404).json({ message: "Owner not found" });
        }

        // Verify owner's unit belongs to user's agency
        const [unit] = await db
          .select({ agencyId: externalUnits.agencyId })
          .from(externalUnits)
          .where(eq(externalUnits.id, owner.unitId))
          .limit(1);

        if (!unit || unit.agencyId !== agencyId) {
          return res.status(403).json({ message: "Forbidden: Cannot send notifications for other agencies" });
        }
      }

      const [notification] = await db
        .insert(externalOwnerNotifications)
        .values({
          ...notificationData,
          agencyId,
          createdBy: req.user?.id || req.session?.adminUser?.id,
        })
        .returning();

      await createAuditLog(req, "create", "external_owner_notification", notification.id, "Created owner notification");
      res.json(notification);
    } catch (error: any) {
      console.error("Error creating notification:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // External Agency - Maintenance Worker Routes
  app.get("/api/external/maintenance-workers", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // Get all maintenance workers for this agency
      const workers = await db
        .select({
          id: users.id,
          email: users.email,
          firstName: users.firstName,
          lastName: users.lastName,
          phone: users.phone,
          maintenanceSpecialty: users.maintenanceSpecialty,
          isSuspended: users.isSuspended,
        })
        .from(users)
        .where(and(
          eq(users.role, "external_agency_maintenance"),
          eq(users.externalAgencyId, agencyId)
        ))
        .orderBy(users.firstName);

      res.json(workers);
    } catch (error: any) {
      console.error("Error fetching maintenance workers:", error);
      handleGenericError(res, error);
    }
  });

  app.get("/api/external/maintenance-worker-assignments", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const assignments = await db.query.externalWorkerAssignments.findMany({
        where: eq(externalWorkerAssignments.agencyId, agencyId),
        orderBy: desc(externalWorkerAssignments.createdAt),
      });

      res.json(assignments);
    } catch (error: any) {
      console.error("Error fetching worker assignments:", error);
      handleGenericError(res, error);
    }
  });

  app.post("/api/external/maintenance-worker-assignments", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      const assignmentData = insertExternalWorkerAssignmentSchema.parse(req.body);

      // SECURITY: Verify worker belongs to user's agency
      const [worker] = await db
        .select({ assignedToUser: users.assignedToUser })
        .from(users)
        .where(and(
          eq(users.id, assignmentData.userId),
          eq(users.role, "external_agency_maintenance")
        ))
        .limit(1);

      if (!worker || worker.assignedToUser !== agencyId) {
        return res.status(403).json({ message: "Forbidden: Worker does not belong to your agency" });
      }

      // SECURITY: If condominium is specified, verify it belongs to user's agency
      if (assignmentData.condominiumId) {
        const [condo] = await db
          .select({ agencyId: externalCondominiums.agencyId })
          .from(externalCondominiums)
          .where(eq(externalCondominiums.id, assignmentData.condominiumId))
          .limit(1);

        if (!condo || condo.agencyId !== agencyId) {
          return res.status(403).json({ message: "Forbidden: Condominium does not belong to your agency" });
        }
      }

      // SECURITY: If unit is specified, verify it belongs to user's agency
      if (assignmentData.unitId) {
        const [unit] = await db
          .select({ agencyId: externalUnits.agencyId })
          .from(externalUnits)
          .where(eq(externalUnits.id, assignmentData.unitId))
          .limit(1);

        if (!unit || unit.agencyId !== agencyId) {
          return res.status(403).json({ message: "Forbidden: Unit does not belong to your agency" });
        }
      }

      const [assignment] = await db
        .insert(externalWorkerAssignments)
        .values({
          ...assignmentData,
          agencyId,
        })
        .returning();

      await createAuditLog(req, "create", "external_worker_assignment", assignment.id, "Created worker assignment");
      res.json(assignment);
    } catch (error: any) {
      console.error("Error creating worker assignment:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  app.delete("/api/external/maintenance-worker-assignments/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(400).json({ message: "No agency assigned to user" });
      }

      // SECURITY: Verify assignment belongs to user's agency
      const [assignment] = await db
        .select({ agencyId: externalWorkerAssignments.agencyId })
        .from(externalWorkerAssignments)
        .where(eq(externalWorkerAssignments.id, id))
        .limit(1);

      if (!assignment || assignment.agencyId !== agencyId) {
        return res.status(403).json({ message: "Forbidden: Cannot delete assignments from other agencies" });
      }

      await db.delete(externalWorkerAssignments).where(eq(externalWorkerAssignments.id, id));
      await createAuditLog(req, "delete", "external_worker_assignment", id, "Deleted worker assignment");

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting worker assignment:", error);
      handleGenericError(res, error);
    }
  });

  // ================================================================================
  // External Accounting / Financial Transactions Routes
  // ================================================================================

  // GET /api/external/accounting/overview - Consolidated endpoint for all accounting data
  // Reduces multiple API calls to a single request for better performance
  app.get("/api/external/accounting/overview", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { direction, category, status, condominiumId, unitId, startDate, endDate, search, sortField, sortOrder, limit, offset } = req.query;

      // Parse pagination params
      const limitNum = limit ? parseInt(limit as string, 10) : 20;
      const offsetNum = offset ? parseInt(offset as string, 10) : 0;
      const parsedLimit = Number.isFinite(limitNum) ? Math.min(Math.max(1, limitNum), 100) : 20;
      const parsedOffset = Number.isFinite(offsetNum) ? Math.max(0, offsetNum) : 0;

      // Build filters object
      const filters: any = {
        limit: parsedLimit,
        offset: parsedOffset,
      };
      if (direction && direction !== 'all') filters.direction = direction;
      if (category && category !== 'all') filters.category = category;
      if (status && status !== 'all') filters.status = status;
      if (condominiumId && condominiumId !== 'all') filters.condominiumId = condominiumId as string;
      if (unitId && unitId !== 'all') filters.unitId = unitId as string;
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);
      if (search) filters.search = search as string;
      if (zone) filters.zone = zone as string;
      if (typology) filters.typology = typology as string;
      if (sortField) filters.sortField = sortField as string;
      if (sortOrder && (sortOrder === 'asc' || sortOrder === 'desc')) filters.sortOrder = sortOrder;

      // Execute all queries in parallel for maximum performance
      const [transactions, total, condominiums, units] = await Promise.all([
        // Paginated transactions
        storage.getExternalFinancialTransactionsByAgency(agencyId, filters),
        // Total count for pagination
        storage.getExternalFinancialTransactionsCountByAgency(agencyId, {
          direction: filters.direction,
          category: filters.category,
          status: filters.status,
          unitId: filters.unitId,
          condominiumId: filters.condominiumId,
          startDate: filters.startDate,
          endDate: filters.endDate,
          search: filters.search,
        }),
        // Filter options - condominiums
        db.select({
          id: externalCondominiums.id,
          name: externalCondominiums.name,
        })
        .from(externalCondominiums)
        .where(eq(externalCondominiums.agencyId, agencyId))
        .orderBy(asc(externalCondominiums.name)),
        // Filter options - units
        db.select({
          id: externalUnits.id,
          unitNumber: externalUnits.unitNumber,
          condominiumId: externalUnits.condominiumId,
        })
        .from(externalUnits)
        .where(eq(externalUnits.agencyId, agencyId))
        .orderBy(asc(externalUnits.unitNumber)),
      ]);

      // Calculate analytics from the transactions we already have (avoiding extra queries)
      const todayStart = new Date();
      todayStart.setHours(0, 0, 0, 0);
      const todayEnd = new Date();
      todayEnd.setHours(23, 59, 59, 999);

      // For analytics, we need aggregates - run optimized queries
      const baseConditions = [eq(externalFinancialTransactions.agencyId, agencyId)];
      if (filters.direction) baseConditions.push(eq(externalFinancialTransactions.direction, filters.direction));
      if (filters.category) baseConditions.push(eq(externalFinancialTransactions.category, filters.category));
      if (filters.status) baseConditions.push(eq(externalFinancialTransactions.status, filters.status));
      if (filters.condominiumId) baseConditions.push(eq(externalFinancialTransactions.condominiumId, filters.condominiumId));
      if (filters.unitId) baseConditions.push(eq(externalFinancialTransactions.unitId, filters.unitId));
      if (filters.startDate) baseConditions.push(gte(externalFinancialTransactions.dueDate, filters.startDate));
      if (filters.endDate) baseConditions.push(lte(externalFinancialTransactions.dueDate, filters.endDate));

      // Run all analytics aggregates in parallel
      const [incomeExpense, receivablesToday, receivablesOverdue, receivablesUpcoming] = await Promise.all([
        db.select({
          direction: externalFinancialTransactions.direction,
          total: sql<string>`COALESCE(SUM(CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL)), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(...baseConditions, eq(externalFinancialTransactions.status, 'completed')))
        .groupBy(externalFinancialTransactions.direction),
        db.select({
          count: sql<number>`COUNT(*)::int`,
          total: sql<string>`COALESCE(SUM(CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL)), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(
          ...baseConditions,
          eq(externalFinancialTransactions.status, 'pending'),
          eq(externalFinancialTransactions.direction, 'inflow'),
          sql`${externalFinancialTransactions.dueDate} >= ${todayStart}`,
          sql`${externalFinancialTransactions.dueDate} <= ${todayEnd}`
        )),
        db.select({
          count: sql<number>`COUNT(*)::int`,
          total: sql<string>`COALESCE(SUM(CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL)), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(
          ...baseConditions,
          eq(externalFinancialTransactions.status, 'pending'),
          eq(externalFinancialTransactions.direction, 'inflow'),
          sql`${externalFinancialTransactions.dueDate} < ${todayStart}`
        )),
        db.select({
          count: sql<number>`COUNT(*)::int`,
          total: sql<string>`COALESCE(SUM(CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL)), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(
          ...baseConditions,
          eq(externalFinancialTransactions.status, 'pending'),
          eq(externalFinancialTransactions.direction, 'inflow'),
          sql`${externalFinancialTransactions.dueDate} > ${todayEnd}`
        )),
      ]);

      let totalIncome = 0;
      let totalExpenses = 0;
      for (const row of incomeExpense) {
        const amount = parseFloat(row.total || '0');
        if (row.direction === 'inflow') totalIncome = amount;
        else if (row.direction === 'outflow') totalExpenses = amount;
      }

      res.json({
        transactions: {
          data: transactions,
          total,
          limit: parsedLimit,
          offset: parsedOffset,
          hasMore: parsedOffset + transactions.length < total,
        },
        analytics: {
          totalIncome,
          totalExpenses,
          netBalance: totalIncome - totalExpenses,
          receivables: {
            today: { count: receivablesToday[0]?.count || 0, total: parseFloat(receivablesToday[0]?.total || '0') },
            overdue: { count: receivablesOverdue[0]?.count || 0, total: parseFloat(receivablesOverdue[0]?.total || '0') },
            upcoming: { count: receivablesUpcoming[0]?.count || 0, total: parseFloat(receivablesUpcoming[0]?.total || '0') },
          },
        },
        filters: {
          condominiums,
          units,
        },
      });
    } catch (error: any) {
      console.error("Error fetching accounting overview:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/accounting/summary - Get accounting summary for agency
  app.get("/api/external/accounting/summary", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const summary = await storage.getExternalAccountingSummary(agencyId);
      res.json(summary);
    } catch (error: any) {
      console.error("Error fetching accounting summary:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/accounting/transactions - Get financial transactions with filters
  app.get("/api/external/accounting/transactions", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { direction, category, status, ownerId, contractId, unitId, condominiumId, startDate, endDate, search, sortField, sortOrder, limit, offset, zone, typology } = req.query;

      // Detect pagination mode: only check limit/offset to avoid breaking legacy consumers that use search/sortField
      const usePagination = (limit !== undefined && limit !== '') || (offset !== undefined && offset !== '');

      const filters: any = {};
      if (direction) filters.direction = direction;
      if (category) filters.category = category;
      if (status) filters.status = status;
      if (ownerId) filters.ownerId = ownerId as string;
      if (contractId) filters.contractId = contractId as string;
      if (unitId) filters.unitId = unitId as string;
      if (condominiumId) filters.condominiumId = condominiumId as string;
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);

      if (usePagination) {
        // Paginated mode: return envelope with pagination metadata
        const limitNum = limit ? parseInt(limit as string, 10) : 50;
        const offsetNum = offset ? parseInt(offset as string, 10) : 0;
        const parsedLimit = Number.isFinite(limitNum) ? Math.min(Math.max(1, limitNum), 100) : 50;
        const parsedOffset = Number.isFinite(offsetNum) ? Math.max(0, offsetNum) : 0;

        if (search) filters.search = search as string;
      if (zone) filters.zone = zone as string;
      if (typology) filters.typology = typology as string;
        if (sortField) filters.sortField = sortField as string;
        if (sortOrder && (sortOrder === 'asc' || sortOrder === 'desc')) filters.sortOrder = sortOrder;
        filters.limit = parsedLimit;
        filters.offset = parsedOffset;

        // Execute data fetch and count in parallel
        const [transactions, total] = await Promise.all([
          storage.getExternalFinancialTransactionsByAgency(agencyId, filters),
          storage.getExternalFinancialTransactionsCountByAgency(agencyId, {
            direction: filters.direction,
            category: filters.category,
            status: filters.status,
            ownerId: filters.ownerId,
            contractId: filters.contractId,
            unitId: filters.unitId,
            condominiumId: filters.condominiumId,
            startDate: filters.startDate,
            endDate: filters.endDate,
            search: filters.search,
          sellerId: filters.sellerId,
          sellerScope: filters.sellerScope,
          expiringDays: filters.expiringDays,
          }),
        ]);

        res.json({
          data: transactions,
          total,
          limit: parsedLimit,
          offset: parsedOffset,
          hasMore: parsedOffset + transactions.length < total,
        });
      } else {
        // Legacy mode: return simple array (NO pagination - full dataset)
        // Preserve historical behavior: existing filters only, NO sortField/sortOrder
        // Storage will use default ordering (desc by dueDate)
        if (search) filters.search = search as string;
      if (zone) filters.zone = zone as string;
      if (typology) filters.typology = typology as string;
        // DO NOT pass sortField/sortOrder/limit/offset - legacy callers expect default behavior
        const transactions = await storage.getExternalFinancialTransactionsByAgency(agencyId, filters);
        res.json(transactions);
      }
    } catch (error: any) {
      console.error("Error fetching financial transactions:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/accounting/analytics - Get aggregated analytics data
  app.get("/api/external/accounting/analytics", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const { direction, category, status, condominiumId, unitId, startDate, endDate, search } = req.query;

      // Build filter conditions
      const conditions: any[] = [eq(externalFinancialTransactions.agencyId, agencyId)];
      
      if (direction) conditions.push(eq(externalFinancialTransactions.direction, direction as string));
      if (category) conditions.push(eq(externalFinancialTransactions.category, category as string));
      if (status) conditions.push(eq(externalFinancialTransactions.status, status as string));
      if (condominiumId) conditions.push(eq(externalFinancialTransactions.condominiumId, condominiumId as string));
      if (unitId) conditions.push(eq(externalFinancialTransactions.unitId, unitId as string));
      if (startDate) conditions.push(sql`${externalFinancialTransactions.dueDate} >= ${new Date(startDate as string)}`);
      if (endDate) conditions.push(sql`${externalFinancialTransactions.dueDate} <= ${new Date(endDate as string)}`);
      
      // Add search filter with sanitization (same as /transactions endpoint)
      if (search && typeof search === 'string' && search.trim().length > 0) {
        const sanitized = search.trim().slice(0, 100);
        if (sanitized.length > 0) {
          const escaped = sanitized
            .replace(/\\/g, '\\\\')
            .replace(/%/g, '\\%')
            .replace(/_/g, '\\_');
          const searchPattern = `%${escaped}%`;
          
          const searchCondition = sql`(${externalFinancialTransactions.tenantName} ILIKE ${searchPattern} ESCAPE '\\' OR ${externalFinancialTransactions.paymentReference} ILIKE ${searchPattern} ESCAPE '\\')`;
          conditions.push(searchCondition);
        }
      }

      // Calculate total income and expenses (all non-cancelled transactions)
      const [financialTotals] = await db
        .select({
          totalIncome: sql<string>`COALESCE(SUM(CASE WHEN ${externalFinancialTransactions.direction} = 'inflow' AND ${externalFinancialTransactions.status} != 'cancelled' THEN CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL) ELSE 0 END), 0)`,
          totalExpenses: sql<string>`COALESCE(SUM(CASE WHEN ${externalFinancialTransactions.direction} = 'outflow' AND ${externalFinancialTransactions.status} != 'cancelled' THEN CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL) ELSE 0 END), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(...conditions));

      const totalIncome = parseFloat(financialTotals.totalIncome || '0');
      const totalExpenses = parseFloat(financialTotals.totalExpenses || '0');
      const netBalance = totalIncome - totalExpenses;

      // Calculate receivables (pending inflow only)
      const now = new Date();
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);

      const [receivablesToday] = await db
        .select({
          count: sql<number>`COUNT(*)::int`,
          total: sql<string>`COALESCE(SUM(CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL)), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(
          ...conditions,
          eq(externalFinancialTransactions.status, 'pending'),
          sql`${externalFinancialTransactions.dueDate} >= ${todayStart}`,
          sql`${externalFinancialTransactions.dueDate} <= ${todayEnd}`
        ));

      const [receivablesOverdue] = await db
        .select({
          count: sql<number>`COUNT(*)::int`,
          total: sql<string>`COALESCE(SUM(CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL)), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(
          ...conditions,
          eq(externalFinancialTransactions.status, 'pending'),
          eq(externalFinancialTransactions.direction, 'inflow'),
          sql`${externalFinancialTransactions.dueDate} < ${todayStart}`
        ));

      const [receivablesUpcoming] = await db
        .select({
          count: sql<number>`COUNT(*)::int`,
          total: sql<string>`COALESCE(SUM(CAST(${externalFinancialTransactions.grossAmount} AS DECIMAL)), 0)`,
        })
        .from(externalFinancialTransactions)
        .where(and(
          ...conditions,
          eq(externalFinancialTransactions.status, 'pending'),
          eq(externalFinancialTransactions.direction, 'inflow'),
          sql`${externalFinancialTransactions.dueDate} > ${todayEnd}`
        ));

      res.json({
        totalIncome,
        totalExpenses,
        netBalance,
        receivables: {
          today: {
            count: receivablesToday.count || 0,
            total: parseFloat(receivablesToday.total || '0'),
          },
          overdue: {
            count: receivablesOverdue.count || 0,
            total: parseFloat(receivablesOverdue.total || '0'),
          },
          upcoming: {
            count: receivablesUpcoming.count || 0,
            total: parseFloat(receivablesUpcoming.total || '0'),
          },
        },
      });
    } catch (error: any) {
      console.error("Error fetching analytics:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/accounting/transactions/:id - Get specific transaction
  app.get("/api/external/accounting/transactions/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const transaction = await storage.getExternalFinancialTransaction(id);

      if (!transaction) {
        return res.status(404).json({ message: "Transaction not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, transaction.agencyId);
      if (!hasAccess) return;

      res.json(transaction);
    } catch (error: any) {
      console.error("Error fetching transaction:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/accounting/transactions - Create new financial transaction
  app.post("/api/external/accounting/transactions", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "No agency access" });
      }

      const transactionData = insertExternalFinancialTransactionSchema.parse({
        ...req.body,
        agencyId,
        createdBy: req.user?.id || req.session?.userId,
      });

      const transaction = await storage.createExternalFinancialTransaction(transactionData);

      await createAuditLog(req, "create", "external_financial_transaction", transaction.id, `Created ${transaction.direction} transaction: ${transaction.category}`);
      res.status(201).json(transaction);
    } catch (error: any) {
      console.error("Error creating financial transaction:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/accounting/transactions/:id - Update financial transaction
  app.patch("/api/external/accounting/transactions/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalFinancialTransaction(id);

      if (!existing) {
        return res.status(404).json({ message: "Transaction not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      const updates = updateExternalFinancialTransactionSchema.parse(req.body);
      const transaction = await storage.updateExternalFinancialTransaction(id, updates);

      await createAuditLog(req, "update", "external_financial_transaction", id, "Updated financial transaction");
      res.json(transaction);
    } catch (error: any) {
      console.error("Error updating financial transaction:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/accounting/transactions/:id - Delete financial transaction
  app.delete("/api/external/accounting/transactions/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalFinancialTransaction(id);

      if (!existing) {
        return res.status(404).json({ message: "Transaction not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      await storage.deleteExternalFinancialTransaction(id);

      await createAuditLog(req, "delete", "external_financial_transaction", id, "Deleted financial transaction");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting financial transaction:", error);
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/accounting/transactions/:id/mark-paid - Mark transaction as paid
  app.patch("/api/external/accounting/transactions/:id/mark-paid", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { paidDate, notes } = req.body;

      const existing = await storage.getExternalFinancialTransaction(id);
      if (!existing) {
        return res.status(404).json({ message: "Transaction not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      // Update the transaction to mark as paid
      const updatedTransaction = await storage.updateExternalFinancialTransaction(id, {
        status: 'posted',
        performedDate: paidDate ? new Date(paidDate) : new Date(),
        notes: notes ? (existing.notes ? `${existing.notes}\n${notes}` : notes) : existing.notes,
      });

      // If this transaction is linked to a maintenance ticket, update ticket accounting status
      if (existing.maintenanceTicketId) {
        await db.update(externalMaintenanceTickets)
          .set({ accountingSyncStatus: 'synced' })
          .where(eq(externalMaintenanceTickets.id, existing.maintenanceTicketId));
      }

      await createAuditLog(req, "update", "external_financial_transaction", id, "Marked transaction as paid");
      res.json(updatedTransaction);
    } catch (error: any) {
      console.error("Error marking transaction as paid:", error);
      handleGenericError(res, error);
    }
  });


  // GET /api/external/accounting/worker-payments - Get worker payments for biweekly period
  app.get("/api/external/accounting/worker-payments", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const year = parseInt(req.query.year as string) || new Date().getFullYear();
      const month = parseInt(req.query.month as string) || (new Date().getMonth() + 1);
      const period = parseInt(req.query.period as string) || (new Date().getDate() <= 15 ? 1 : 2);
      const category = req.query.category as string;
      const condominiumId = req.query.condominiumId as string;

      // Calculate date range for biweekly period
      const startDay = period === 1 ? 1 : 16;
      const endDay = period === 1 ? 15 : new Date(year, month, 0).getDate();
      const startDate = new Date(year, month - 1, startDay, 0, 0, 0);
      const endDate = new Date(year, month - 1, endDay, 23, 59, 59);

      // Build query conditions
      const conditions: any[] = [
        eq(externalMaintenanceTickets.agencyId, agencyId),
        sql`${externalMaintenanceTickets.closedAt} >= ${startDate}`,
        sql`${externalMaintenanceTickets.closedAt} <= ${endDate}`,
        or(
          eq(externalMaintenanceTickets.status, 'closed'),
          eq(externalMaintenanceTickets.status, 'resolved')
        ),
      ];

      if (category === 'maintenance') {
        conditions.push(not(eq(externalMaintenanceTickets.category, 'cleaning')));
      } else if (category === 'cleaning') {
        conditions.push(eq(externalMaintenanceTickets.category, 'cleaning'));
      }

      if (condominiumId && condominiumId !== 'all') {
        const unitIds = await db.select({ id: externalUnits.id })
          .from(externalUnits)
          .where(eq(externalUnits.condominiumId, condominiumId));
        if (unitIds.length > 0) {
          conditions.push(inArray(externalMaintenanceTickets.unitId, unitIds.map(u => u.id)));
        }
      }

      const tickets = await db.select({
        id: externalMaintenanceTickets.id,
        title: externalMaintenanceTickets.title,
        assignedTo: externalMaintenanceTickets.assignedTo,
        actualCost: externalMaintenanceTickets.actualCost,
        adminFeeAmount: externalMaintenanceTickets.adminFeeAmount,
        totalChargeAmount: externalMaintenanceTickets.totalChargeAmount,
        closedAt: externalMaintenanceTickets.closedAt,
        unitId: externalMaintenanceTickets.unitId,
        workerPaymentStatus: externalMaintenanceTickets.workerPaymentStatus,
        workerPaymentDate: externalMaintenanceTickets.workerPaymentDate,
        agencyCollectedStatus: externalMaintenanceTickets.agencyCollectedStatus,
        agencyCollectedDate: externalMaintenanceTickets.agencyCollectedDate,
        accountingTransactionId: externalMaintenanceTickets.accountingTransactionId,
      })
      .from(externalMaintenanceTickets)
      .where(and(...conditions));

      // Group by worker
      const workerPayments = new Map<string, {
        workerId: string;
        workerName: string;
        tickets: any[];
        totalActualCost: number;
        totalAdminFee: number;
        totalCharge: number;
      }>();

      for (const ticket of tickets) {
        if (!ticket.assignedTo) continue;

        const [worker] = await db.select({
          id: users.id,
          firstName: users.firstName,
          lastName: users.lastName,
        }).from(users).where(eq(users.id, ticket.assignedTo));

        if (!worker) continue;

        const workerName = `${worker.firstName || ''} ${worker.lastName || ''}`.trim() || 'Sin nombre';
        const workerId = worker.id;

        if (!workerPayments.has(workerId)) {
          workerPayments.set(workerId, {
            workerId,
            workerName,
            tickets: [],
            totalActualCost: 0,
            totalAdminFee: 0,
            totalCharge: 0,
          });
        }

        const payment = workerPayments.get(workerId)!;
        const actualCost = parseFloat(ticket.actualCost || '0');
        const adminFee = parseFloat(ticket.adminFeeAmount || '0');
        const totalCharge = parseFloat(ticket.totalChargeAmount || '0') || (actualCost + adminFee);

        payment.tickets.push({
          id: ticket.id,
          title: ticket.title,
          actualCost,
          adminFee,
          totalCharge,
          closedAt: ticket.closedAt,
          workerPaymentStatus: ticket.workerPaymentStatus || "pending",
          agencyCollectedStatus: ticket.agencyCollectedStatus || "pending",
          workerPaymentDate: ticket.workerPaymentDate,
          agencyCollectedDate: ticket.agencyCollectedDate,
          accountingTransactionId: ticket.accountingTransactionId,
        });
        payment.totalActualCost += actualCost;
        payment.totalAdminFee += adminFee;
        payment.totalCharge += totalCharge;
      }

      const payments = Array.from(workerPayments.values()).map(p => ({
        id: `payment-${p.workerId}`,
        workerId: p.workerId,
        workerName: p.workerName,
        ticketCount: p.tickets.length,
        totalActualCost: p.totalActualCost,
        totalAdminFee: p.totalAdminFee,
        totalCharge: p.totalCharge,
        status: 'pending',
        tickets: p.tickets,
      }));

      const summary = {
        totalPayments: payments.length,
        totalActualCost: payments.reduce((sum, p) => sum + p.totalActualCost, 0),
        totalAdminFee: payments.reduce((sum, p) => sum + p.totalAdminFee, 0),
        totalCharge: payments.reduce((sum, p) => sum + p.totalCharge, 0),
      };

      res.json({ payments, summary });
    } catch (error: any) {
      console.error("Error fetching worker payments:", error);
      handleGenericError(res, error);
    }
  });


  // PATCH /api/external/maintenance/tickets/:id/payment-status - Mark ticket worker payment and agency collection status
  app.patch("/api/external/maintenance/tickets/:id/payment-status", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const ticketId = req.params.id;
      const { workerPaymentStatus, agencyCollectedStatus } = req.body;

      // Verify ticket belongs to agency
      const [ticket] = await db.select()
        .from(externalMaintenanceTickets)
        .where(and(
          eq(externalMaintenanceTickets.id, ticketId),
          eq(externalMaintenanceTickets.agencyId, agencyId)
        ));

      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }

      const updateData: any = { updatedAt: new Date() };
      
      if (workerPaymentStatus !== undefined) {
        updateData.workerPaymentStatus = workerPaymentStatus;
        if (workerPaymentStatus === 'paid') {
          updateData.workerPaymentDate = new Date();
        }
      }
      
      if (agencyCollectedStatus !== undefined) {
        updateData.agencyCollectedStatus = agencyCollectedStatus;
        if (agencyCollectedStatus === 'collected') {
          updateData.agencyCollectedDate = new Date();
        }
      }

      const [updated] = await db.update(externalMaintenanceTickets)
        .set(updateData)
        .where(eq(externalMaintenanceTickets.id, ticketId))
        .returning();

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating ticket payment status:", error);
      handleGenericError(res, error);
    }
  });
  // GET /api/external/accounting/commissions - Get agency commissions for biweekly period
  app.get("/api/external/accounting/commissions", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const year = parseInt(req.query.year as string) || new Date().getFullYear();
      const month = parseInt(req.query.month as string) || (new Date().getMonth() + 1);
      const period = parseInt(req.query.period as string) || (new Date().getDate() <= 15 ? 1 : 2);
      const condominiumId = req.query.condominiumId as string;

      const startDay = period === 1 ? 1 : 16;
      const endDay = period === 1 ? 15 : new Date(year, month, 0).getDate();
      const startDate = new Date(year, month - 1, startDay, 0, 0, 0);
      const endDate = new Date(year, month - 1, endDay, 23, 59, 59);

      const baseConditions: any[] = [
        eq(externalMaintenanceTickets.agencyId, agencyId),
        sql`${externalMaintenanceTickets.closedAt} >= ${startDate}`,
        sql`${externalMaintenanceTickets.closedAt} <= ${endDate}`,
        or(
          eq(externalMaintenanceTickets.status, 'closed'),
          eq(externalMaintenanceTickets.status, 'resolved')
        ),
      ];

      if (condominiumId && condominiumId !== 'all') {
        const unitIds = await db.select({ id: externalUnits.id })
          .from(externalUnits)
          .where(eq(externalUnits.condominiumId, condominiumId));
        if (unitIds.length > 0) {
          baseConditions.push(inArray(externalMaintenanceTickets.unitId, unitIds.map(u => u.id)));
        }
      }

      const maintenanceTickets = await db.select({
        id: externalMaintenanceTickets.id,
        title: externalMaintenanceTickets.title,
        adminFeeAmount: externalMaintenanceTickets.adminFeeAmount,
        closedAt: externalMaintenanceTickets.closedAt,
        category: externalMaintenanceTickets.category,
      })
      .from(externalMaintenanceTickets)
      .where(and(
        ...baseConditions,
        not(eq(externalMaintenanceTickets.category, 'cleaning'))
      ));

      const cleaningTickets = await db.select({
        id: externalMaintenanceTickets.id,
        title: externalMaintenanceTickets.title,
        adminFeeAmount: externalMaintenanceTickets.adminFeeAmount,
        closedAt: externalMaintenanceTickets.closedAt,
        category: externalMaintenanceTickets.category,
      })
      .from(externalMaintenanceTickets)
      .where(and(
        ...baseConditions,
        eq(externalMaintenanceTickets.category, 'cleaning')
      ));

      const commissions: any[] = [];

      for (const ticket of maintenanceTickets) {
        const adminFee = parseFloat(ticket.adminFeeAmount || '0');
        if (adminFee > 0) {
          commissions.push({
            id: `comm-maint-${ticket.id}`,
            type: 'admin_fee',
            description: `Comisión mantenimiento: ${ticket.title}`,
            sourceId: ticket.id,
            amount: adminFee,
            date: ticket.closedAt,
            category: 'maintenance',
          });
        }
      }

      for (const ticket of cleaningTickets) {
        const adminFee = parseFloat(ticket.adminFeeAmount || '0');
        if (adminFee > 0) {
          commissions.push({
            id: `comm-clean-${ticket.id}`,
            type: 'admin_fee',
            description: `Comisión limpieza: ${ticket.title}`,
            sourceId: ticket.id,
            amount: adminFee,
            date: ticket.closedAt,
            category: 'cleaning',
          });
        }
      }

      const totalMaintenanceFees = maintenanceTickets.reduce((sum, t) => sum + parseFloat(t.adminFeeAmount || '0'), 0);
      const totalCleaningFees = cleaningTickets.reduce((sum, t) => sum + parseFloat(t.adminFeeAmount || '0'), 0);

      const summary = {
        totalMaintenanceFees,
        totalCleaningFees,
        totalRentalCommissions: 0,
        grandTotal: totalMaintenanceFees + totalCleaningFees,
      };

      res.json({ commissions, summary });
    } catch (error: any) {
      console.error("Error fetching commissions:", error);
      handleGenericError(res, error);
    }
  });


  // ============================================================================
  // EXTERNAL MANAGEMENT SYSTEM - TERMS AND CONDITIONS ROUTES
  // ============================================================================

  // GET /api/external/configuration/terms - Get all terms for agency
  app.get("/api/external/configuration/terms", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const type = req.query.type as 'tenant' | 'owner' | undefined;
      const terms = await storage.getExternalTermsAndConditions(agencyId, type);
      res.json(terms);
    } catch (error: any) {
      console.error("Error fetching terms and conditions:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/configuration/terms/active - Get active terms for agency
  app.get("/api/external/configuration/terms/active", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const type = req.query.type as 'tenant' | 'owner';
      if (!type) {
        return res.status(400).json({ message: "Type (tenant or owner) is required" });
      }

      const terms = await storage.getActiveExternalTermsAndConditions(agencyId, type);
      res.json(terms || null);
    } catch (error: any) {
      console.error("Error fetching active terms:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/configuration/terms/:id - Get specific terms
  app.get("/api/external/configuration/terms/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const terms = await storage.getExternalTermsAndConditionsById(id);

      if (!terms) {
        return res.status(404).json({ message: "Terms and conditions not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, terms.agencyId);
      if (!hasAccess) return;

      res.json(terms);
    } catch (error: any) {
      console.error("Error fetching terms by ID:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/configuration/terms - Create new terms
  app.post("/api/external/configuration/terms", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const termsData = insertExternalTermsAndConditionsSchema.parse({
        ...req.body,
        agencyId,
        createdBy: req.user.id,
      });

      const terms = await storage.createExternalTermsAndConditions(termsData);

      await createAuditLog(req, "create", "external_terms_and_conditions", terms.id, "Created terms and conditions");
      res.status(201).json(terms);
    } catch (error: any) {
      console.error("Error creating terms:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/configuration/terms/:id - Update terms
  app.patch("/api/external/configuration/terms/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalTermsAndConditionsById(id);

      if (!existing) {
        return res.status(404).json({ message: "Terms and conditions not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      const updates = updateExternalTermsAndConditionsSchema.parse(req.body);
      const terms = await storage.updateExternalTermsAndConditions(id, updates);

      await createAuditLog(req, "update", "external_terms_and_conditions", id, "Updated terms and conditions");
      res.json(terms);
    } catch (error: any) {
      console.error("Error updating terms:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // POST /api/external/configuration/terms/:id/publish - Publish terms
  app.post("/api/external/configuration/terms/:id/publish", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalTermsAndConditionsById(id);

      if (!existing) {
        return res.status(404).json({ message: "Terms and conditions not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      const terms = await storage.publishExternalTermsAndConditions(id, req.user.id);

      await createAuditLog(req, "update", "external_terms_and_conditions", id, "Published terms and conditions");
      res.json(terms);
    } catch (error: any) {
      console.error("Error publishing terms:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/configuration/terms/:id/unpublish - Unpublish terms
  app.post("/api/external/configuration/terms/:id/unpublish", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalTermsAndConditionsById(id);

      if (!existing) {
        return res.status(404).json({ message: "Terms and conditions not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      const terms = await storage.unpublishExternalTermsAndConditions(id);

      await createAuditLog(req, "update", "external_terms_and_conditions", id, "Unpublished terms and conditions");
      res.json(terms);
    } catch (error: any) {
      console.error("Error unpublishing terms:", error);
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/configuration/terms/:id - Delete terms
  app.delete("/api/external/configuration/terms/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExternalTermsAndConditionsById(id);

      if (!existing) {
        return res.status(404).json({ message: "Terms and conditions not found" });
      }

      const hasAccess = await verifyExternalAgencyOwnership(req, res, existing.agencyId);
      if (!hasAccess) return;

      await storage.deleteExternalTermsAndConditions(id);

      await createAuditLog(req, "delete", "external_terms_and_conditions", id, "Deleted terms and conditions");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting terms:", error);
      handleGenericError(res, error);
    }
  });

  // ============================================================================


  // ============================================================================
  // EXTERNAL MANAGEMENT SYSTEM - CSV EXPORT/IMPORT ROUTES
  // ============================================================================

  // GET /api/external/data/export/:section - Export data as CSV
  app.get("/api/external/data/export/:section", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const Papa = (await import('papaparse')).default;
      const { section } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      let data: any[] = [];
      let filename = '';
      
      switch (section) {
        case 'condominiums':
          const condos = await db.select().from(externalCondominiums).where(eq(externalCondominiums.agencyId, agencyId));
          data = condos.map(c => ({
            id: c.id,
            name: c.name,
            description: c.description || '',
            address: c.address || '',
            zone: c.zone || '',
            total_units: c.totalUnits || 0,
            is_active: c.isActive ? 'true' : 'false',
            created_at: c.createdAt?.toISOString() || '',
          }));
          filename = 'condominiums.csv';
          break;
          
        case 'units':
          const units = await db.select({
            id: externalUnits.id,
            unitNumber: externalUnits.unitNumber,
            condominiumId: externalUnits.condominiumId,
            condominiumName: externalCondominiums.name,
          squareMeters: externalUnits.area,
          description: externalUnits.description,
          petsAllowed: externalUnits.petFriendly,
            zone: externalUnits.zone,
            typology: externalUnits.typology,
            propertyType: externalUnits.propertyType,
            bedrooms: externalUnits.bedrooms,
            bathrooms: externalUnits.bathrooms,
            area: externalUnits.area,
            city: externalUnits.city,
            isActive: externalUnits.isActive,
            createdAt: externalUnits.createdAt,
          })
          .from(externalUnits)
          .leftJoin(externalCondominiums, eq(externalUnits.condominiumId, externalCondominiums.id))
          .where(eq(externalUnits.agencyId, agencyId));
          
          data = units.map(u => ({
            id: u.id,
            unit_number: u.unitNumber,
            condominium_id: u.condominiumId || '',
            condominium_name: u.condominiumName || '',
            zone: u.zone || '',
            city: u.city || '',
            typology: u.typology || '',
            property_type: u.propertyType || '',
            bedrooms: u.bedrooms || 0,
            bathrooms: u.bathrooms || 0,
            area: u.area || 0,
            is_active: u.isActive ? 'true' : 'false',
            created_at: u.createdAt?.toISOString() || '',
          }));
          filename = 'units.csv';
          break;
          
        case 'owners':
          const owners = await db.select({
            id: externalUnitOwners.id,
            unitId: externalUnitOwners.unitId,
            unitNumber: externalUnits.unitNumber,
            ownerName: externalUnitOwners.ownerName,
            ownerEmail: externalUnitOwners.ownerEmail,
            ownerPhone: externalUnitOwners.ownerPhone,
            ownershipPercentage: externalUnitOwners.ownershipPercentage,
            isActive: externalUnitOwners.isActive,
            notes: externalUnitOwners.notes,
            createdAt: externalUnitOwners.createdAt,
          })
          .from(externalUnitOwners)
          .leftJoin(externalUnits, eq(externalUnitOwners.unitId, externalUnits.id))
          .where(eq(externalUnits.agencyId, agencyId));
          
          data = owners.map(o => ({
            id: o.id,
            unit_id: o.unitId || '',
            unit_number: o.unitNumber || '',
            owner_name: o.ownerName,
            email: o.ownerEmail || '',
            phone: o.ownerPhone || '',
            ownership_percentage: o.ownershipPercentage || '100.00',
            is_active: o.isActive ? 'true' : 'false',
            notes: o.notes || '',
            created_at: o.createdAt?.toISOString() || '',
          }));
          filename = 'owners.csv';
          break;
          
        case 'clients':
          const clients = await db.select().from(externalClients).where(eq(externalClients.agencyId, agencyId));
          data = clients.map(c => ({
            id: c.id,
            first_name: c.firstName,
            last_name: c.lastName,
            email: c.email || '',
            phone: c.phone || '',
            nationality: c.nationality || '',
            client_type: c.clientType || '',
            status: c.status || 'active',
            notes: c.notes || '',
            created_at: c.createdAt?.toISOString() || '',
          }));
          filename = 'clients.csv';
          break;
          
        case 'leads':
          const leads = await db.select().from(externalLeads).where(eq(externalLeads.agencyId, agencyId));
          data = leads.map(l => ({
            id: l.id,
            first_name: l.firstName,
            last_name: l.lastName,
            email: l.email || '',
            phone: l.phone || '',
            registration_type: l.registrationType || 'seller',
            lead_type: l.leadType || '',
            status: l.status || '',
            source: l.source || '',
            assigned_to: l.assignedTo || '',
            property_interest: l.propertyInterest || '',
            budget_min: l.budgetMin || '',
            budget_max: l.budgetMax || '',
            notes: l.notes || '',
            created_at: l.createdAt?.toISOString() || '',
          }));
          filename = 'leads.csv';
          break;
          
        case 'contracts':
          const contracts = await db.select({
            id: externalRentalContracts.id,
            unitId: externalRentalContracts.unitId,
            unitNumber: externalUnits.unitNumber,
            contractType: externalRentalContracts.contractType,
            status: externalRentalContracts.status,
            startDate: externalRentalContracts.startDate,
            endDate: externalRentalContracts.endDate,
            rentAmount: externalRentalContracts.rentAmount,
            currency: externalRentalContracts.currency,
            createdAt: externalRentalContracts.createdAt,
          })
          .from(externalRentalContracts)
          .leftJoin(externalUnits, eq(externalRentalContracts.unitId, externalUnits.id))
          .where(eq(externalRentalContracts.agencyId, agencyId));
          
          data = contracts.map(c => ({
            id: c.id,
            unit_id: c.unitId || '',
            unit_number: c.unitNumber || '',
            contract_type: c.contractType || '',
            status: c.status || '',
            start_date: c.startDate?.toISOString().split('T')[0] || '',
            end_date: c.endDate?.toISOString().split('T')[0] || '',
            rent_amount: c.rentAmount || 0,
            currency: c.currency || 'USD',
            created_at: c.createdAt?.toISOString() || '',
          }));
          filename = 'contracts.csv';
          break;
          
        case 'maintenance':
          const tickets = await db.select({
            id: externalMaintenanceTickets.id,
            unitId: externalMaintenanceTickets.unitId,
            unitNumber: externalUnits.unitNumber,
            title: externalMaintenanceTickets.title,
            description: externalMaintenanceTickets.description,
            category: externalMaintenanceTickets.category,
            priority: externalMaintenanceTickets.priority,
            status: externalMaintenanceTickets.status,
            createdAt: externalMaintenanceTickets.createdAt,
            resolvedAt: externalMaintenanceTickets.resolvedAt,
          })
          .from(externalMaintenanceTickets)
          .leftJoin(externalUnits, eq(externalMaintenanceTickets.unitId, externalUnits.id))
          .where(eq(externalMaintenanceTickets.agencyId, agencyId));
          
          data = tickets.map(t => ({
            id: t.id,
            unit_id: t.unitId || '',
            unit_number: t.unitNumber || '',
            title: t.title,
            description: t.description || '',
            category: t.category || '',
            priority: t.priority || '',
            status: t.status || '',
            created_at: t.createdAt?.toISOString() || '',
            resolved_at: t.resolvedAt?.toISOString() || '',
          }));
          filename = 'maintenance_tickets.csv';
          break;
          
        case 'transactions':
          const transactions = await db.select({
            id: externalFinancialTransactions.id,
            unitId: externalFinancialTransactions.unitId,
            unitNumber: externalUnits.unitNumber,
            type: externalFinancialTransactions.type,
            category: externalFinancialTransactions.category,
            amount: externalFinancialTransactions.amount,
            currency: externalFinancialTransactions.currency,
            status: externalFinancialTransactions.status,
            description: externalFinancialTransactions.description,
            date: externalFinancialTransactions.transactionDate,
            createdAt: externalFinancialTransactions.createdAt,
          })
          .from(externalFinancialTransactions)
          .leftJoin(externalUnits, eq(externalFinancialTransactions.unitId, externalUnits.id))
          .where(eq(externalFinancialTransactions.agencyId, agencyId));
          
          data = transactions.map(t => ({
            id: t.id,
            unit_id: t.unitId || '',
            unit_number: t.unitNumber || '',
            type: t.type || '',
            category: t.category || '',
            amount: t.amount || 0,
            currency: t.currency || 'USD',
            status: t.status || '',
            description: t.description || '',
            transaction_date: t.date?.toISOString().split('T')[0] || '',
            created_at: t.createdAt?.toISOString() || '',
          }));
          filename = 'transactions.csv';
          break;
          
        case 'quotations':
          const quotations = await db.select({
            id: externalQuotations.id,
            unitId: externalQuotations.unitId,
            unitNumber: externalUnits.unitNumber,
            clientName: externalQuotations.clientName,
            clientEmail: externalQuotations.clientEmail,
            status: externalQuotations.status,
            totalAmount: externalQuotations.totalAmount,
            adminFee: externalQuotations.adminFee,
            currency: externalQuotations.currency,
            validUntil: externalQuotations.validUntil,
            createdAt: externalQuotations.createdAt,
          })
          .from(externalQuotations)
          .leftJoin(externalUnits, eq(externalQuotations.unitId, externalUnits.id))
          .where(eq(externalQuotations.agencyId, agencyId));
          
          data = quotations.map(q => ({
            id: q.id,
            unit_id: q.unitId || '',
            unit_number: q.unitNumber || '',
            client_name: q.clientName || '',
            client_email: q.clientEmail || '',
            status: q.status || '',
            total_amount: q.totalAmount || 0,
            admin_fee: q.adminFee || 0,
            currency: q.currency || 'USD',
            valid_until: q.validUntil?.toISOString().split('T')[0] || '',
            created_at: q.createdAt?.toISOString() || '',
          }));
          filename = 'quotations.csv';
          break;
          
        case 'accounts':
          const externalRoles = ["external_agency_admin", "external_agency_accounting", "external_agency_maintenance", "external_agency_seller", "external_agency_concierge", "external_agency_lawyer"];
          const agencyUsers = await db
            .select({
              id: users.id,
              email: users.email,
              firstName: users.firstName,
              lastName: users.lastName,
              phone: users.phone,
              role: users.role,
              status: users.status,
              maintenanceSpecialty: users.maintenanceSpecialty,
              isSuspended: users.isSuspended,
              createdAt: users.createdAt,
            })
            .from(users)
            .where(and(
              inArray(users.role, externalRoles),
              eq(users.externalAgencyId, agencyId)
            ));
          
          data = agencyUsers.map(u => ({
            id: u.id,
            email: u.email || '',
            first_name: u.firstName || '',
            last_name: u.lastName || '',
            phone: u.phone || '',
            role: u.role || '',
            status: COALESCE(u.publish_status, 'draft') as status || 'active',
            maintenance_specialty: u.maintenanceSpecialty || '',
            is_suspended: u.isSuspended ? 'true' : 'false',
            created_at: u.createdAt?.toISOString() || '',
          }));
          filename = 'accounts.csv';
          break;
          
        default:
          return res.status(400).json({ message: `Unknown section: ${section}` });
      }

      if (data.length === 0) {
        return res.status(200).json({ message: 'No data to export', csv: '', filename });
      }

      // Generate CSV using papaparse
      const csv = Papa.unparse(data, {
        header: true,
        quotes: true,
      });

      await createAuditLog(req, "export", `external_${section}`, agencyId, `Exported ${data.length} ${section} records to CSV`);

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(csv);
    } catch (error: any) {
      console.error(`Error exporting ${req.params.section}:`, error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/imports/:jobId - Get import job status
  app.get("/api/external/imports/:jobId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { jobId } = req.params;
      const job = importJobs.get(jobId);
      
      if (!job) {
        return res.status(404).json({ message: "Import job not found" });
      }
      
      res.json({
        id: job.id,
        section: job.section,
        status: job.status,
        total: job.total,
        processed: job.processed,
        imported: job.imported,
        skipped: job.skipped,
        errors: job.errors.slice(0, 10),
        startedAt: job.startedAt.toISOString(),
        finishedAt: job.finishedAt?.toISOString() || null,
        message: job.message || null,
        progress: job.total > 0 ? Math.round((job.processed / job.total) * 100) : 0,
      });
    } catch (error) {
      console.error("Error getting import status:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/data/import/:section - Import data from CSV
  app.post("/api/external/data/import/:section", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const Papa = (await import('papaparse')).default;
      const { section } = req.params;
      const { csvData } = req.body;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }
      
      if (!csvData || typeof csvData !== 'string') {
        return res.status(400).json({ message: "CSV data is required" });
      }

      // Parse CSV
      const parseResult = Papa.parse(csvData, {
        header: true,
        skipEmptyLines: true,
        transformHeader: (h: string) => h.trim().toLowerCase().replace(/\s+/g, '_'),
      });

      if (parseResult.errors.length > 0) {
        return res.status(400).json({ 
          message: "CSV parsing errors", 
          errors: parseResult.errors.slice(0, 5) 
        });
      }

      const rows = parseResult.data as any[];
      
      // Create import job for progress tracking
      const jobId = crypto.randomUUID();
      const job: ImportJob = {
        id: jobId,
        section,
        status: 'processing',
        total: rows.length,
        processed: 0,
        imported: 0,
        skipped: 0,
        errors: [],
        startedAt: new Date(),
      };
      importJobs.set(jobId, job);
      
      // Return job ID immediately so client can poll for progress
      res.json({ jobId, total: rows.length, message: "Import started" });
      
      // Process rows asynchronously
      let imported = 0;
      let skipped = 0;
      let errors: string[] = [];
      
      const updateProgress = () => {
        job.processed = imported + skipped;
        job.imported = imported;
        job.skipped = skipped;
        job.errors = errors.slice(0, 50);
      };

      switch (section) {
        case 'condominiums':
          for (const row of rows) {
            try {
              if (!row.name?.trim()) {
                skipped++;
                continue;
              }
              
              // Check if exists by name
              const existing = await db.select().from(externalCondominiums)
                .where(and(
                  eq(externalCondominiums.agencyId, agencyId),
                  sql`LOWER(${externalCondominiums.name}) = LOWER(${row.name.trim()})`
                ))
                .limit(1);
              
              if (existing.length > 0) {
                skipped++;
                continue;
              }
              
              await db.insert(externalCondominiums).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                name: row.name.trim(),
                description: row.description?.trim() || null,
                address: row.address?.trim() || null,
                zone: row.zone?.trim() || null,
                totalUnits: parseInt(row.total_units) || 0,
                isActive: row.is_active !== 'false',
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.name}": ${e.message}`);
            }
          }
          break;
          
        case 'clients':
          for (const row of rows) {
            try {
              if (!row.first_name?.trim() || !row.last_name?.trim()) {
                skipped++;
                continue;
              }
              
              // Check for duplicates by name + phone/email
              const existingConditions: any[] = [eq(externalClients.agencyId, agencyId)];
              
              const firstName = row.first_name.trim();
              const lastName = row.last_name.trim();
              
              existingConditions.push(sql`LOWER(${externalClients.firstName}) = LOWER(${firstName})`);
              existingConditions.push(sql`LOWER(${externalClients.lastName}) = LOWER(${lastName})`);
              
              const existing = await db.select().from(externalClients)
                .where(and(...existingConditions))
                .limit(1);
              
              if (existing.length > 0) {
                skipped++;
                continue;
              }
              
              await db.insert(externalClients).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                firstName,
                lastName,
                email: row.email?.trim() || null,
                phone: row.phone?.trim() || null,
                nationality: row.nationality?.trim() || null,
                clientType: row.client_type?.trim() || 'tenant',
                status: row.status?.trim() || 'active',
                notes: row.notes?.trim() || null,
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.first_name} ${row.last_name}": ${e.message}`);
            }
          }
          break;
          
        case 'leads':
          for (const row of rows) {
            try {
              if (!row.first_name?.trim() || !row.last_name?.trim()) {
                skipped++;
                continue;
              }
              
              const firstName = row.first_name.trim();
              const lastName = row.last_name.trim();
              
              // Check for duplicates
              const existing = await db.select().from(externalLeads)
                .where(and(
                  eq(externalLeads.agencyId, agencyId),
                  sql`LOWER(${externalLeads.firstName}) = LOWER(${firstName})`,
                  sql`LOWER(${externalLeads.lastName}) = LOWER(${lastName})`
                ))
                .limit(1);
              
              if (existing.length > 0) {
                skipped++;
                continue;
              }
              
              await db.insert(externalLeads).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                firstName,
                lastName,
                email: row.email?.trim() || null,
                phone: row.phone?.trim() || null,
                leadType: row.lead_type?.trim() || 'buyer',
                status: row.status?.trim() || 'new',
                source: row.source?.trim() || 'csv_import',
                assignedTo: row.assigned_to?.trim() || null,
                propertyInterest: row.property_interest?.trim() || null,
                budgetMin: row.budget_min ? parseFloat(row.budget_min) : null,
                budgetMax: row.budget_max ? parseFloat(row.budget_max) : null,
                notes: row.notes?.trim() || null,
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.first_name} ${row.last_name}": ${e.message}`);
            }
          }
          break;
          
        case 'units':
          for (const row of rows) {
            try {
              if (!row.unit_number?.trim()) {
                skipped++;
                continue;
              }
              
              const unitNumber = row.unit_number.trim();
              
              // Resolve condominium by name if provided
              let condominiumId: string | null = null;
              if (row.condominium_name?.trim()) {
                const condo = await db.select().from(externalCondominiums)
                  .where(and(
                    eq(externalCondominiums.agencyId, agencyId),
                    sql`LOWER(${externalCondominiums.name}) = LOWER(${row.condominium_name.trim()})`
                  ))
                  .limit(1);
                if (condo.length > 0) {
                  condominiumId = condo[0].id;
                }
              }
              
              // Check for duplicates by unit number + condominium
              const existingConditions: any[] = [
                eq(externalUnits.agencyId, agencyId),
                sql`LOWER(${externalUnits.unitNumber}) = LOWER(${unitNumber})`
              ];
              if (condominiumId) {
                existingConditions.push(eq(externalUnits.condominiumId, condominiumId));
              }
              
              const existing = await db.select().from(externalUnits)
                .where(and(...existingConditions))
                .limit(1);
              
              if (existing.length > 0) {
                skipped++;
                continue;
              }
              
              await db.insert(externalUnits).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                condominiumId,
                unitNumber,
                zone: row.zone?.trim() || null,
                typology: row.typology?.trim() || null,
                propertyType: row.property_type?.trim() || null,
                bedrooms: row.bedrooms ? parseInt(row.bedrooms) : null,
                bathrooms: row.bathrooms ? parseFloat(row.bathrooms) : null,
                squareMeters: row.square_meters ? parseFloat(row.square_meters) : null,
                furnished: row.furnished === 'true',
                monthlyRent: row.monthly_rent ? parseFloat(row.monthly_rent) : null,
                currency: row.currency?.trim() || 'USD',
                status: row.status?.trim() || 'available',
                notes: row.notes?.trim() || null,
                isActive: row.is_active !== 'false',
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.unit_number}": ${e.message}`);
            }
          }
          break;
          
        case 'owners':
          for (const row of rows) {
            try {
              if (!row.owner_name?.trim() || !row.unit_number?.trim()) {
                skipped++;
                continue;
              }
              
              const ownerName = row.owner_name.trim();
              const unitNumber = row.unit_number.trim();
              
              // Find unit by number
              const unit = await db.select().from(externalUnits)
                .where(and(
                  eq(externalUnits.agencyId, agencyId),
                  sql`LOWER(${externalUnits.unitNumber}) = LOWER(${unitNumber})`
                ))
                .limit(1);
              
              if (unit.length === 0) {
                errors.push(`Unit "${unitNumber}" not found for owner "${ownerName}"`);
                skipped++;
                continue;
              }
              
              // Check for duplicates by owner name + unit
              const existing = await db.select().from(externalUnitOwners)
                .where(and(
                  eq(externalUnitOwners.unitId, unit[0].id),
                  sql`LOWER(${externalUnitOwners.ownerName}) = LOWER(${ownerName})`
                ))
                .limit(1);
              
              if (existing.length > 0) {
                skipped++;
                continue;
              }
              
              await db.insert(externalUnitOwners).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                unitId: unit[0].id,
                ownerName,
                ownerEmail: row.email?.trim() || null,
                ownerPhone: row.phone?.trim() || null,
                ownershipPercentage: row.ownership_percentage?.trim() || "100.00",
                isActive: row.is_active !== 'false',
                notes: row.notes?.trim() || null,
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.owner_name}": ${e.message}`);
            }
          }
          break;
          
        case 'contracts':
          for (const row of rows) {
            try {
              if (!row.unit_number?.trim()) {
                errors.push(`Row missing unit_number`);
                skipped++;
                continue;
              }
              
              // Resolve unit by number
              const unit = await db.select().from(externalUnits)
                .where(and(
                  eq(externalUnits.agencyId, agencyId),
                  sql`LOWER(${externalUnits.unitNumber}) = LOWER(${row.unit_number.trim()})`
                ))
                .limit(1);
              
              if (unit.length === 0) {
                errors.push(`Unit "${row.unit_number}" not found`);
                skipped++;
                continue;
              }
              
              await db.insert(externalRentalContracts).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                unitId: unit[0].id,
                contractType: row.contract_type?.trim() || 'fixed',
                status: row.status?.trim() || 'draft',
                startDate: row.start_date ? new Date(row.start_date) : null,
                endDate: row.end_date ? new Date(row.end_date) : null,
                rentAmount: row.rent_amount ? parseFloat(row.rent_amount) : null,
                currency: row.currency?.trim() || 'USD',
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.unit_number}": ${e.message}`);
            }
          }
          break;
          
        case 'maintenance':
          for (const row of rows) {
            try {
              if (!row.title?.trim()) {
                skipped++;
                continue;
              }
              
              const title = row.title.trim();
              
              // Resolve unit by number if provided
              let unitId: string | null = null;
              if (row.unit_number?.trim()) {
                const unit = await db.select().from(externalUnits)
                  .where(and(
                    eq(externalUnits.agencyId, agencyId),
                    sql`LOWER(${externalUnits.unitNumber}) = LOWER(${row.unit_number.trim()})`
                  ))
                  .limit(1);
                if (unit.length > 0) {
                  unitId = unit[0].id;
                }
              }
              
              // Check for duplicates by title
              const existing = await db.select().from(externalMaintenanceTickets)
                .where(and(
                  eq(externalMaintenanceTickets.agencyId, agencyId),
                  sql`LOWER(${externalMaintenanceTickets.title}) = LOWER(${title})`
                ))
                .limit(1);
              
              if (existing.length > 0) {
                skipped++;
                continue;
              }
              
              await db.insert(externalMaintenanceTickets).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                unitId,
                title,
                description: row.description?.trim() || null,
                category: row.category?.trim() || 'general',
                priority: row.priority?.trim() || 'medium',
                status: row.status?.trim() || 'open',
                reportedBy: row.reported_by?.trim() || null,
                estimatedCost: row.estimated_cost ? parseFloat(row.estimated_cost) : null,
                actualCost: row.actual_cost ? parseFloat(row.actual_cost) : null,
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.title}": ${e.message}`);
            }
          }
          break;
          
        case 'transactions':
          for (const row of rows) {
            try {
              if (!row.type?.trim() || !row.amount) {
                skipped++;
                continue;
              }
              
              // Resolve unit by number if provided
              let unitId: string | null = null;
              if (row.unit_number?.trim()) {
                const unit = await db.select().from(externalUnits)
                  .where(and(
                    eq(externalUnits.agencyId, agencyId),
                    sql`LOWER(${externalUnits.unitNumber}) = LOWER(${row.unit_number.trim()})`
                  ))
                  .limit(1);
                if (unit.length > 0) {
                  unitId = unit[0].id;
                }
              }
              
              await db.insert(externalFinancialTransactions).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                unitId,
                type: row.type.trim(),
                category: row.category?.trim() || 'other',
                amount: parseFloat(row.amount),
                currency: row.currency?.trim() || 'USD',
                status: row.status?.trim() || 'pending',
                description: row.description?.trim() || null,
                transactionDate: row.transaction_date ? new Date(row.transaction_date) : new Date(),
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row with amount ${row.amount}: ${e.message}`);
            }
          }
          break;
          
        case 'quotations':
          for (const row of rows) {
            try {
              if (!row.title?.trim()) {
                skipped++;
                continue;
              }
              
              const title = row.title.trim();
              
              // Resolve unit by number if provided
              let unitId: string | null = null;
              if (row.unit_number?.trim()) {
                const unit = await db.select().from(externalUnits)
                  .where(and(
                    eq(externalUnits.agencyId, agencyId),
                    sql`LOWER(${externalUnits.unitNumber}) = LOWER(${row.unit_number.trim()})`
                  ))
                  .limit(1);
                if (unit.length > 0) {
                  unitId = unit[0].id;
                }
              }
              
              // Check for duplicates by quotation number if provided
              if (row.quotation_number?.trim()) {
                const existing = await db.select().from(externalQuotations)
                  .where(and(
                    eq(externalQuotations.agencyId, agencyId),
                    sql`LOWER(${externalQuotations.quotationNumber}) = LOWER(${row.quotation_number.trim()})`
                  ))
                  .limit(1);
                
                if (existing.length > 0) {
                  skipped++;
                  continue;
                }
              }
              
              await db.insert(externalQuotations).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                agencyId,
                unitId,
                title,
                quotationNumber: row.quotation_number?.trim() || null,
                clientName: row.client_name?.trim() || null,
                clientEmail: row.client_email?.trim() || null,
                description: row.description?.trim() || null,
                status: row.status?.trim() || 'draft',
                totalAmount: row.total_amount ? parseFloat(row.total_amount) : 0,
                adminFee: row.admin_fee ? parseFloat(row.admin_fee) : 0,
                currency: row.currency?.trim() || 'USD',
                validUntil: row.valid_until ? new Date(row.valid_until) : null,
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.title}": ${e.message}`);
            }
          }
          break;
          
        case 'accounts':
          const bcrypt = (await import('bcryptjs')).default;
          for (const row of rows) {
            try {
              if (!row.email?.trim()) {
                skipped++;
                continue;
              }
              
              const email = row.email.trim().toLowerCase();
              
              // Check if user already exists
              const existingUser = await db.select().from(users)
                .where(eq(users.email, email))
                .limit(1);
              
              if (existingUser.length > 0) {
                skipped++;
                continue;
              }
              
              // Validate role
              const validRoles = ["external_agency_admin", "external_agency_accounting", "external_agency_maintenance", "external_agency_seller", "external_agency_concierge", "external_agency_lawyer"];
              const role = row.role?.trim() || 'external_agency_seller';
              if (!validRoles.includes(role)) {
                errors.push(`Invalid role "${role}" for user "${email}"`);
                skipped++;
                continue;
              }
              
              // Generate random password
              const tempPassword = crypto.randomBytes(8).toString('hex');
              const hashedPassword = await bcrypt.hash(tempPassword, 10);
              
              await db.insert(users).values({
                id: crypto.randomUUID(),
                registrationType: row.registration_type?.trim() || 'seller',
                email,
                password: hashedPassword,
                firstName: row.first_name?.trim() || null,
                lastName: row.last_name?.trim() || null,
                phone: row.phone?.trim() || null,
                role,
                status: row.status?.trim() || 'active',
                maintenanceSpecialty: row.maintenance_specialty?.trim() || null,
                externalAgencyId: agencyId,
                isActive: true,
                isSuspended: false,
                createdAt: new Date(),
                updatedAt: new Date(),
              });
              imported++;
            } catch (e: any) {
              errors.push(`Row "${row.email}": ${e.message}`);
            }
          }
          break;
          
        default:
          return res.status(400).json({ 
            message: `Import not supported for section: ${section}` 
          });
      }

      // Update job status to completed
      updateProgress();
      job.status = 'completed';
      job.finishedAt = new Date();
      job.message = `Imported ${imported} records, skipped ${skipped} duplicates${errors.length > 0 ? `, ${errors.length} errors` : ''}`;
      
      await createAuditLog(req, "import", `external_${section}`, agencyId, 
        `Imported ${imported} ${section} records from CSV (${skipped} skipped, ${errors.length} errors)`);
    } catch (error: any) {
      console.error(`Error importing ${req.params.section}:`, error);
      // Update job status to failed
      const job = importJobs.get(req.body.jobId || '');
      if (job) {
        job.status = 'failed';
        job.finishedAt = new Date();
        job.message = error.message || 'Import failed';
      }
    }
  });
  // ============================================================================
  // EXTERNAL MANAGEMENT SYSTEM - CONFIGURABLE ZONES ROUTES
  // ============================================================================

  // GET /api/external/config/zones - List all zones for agency
  app.get("/api/external/config/zones", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const zones = await db.select()
        .from(externalAgencyZones)
        .where(eq(externalAgencyZones.agencyId, agencyId))
        .orderBy(asc(externalAgencyZones.sortOrder), asc(externalAgencyZones.name));

      res.json(zones);
    } catch (error: any) {
      console.error("Error listing zones:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/config/zones - Create new zone
  app.post("/api/external/config/zones", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const validated = insertExternalAgencyZoneSchema.parse({
        ...req.body,
        agencyId,
      });

      const [zone] = await db.insert(externalAgencyZones)
        .values(validated)
        .returning();

      await createAuditLog(req, "create", "external_agency_zone", zone.id, `Created zone: ${zone.name}`);
      res.status(201).json(zone);
    } catch (error: any) {
      console.error("Error creating zone:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "A zone with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/config/zones/:id - Update zone
  app.patch("/api/external/config/zones/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyZones)
        .where(and(eq(externalAgencyZones.id, id), eq(externalAgencyZones.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Zone not found" });
      }

      const { name, isActive, sortOrder } = req.body;
      const updates: any = {};
      if (name !== undefined) updates.name = name;
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = sortOrder;

      const [updated] = await db.update(externalAgencyZones)
        .set(updates)
        .where(eq(externalAgencyZones.id, id))
        .returning();

      await createAuditLog(req, "update", "external_agency_zone", id, `Updated zone: ${updated.name}`);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating zone:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "A zone with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/config/zones/:id - Delete zone
  app.delete("/api/external/config/zones/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyZones)
        .where(and(eq(externalAgencyZones.id, id), eq(externalAgencyZones.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Zone not found" });
      }

      await db.delete(externalAgencyZones).where(eq(externalAgencyZones.id, id));

      await createAuditLog(req, "delete", "external_agency_zone", id, `Deleted zone: ${existing.name}`);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting zone:", error);
      handleGenericError(res, error);
    }
  });

  // ============================================================================
  // EXTERNAL MANAGEMENT SYSTEM - CONFIGURABLE PROPERTY TYPES ROUTES
  // ============================================================================

  // GET /api/external/config/property-types - List all property types for agency
  app.get("/api/external/config/property-types", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const propertyTypes = await db.select()
        .from(externalAgencyPropertyTypes)
        .where(eq(externalAgencyPropertyTypes.agencyId, agencyId))
        .orderBy(asc(externalAgencyPropertyTypes.sortOrder), asc(externalAgencyPropertyTypes.name));

      res.json(propertyTypes);
    } catch (error: any) {
      console.error("Error listing property types:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/config/property-types - Create new property type
  app.post("/api/external/config/property-types", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const validated = insertExternalAgencyPropertyTypeSchema.parse({
        ...req.body,
        agencyId,
      });

      const [propertyType] = await db.insert(externalAgencyPropertyTypes)
        .values(validated)
        .returning();

      await createAuditLog(req, "create", "external_agency_property_type", propertyType.id, `Created property type: ${propertyType.name}`);
      res.status(201).json(propertyType);
    } catch (error: any) {
      console.error("Error creating property type:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "A property type with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/config/property-types/:id - Update property type
  app.patch("/api/external/config/property-types/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyPropertyTypes)
        .where(and(eq(externalAgencyPropertyTypes.id, id), eq(externalAgencyPropertyTypes.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Property type not found" });
      }

      const { name, isActive, sortOrder } = req.body;
      const updates: any = {};
      if (name !== undefined) updates.name = name;
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = sortOrder;

      const [updated] = await db.update(externalAgencyPropertyTypes)
        .set(updates)
        .where(eq(externalAgencyPropertyTypes.id, id))
        .returning();

      await createAuditLog(req, "update", "external_agency_property_type", id, `Updated property type: ${updated.name}`);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating property type:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "A property type with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/config/property-types/:id - Delete property type
  app.delete("/api/external/config/property-types/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyPropertyTypes)
        .where(and(eq(externalAgencyPropertyTypes.id, id), eq(externalAgencyPropertyTypes.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Property type not found" });
      }

      await db.delete(externalAgencyPropertyTypes).where(eq(externalAgencyPropertyTypes.id, id));

      await createAuditLog(req, "delete", "external_agency_property_type", id, `Deleted property type: ${existing.name}`);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting property type:", error);
      handleGenericError(res, error);
    }
  });
  // EXTERNAL MANAGEMENT SYSTEM - QUOTATIONS ROUTES

  // ============================================================================
  // EXTERNAL MANAGEMENT SYSTEM - CONFIGURABLE UNIT CHARACTERISTICS ROUTES
  // ============================================================================

  // GET /api/external/config/unit-characteristics - List all unit characteristics for agency
  app.get("/api/external/config/unit-characteristics", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const characteristics = await db.select()
        .from(externalAgencyUnitCharacteristics)
        .where(eq(externalAgencyUnitCharacteristics.agencyId, agencyId))
        .orderBy(asc(externalAgencyUnitCharacteristics.category), asc(externalAgencyUnitCharacteristics.sortOrder), asc(externalAgencyUnitCharacteristics.name));

      res.json(characteristics);
    } catch (error: any) {
      console.error("Error listing unit characteristics:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/config/unit-characteristics - Create new unit characteristic
  app.post("/api/external/config/unit-characteristics", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const validated = insertExternalAgencyUnitCharacteristicSchema.parse({
        ...req.body,
        agencyId,
      });

      const [characteristic] = await db.insert(externalAgencyUnitCharacteristics)
        .values(validated)
        .returning();

      await createAuditLog(req, "create", "external_agency_unit_characteristic", characteristic.id, `Created unit characteristic: ${characteristic.name}`);
      res.status(201).json(characteristic);
    } catch (error: any) {
      console.error("Error creating unit characteristic:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "A unit characteristic with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/config/unit-characteristics/:id - Update unit characteristic
  app.patch("/api/external/config/unit-characteristics/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyUnitCharacteristics)
        .where(and(eq(externalAgencyUnitCharacteristics.id, id), eq(externalAgencyUnitCharacteristics.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Unit characteristic not found" });
      }

      const { name, nameEn, category, icon, isActive, sortOrder } = req.body;
      const updates: any = {};
      if (name !== undefined) updates.name = name;
      if (nameEn !== undefined) updates.nameEn = nameEn;
      if (category !== undefined) updates.category = category;
      if (icon !== undefined) updates.icon = icon;
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = sortOrder;

      const [updated] = await db.update(externalAgencyUnitCharacteristics)
        .set(updates)
        .where(eq(externalAgencyUnitCharacteristics.id, id))
        .returning();

      await createAuditLog(req, "update", "external_agency_unit_characteristic", id, `Updated unit characteristic: ${updated.name}`);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating unit characteristic:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "A unit characteristic with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/config/unit-characteristics/:id - Delete unit characteristic
  app.delete("/api/external/config/unit-characteristics/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyUnitCharacteristics)
        .where(and(eq(externalAgencyUnitCharacteristics.id, id), eq(externalAgencyUnitCharacteristics.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Unit characteristic not found" });
      }

      await db.delete(externalAgencyUnitCharacteristics).where(eq(externalAgencyUnitCharacteristics.id, id));

      await createAuditLog(req, "delete", "external_agency_unit_characteristic", id, `Deleted unit characteristic: ${existing.name}`);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting unit characteristic:", error);
      handleGenericError(res, error);
    }
  });

  // ============================================================================
  // EXTERNAL MANAGEMENT SYSTEM - CONFIGURABLE AMENITIES ROUTES
  // ============================================================================

  // GET /api/external/config/amenities - List all amenities for agency
  app.get("/api/external/config/amenities", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const amenities = await db.select()
        .from(externalAgencyAmenities)
        .where(eq(externalAgencyAmenities.agencyId, agencyId))
        .orderBy(asc(externalAgencyAmenities.category), asc(externalAgencyAmenities.sortOrder), asc(externalAgencyAmenities.name));

      res.json(amenities);
    } catch (error: any) {
      console.error("Error listing amenities:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/config/amenities - Create new amenity
  app.post("/api/external/config/amenities", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const validated = insertExternalAgencyAmenitySchema.parse({
        ...req.body,
        agencyId,
      });

      const [amenity] = await db.insert(externalAgencyAmenities)
        .values(validated)
        .returning();

      await createAuditLog(req, "create", "external_agency_amenity", amenity.id, `Created amenity: ${amenity.name}`);
      res.status(201).json(amenity);
    } catch (error: any) {
      console.error("Error creating amenity:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "An amenity with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/config/amenities/:id - Update amenity
  app.patch("/api/external/config/amenities/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyAmenities)
        .where(and(eq(externalAgencyAmenities.id, id), eq(externalAgencyAmenities.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Amenity not found" });
      }

      const { name, nameEn, category, icon, isActive, sortOrder } = req.body;
      const updates: any = {};
      if (name !== undefined) updates.name = name;
      if (nameEn !== undefined) updates.nameEn = nameEn;
      if (category !== undefined) updates.category = category;
      if (icon !== undefined) updates.icon = icon;
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = sortOrder;

      const [updated] = await db.update(externalAgencyAmenities)
        .set(updates)
        .where(eq(externalAgencyAmenities.id, id))
        .returning();

      await createAuditLog(req, "update", "external_agency_amenity", id, `Updated amenity: ${updated.name}`);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating amenity:", error);
      if (error.code === "23505") {
        return res.status(409).json({ message: "An amenity with this name already exists for your agency" });
      }
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/config/amenities/:id - Delete amenity
  app.delete("/api/external/config/amenities/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      const [existing] = await db.select()
        .from(externalAgencyAmenities)
        .where(and(eq(externalAgencyAmenities.id, id), eq(externalAgencyAmenities.agencyId, agencyId)));

      if (!existing) {
        return res.status(404).json({ message: "Amenity not found" });
      }

      await db.delete(externalAgencyAmenities).where(eq(externalAgencyAmenities.id, id));

      await createAuditLog(req, "delete", "external_agency_amenity", id, `Deleted amenity: ${existing.name}`);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting amenity:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/config/seed-characteristics-amenities - Seed default characteristics and amenities
  app.post("/api/external/config/seed-characteristics-amenities", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "Agency ID not found" });
      }

      // Default unit characteristics (40 items)
      const defaultCharacteristics = [
        // Cocina (Kitchen)
        { name: "Cocina Equipada", nameEn: "Equipped Kitchen", category: "kitchen", sortOrder: 1 },
        { name: "Estufa", nameEn: "Stove", category: "kitchen", sortOrder: 2 },
        { name: "Horno", nameEn: "Oven", category: "kitchen", sortOrder: 3 },
        { name: "Microondas", nameEn: "Microwave", category: "kitchen", sortOrder: 4 },
        { name: "Refrigerador", nameEn: "Refrigerator", category: "kitchen", sortOrder: 5 },
        { name: "Lavavajillas", nameEn: "Dishwasher", category: "kitchen", sortOrder: 6 },
        { name: "Tostador", nameEn: "Toaster", category: "kitchen", sortOrder: 7 },
        { name: "Cafetera", nameEn: "Coffee Maker", category: "kitchen", sortOrder: 8 },
        { name: "Licuadora", nameEn: "Blender", category: "kitchen", sortOrder: 9 },
        { name: "Utensilios de Cocina", nameEn: "Kitchen Utensils", category: "kitchen", sortOrder: 10 },
        // Lavandería (Laundry)
        { name: "Lavadora", nameEn: "Washing Machine", category: "laundry", sortOrder: 1 },
        { name: "Secadora", nameEn: "Dryer", category: "laundry", sortOrder: 2 },
        { name: "Centro de Lavado", nameEn: "Washer/Dryer Combo", category: "laundry", sortOrder: 3 },
        { name: "Área de Lavado", nameEn: "Laundry Area", category: "laundry", sortOrder: 4 },
        { name: "Tendedero", nameEn: "Clothesline", category: "laundry", sortOrder: 5 },
        // Climatización (Climate)
        { name: "Aire Acondicionado", nameEn: "Air Conditioning", category: "climate", sortOrder: 1 },
        { name: "Minisplit", nameEn: "Mini Split AC", category: "climate", sortOrder: 2 },
        { name: "Ventilador de Techo", nameEn: "Ceiling Fan", category: "climate", sortOrder: 3 },
        { name: "Calentador de Agua", nameEn: "Water Heater", category: "climate", sortOrder: 4 },
        { name: "Boiler Solar", nameEn: "Solar Water Heater", category: "climate", sortOrder: 5 },
        { name: "Calefacción", nameEn: "Heating", category: "climate", sortOrder: 6 },
        // Baño (Bathroom)
        { name: "Tina/Bañera", nameEn: "Bathtub", category: "bathroom", sortOrder: 1 },
        { name: "Regadera con Hidromasaje", nameEn: "Shower with Jets", category: "bathroom", sortOrder: 2 },
        { name: "Baño Completo", nameEn: "Full Bathroom", category: "bathroom", sortOrder: 3 },
        { name: "Medio Baño", nameEn: "Half Bathroom", category: "bathroom", sortOrder: 4 },
        // Recámara (Bedroom)
        { name: "Cama King Size", nameEn: "King Size Bed", category: "bedroom", sortOrder: 1 },
        { name: "Cama Queen Size", nameEn: "Queen Size Bed", category: "bedroom", sortOrder: 2 },
        { name: "Closet/Armario", nameEn: "Closet/Wardrobe", category: "bedroom", sortOrder: 3 },
        { name: "Walk-in Closet", nameEn: "Walk-in Closet", category: "bedroom", sortOrder: 4 },
        { name: "Vestidor", nameEn: "Dressing Room", category: "bedroom", sortOrder: 5 },
        // Sala/Estar (Living)
        { name: "Sala Amueblada", nameEn: "Furnished Living Room", category: "living", sortOrder: 1 },
        { name: "Comedor", nameEn: "Dining Area", category: "living", sortOrder: 2 },
        { name: "Smart TV", nameEn: "Smart TV", category: "living", sortOrder: 3 },
        { name: "Internet/WiFi", nameEn: "Internet/WiFi", category: "living", sortOrder: 4 },
        { name: "Cable/Streaming", nameEn: "Cable/Streaming", category: "living", sortOrder: 5 },
        // Exterior
        { name: "Balcón", nameEn: "Balcony", category: "exterior", sortOrder: 1 },
        { name: "Terraza", nameEn: "Terrace", category: "exterior", sortOrder: 2 },
        { name: "Rooftop Privado", nameEn: "Private Rooftop", category: "exterior", sortOrder: 3 },
        { name: "Jardín Privado", nameEn: "Private Garden", category: "exterior", sortOrder: 4 },
        { name: "Alberca Privada", nameEn: "Private Pool", category: "exterior", sortOrder: 5 },
      ];

      // Default amenities (40 items)
      const defaultAmenities = [
        // Áreas Comunes (Common Areas)
        { name: "Alberca", nameEn: "Swimming Pool", category: "common_areas", sortOrder: 1 },
        { name: "Gimnasio", nameEn: "Gym", category: "common_areas", sortOrder: 2 },
        { name: "Área de BBQ/Asador", nameEn: "BBQ Area", category: "common_areas", sortOrder: 3 },
        { name: "Palapa", nameEn: "Palapa", category: "common_areas", sortOrder: 4 },
        { name: "Rooftop Común", nameEn: "Common Rooftop", category: "common_areas", sortOrder: 5 },
        { name: "Jardín Común", nameEn: "Common Garden", category: "common_areas", sortOrder: 6 },
        { name: "Área de Yoga", nameEn: "Yoga Area", category: "common_areas", sortOrder: 7 },
        { name: "Sala de Eventos", nameEn: "Event Room", category: "common_areas", sortOrder: 8 },
        { name: "Coworking", nameEn: "Coworking Space", category: "common_areas", sortOrder: 9 },
        { name: "Business Center", nameEn: "Business Center", category: "common_areas", sortOrder: 10 },
        { name: "Kids Club", nameEn: "Kids Club", category: "common_areas", sortOrder: 11 },
        { name: "Área de Juegos Infantiles", nameEn: "Playground", category: "common_areas", sortOrder: 12 },
        { name: "Cancha de Tenis", nameEn: "Tennis Court", category: "common_areas", sortOrder: 13 },
        { name: "Cancha de Paddle", nameEn: "Paddle Court", category: "common_areas", sortOrder: 14 },
        { name: "Pet Friendly", nameEn: "Pet Friendly", category: "common_areas", sortOrder: 15 },
        // Seguridad (Security)
        { name: "Seguridad 24/7", nameEn: "24/7 Security", category: "security", sortOrder: 1 },
        { name: "Caseta de Vigilancia", nameEn: "Security Booth", category: "security", sortOrder: 2 },
        { name: "Cámaras de Seguridad", nameEn: "Security Cameras", category: "security", sortOrder: 3 },
        { name: "Control de Acceso", nameEn: "Access Control", category: "security", sortOrder: 4 },
        { name: "Acceso con Tarjeta/Llave", nameEn: "Key Card Access", category: "security", sortOrder: 5 },
        { name: "Intercomunicador", nameEn: "Intercom", category: "security", sortOrder: 6 },
        { name: "Portero/Conserje", nameEn: "Doorman/Concierge", category: "security", sortOrder: 7 },
        // Estacionamiento (Parking)
        { name: "Estacionamiento Privado", nameEn: "Private Parking", category: "parking", sortOrder: 1 },
        { name: "Estacionamiento Techado", nameEn: "Covered Parking", category: "parking", sortOrder: 2 },
        { name: "Estacionamiento para Visitas", nameEn: "Guest Parking", category: "parking", sortOrder: 3 },
        { name: "Estacionamiento para Bicicletas", nameEn: "Bicycle Parking", category: "parking", sortOrder: 4 },
        { name: "Cargador para Auto Eléctrico", nameEn: "EV Charger", category: "parking", sortOrder: 5 },
        // Servicios (Services)
        { name: "Elevador", nameEn: "Elevator", category: "services", sortOrder: 1 },
        { name: "Área de Paquetería", nameEn: "Package Locker", category: "services", sortOrder: 2 },
        { name: "Lavandería Común", nameEn: "Common Laundry", category: "services", sortOrder: 3 },
        { name: "Recolección de Basura", nameEn: "Garbage Collection", category: "services", sortOrder: 4 },
        { name: "Mantenimiento Incluido", nameEn: "Maintenance Included", category: "services", sortOrder: 5 },
        { name: "Agua Incluida", nameEn: "Water Included", category: "services", sortOrder: 6 },
        { name: "Gas Incluido", nameEn: "Gas Included", category: "services", sortOrder: 7 },
        { name: "Internet Incluido", nameEn: "Internet Included", category: "services", sortOrder: 8 },
        // Ubicación (Location)
        { name: "Calle Asfaltada", nameEn: "Paved Street", category: "location", sortOrder: 1 },
        { name: "Cerca de Playa", nameEn: "Near Beach", category: "location", sortOrder: 2 },
        { name: "Cerca de Centro", nameEn: "Near Downtown", category: "location", sortOrder: 3 },
        { name: "Cerca de Supermercado", nameEn: "Near Supermarket", category: "location", sortOrder: 4 },
        { name: "Transporte Público Cercano", nameEn: "Near Public Transit", category: "location", sortOrder: 5 },
      ];

      // Check if already seeded
      const existingChars = await db.select()
        .from(externalAgencyUnitCharacteristics)
        .where(eq(externalAgencyUnitCharacteristics.agencyId, agencyId))
        .limit(1);

      const existingAmenities = await db.select()
        .from(externalAgencyAmenities)
        .where(eq(externalAgencyAmenities.agencyId, agencyId))
        .limit(1);

      let charsCreated = 0;
      let amenitiesCreated = 0;

      if (existingChars.length === 0) {
        await db.insert(externalAgencyUnitCharacteristics)
          .values(defaultCharacteristics.map(c => ({ ...c, agencyId })));
        charsCreated = defaultCharacteristics.length;
      }

      if (existingAmenities.length === 0) {
        await db.insert(externalAgencyAmenities)
          .values(defaultAmenities.map(a => ({ ...a, agencyId })));
        amenitiesCreated = defaultAmenities.length;
      }

      await createAuditLog(req, "create", "seed_characteristics_amenities", agencyId, `Seeded ${charsCreated} characteristics and ${amenitiesCreated} amenities`);
      
      res.json({
        message: "Seed completed",
        characteristicsCreated: charsCreated,
        amenitiesCreated: amenitiesCreated,
        alreadyExisted: {
          characteristics: existingChars.length > 0,
          amenities: existingAmenities.length > 0,
        }
      });
    } catch (error: any) {
      console.error("Error seeding characteristics and amenities:", error);
      handleGenericError(res, error);
    }
  });


  // ============================================================================
  app.get("/api/external/quotations", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const quotations = await storage.getExternalQuotations(agencyId);
      res.json(quotations);
    } catch (error: any) {
      console.error("Error fetching quotations:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/quotations/:id - Get specific quotation
  app.get("/api/external/quotations/:id", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const quotation = await storage.getExternalQuotationById(id, agencyId);
      if (!quotation) {
        return res.status(404).json({ message: "Quotation not found" });
      }

      res.json(quotation);
    } catch (error: any) {
      console.error("Error fetching quotation:", error);
      handleGenericError(res, error);
    }
  });

  // POST /api/external/quotations - Create new quotation
  app.post("/api/external/quotations", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const quotationData = insertExternalQuotationSchema.parse({
        ...req.body,
        agencyId,
        createdBy: req.user.id,
      });

      const quotation = await storage.createExternalQuotation(quotationData);

      await createAuditLog(req, "create", "external_quotation", quotation.id, "Created quotation");
      res.status(201).json(quotation);
    } catch (error: any) {
      console.error("Error creating quotation:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/quotations/:id - Update quotation
  app.patch("/api/external/quotations/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const updates = updateExternalQuotationSchema.parse(req.body);
      const quotation = await storage.updateExternalQuotation(id, agencyId, updates);

      await createAuditLog(req, "update", "external_quotation", id, "Updated quotation");
      res.json(quotation);
    } catch (error: any) {
      console.error("Error updating quotation:", error);
      if (error.name === "ZodError") {
        return handleZodError(res, error);
      }
      if (error instanceof NotFoundError) {
        return res.status(404).json({ message: error.message });
      }
      handleGenericError(res, error);
    }
  });

  // DELETE /api/external/quotations/:id - Delete quotation
  app.delete("/api/external/quotations/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      await storage.deleteExternalQuotation(id, agencyId);

      await createAuditLog(req, "delete", "external_quotation", id, "Deleted quotation");
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting quotation:", error);
      if (error instanceof NotFoundError) {
        return res.status(404).json({ message: error.message });
      }
      handleGenericError(res, error);
    }
  });

  // PATCH /api/external/quotations/:id/status - Update quotation status
  app.patch("/api/external/quotations/:id/status", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      if (!status || !['draft', 'sent', 'approved', 'rejected', 'converted_to_ticket'].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const quotation = await storage.updateExternalQuotationStatus(id, agencyId, status);

      await createAuditLog(req, "update", "external_quotation", id, `Updated quotation status to ${status}`);
      res.json(quotation);
    } catch (error: any) {
      console.error("Error updating quotation status:", error);
      if (error instanceof NotFoundError) {
        return res.status(404).json({ message: error.message });
      }
      if (error.message?.includes("Invalid status transition")) {
        return res.status(400).json({ message: error.message });
      }
      handleGenericError(res, error);
    }
  });

  // POST /api/external/quotations/:id/share - Generate share token for quotation
  app.post("/api/external/quotations/:id/share", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { expiresInDays } = req.body;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      // Verify quotation exists and belongs to agency
      const quotation = await storage.getExternalQuotationById(id, agencyId);
      if (!quotation) {
        return res.status(404).json({ message: "Quotation not found" });
      }

      // Generate unique token
      const token = crypto.randomBytes(32).toString('hex');
      
      // Calculate expiration (default 30 days, max 365 days)
      const daysToExpire = Math.min(expiresInDays || 30, 365);
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + daysToExpire);

      const shareToken = await storage.createExternalQuotationToken({
        quotationId: id,
        token,
        expiresAt: daysToExpire ? expiresAt : null,
      });

      await createAuditLog(req, "create", "external_quotation_token", shareToken.id, `Created share link for quotation`);
      res.status(201).json({
        token: shareToken.token,
        expiresAt: shareToken.expiresAt,
        publicUrl: `/quotations/view/${shareToken.token}`,
      });
    } catch (error: any) {
      console.error("Error creating share token:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/public/external/quotations/:token - Public endpoint to view quotation
  app.get("/api/public/external/quotations/:token", async (req: any, res) => {
    try {
      const { token } = req.params;
      
      const result = await storage.getExternalQuotationByToken(token);
      
      if (!result) {
        return res.status(404).json({ message: "Quotation not found or link has expired" });
      }

      // Increment access count
      await storage.incrementQuotationTokenAccess(result.token.id);

      res.json(result.quotation);
    } catch (error: any) {
      console.error("Error fetching public quotation:", error);
      handleGenericError(res, error);
    }
  });

  // GET /api/external/quotations/:id/pdf - Generate PDF for quotation
  app.get("/api/external/quotations/:id/pdf", isAuthenticated, requireRole(EXTERNAL_ALL_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      // Get quotation
      const quotation = await storage.getExternalQuotationById(id, agencyId);
      if (!quotation) {
        return res.status(404).json({ message: "Quotation not found" });
      }

      // Get agency details
      const agency = await storage.getExternalAgency(agencyId);
      if (!agency) {
        return res.status(404).json({ message: "Agency not found" });
      }

      // Prepare agency data for PDF
      const agencyData = {
        name: agency.name,
        contact: agency.phone || agency.email || undefined,
      };

      // Generate PDF
      const pdfBuffer = await generateQuotationPDF(quotation, agencyData);

      // Set headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="cotizacion-${id}.pdf"`);
      res.send(pdfBuffer);

      await createAuditLog(req, "view", "external_quotation", id, "Generated PDF for quotation");
    } catch (error: any) {
      console.error("Error generating quotation PDF:", error);
      if (error instanceof NotFoundError) {
        return res.status(404).json({ message: error.message });
      }
      handleGenericError(res, error);
    }
  });

  // POST /api/external/quotations/:id/convert-to-ticket - Convert accepted quotation to maintenance ticket
  app.post("/api/external/quotations/:id/convert-to-ticket", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { id } = req.params;
      const agencyId = await getUserAgencyId(req);
      
      if (!agencyId) {
        return res.status(403).json({ message: "User is not assigned to any agency" });
      }

      const quotation = await storage.getExternalQuotationById(id, agencyId);
      if (!quotation) {
        return res.status(404).json({ message: "Quotation not found" });
      }

      if (quotation.status !== "approved") {
        return res.status(400).json({ message: "Solo se pueden convertir cotizaciones aceptadas" });
      }

      if ((quotation as any).convertedTicketId) {
        return res.status(400).json({ message: "Esta cotización ya fue convertida a ticket" });
      }

      const services = typeof quotation.services === 'string' 
        ? JSON.parse(quotation.services) 
        : quotation.services;
      
      const servicesDescription = services.map((s: any) => 
        `- ${s.name}: ${s.quantity} x ${s.unitPrice} = ${s.subtotal}`
      ).join('\n');

      const ticketData = {
        title: quotation.title,
        description: quotation.description || quotation.title,
        category: 'general' as const,
        priority: 'medium' as const,
        status: 'open' as const,
        agencyId,
        propertyId: quotation.propertyId || null,
        unitId: quotation.unitId || null,
        estimatedCost: quotation.total,
        quotedTotal: quotation.total,
        quotedAdminFee: quotation.adminFee,
        quotedServices: services,
        quotationId: quotation.id,
        notes: `Creado desde cotización: ${quotation.quotationNumber}\n\nServicios:\n${servicesDescription}\n\n${(quotation as any).solutionDescription ? `Solución propuesta:\n${(quotation as any).solutionDescription}\n\n` : ''}Notas: ${quotation.notes || 'N/A'}`,
        createdBy: req.user.id,
      };

      const ticket = await storage.createExternalMaintenanceTicket(ticketData);

      await storage.updateExternalQuotation(id, agencyId, { 
        convertedTicketId: ticket.id,
        status: 'converted_to_ticket' 
      });

      await createAuditLog(req, "create", "external_maintenance_ticket", ticket.id, `Converted from quotation ${quotation.quotationNumber}`);
      
      res.status(201).json({ 
        ticket,
        message: "Cotización convertida a ticket exitosamente" 
      });
    } catch (error: any) {
      console.error("Error converting quotation to ticket:", error);
      if (error instanceof NotFoundError) {
        return res.status(404).json({ message: error.message });
      }
      handleGenericError(res, error);
    }
  });

  // Register portal routes for tenant/owner portals
  registerPortalRoutes(
    app,
    handleGenericError,
    isAuthenticated,
    requireRole,
    EXTERNAL_ADMIN_ROLES,
    getUserAgencyId,
    createAuditLog
  );

  const httpServer = createServer(app);
  const sessionMiddleware = getSession();
  
  // WebSocket setup for real-time chat
  const wss = new WebSocketServer({ server: httpServer, path: '/ws/chat' });
  
  wss.on('connection', async (ws, req) => {
    console.log('WebSocket connection attempt');
    
    // Parse session from cookies
    let userId: string | null = null;
    
    try {
      const cookies = req.headers.cookie;
      if (!cookies) {
        console.error('WebSocket: No cookies found');
        ws.close(1008, 'Unauthorized: No session');
        return;
      }
      
      const parsedCookies = parseCookie(cookies);
      const sessionId = parsedCookies['connect.sid']?.split('.')[0]?.substring(2);
      
      if (!sessionId) {
        console.error('WebSocket: No session ID found');
        ws.close(1008, 'Unauthorized: No session');
        return;
      }
      
      // Get session from store
      const sessionStore = (sessionMiddleware as any).store;
      const session: any = await new Promise((resolve, reject) => {
        sessionStore.get(sessionId, (err: any, session: any) => {
          if (err) reject(err);
          else resolve(session);
        });
      });
      
      if (!session) {
        console.error('WebSocket: Session not found');
        ws.close(1008, 'Unauthorized: Invalid session');
        return;
      }
      
      // Extract user ID from session
      if (session.adminUser) {
        userId = session.adminUser.id;
      } else if (session.userId) {
        userId = session.userId;
      } else if (session.passport?.user?.claims?.sub) {
        userId = session.passport.user.claims.sub;
      }
      
      if (!userId) {
        console.error('WebSocket: No user ID in session');
        ws.close(1008, 'Unauthorized: No user');
        return;
      }
      
      console.log(`WebSocket: User ${userId} authenticated`);
    } catch (error) {
      console.error('WebSocket authentication error:', error);
      ws.close(1008, 'Unauthorized: Authentication failed');
      return;
    }
    
    let currentConversationId: string | null = null;
    
    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        
        if (message.type === 'join_conversation') {
          const conversationId = message.conversationId;
          
          if (!conversationId) {
            ws.send(JSON.stringify({ type: 'error', message: 'Missing conversation ID' }));
            return;
          }
          
          // Verify user is a participant in this conversation
          try {
            const participants = await storage.getChatParticipants(conversationId);
            const isParticipant = participants.some(p => p.userId === userId);
            
            if (!isParticipant) {
              console.error(`WebSocket: User ${userId} not authorized for conversation ${conversationId}`);
              ws.send(JSON.stringify({ type: 'error', message: 'Not authorized for this conversation' }));
              return;
            }
            
            currentConversationId = conversationId;
            
            if (!wsClients.has(conversationId)) {
              wsClients.set(conversationId, new Set());
            }
            wsClients.get(conversationId)!.add(ws);
            
            console.log(`WebSocket: User ${userId} joined conversation ${currentConversationId}`);
            ws.send(JSON.stringify({ type: 'joined', conversationId: currentConversationId }));
          } catch (error) {
            console.error('WebSocket: Error verifying participant:', error);
            ws.send(JSON.stringify({ type: 'error', message: 'Failed to verify authorization' }));
          }
        }
      } catch (error) {
        console.error('Error processing WebSocket message:', error);
        ws.send(JSON.stringify({ type: 'error', message: 'Invalid message format' }));
      }
    });
    
    ws.on('close', () => {
      if (currentConversationId) {
        if (wsClients.has(currentConversationId)) {
          wsClients.get(currentConversationId)!.delete(ws);
          
          if (wsClients.get(currentConversationId)!.size === 0) {
            wsClients.delete(currentConversationId);
          }
        }
      }
      console.log(`WebSocket: User ${userId} disconnected`);
    });
    
    ws.on('error', (error) => {
      console.error('WebSocket error:', error);
    });
  });
  

  // GET /api/public/property/:agencySlug/:unitSlug - Resolve friendly URL to property
  app.get("/api/public/property/:agencySlug/:unitSlug", async (req, res) => {
    try {
      const { agencySlug, unitSlug } = req.params;
      
      // Helper to generate slug from string
      const generateSlug = (str: string) => {
        return str
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/(^-|-$)/g, "");
      };
      
      // Find agency by slug or generated slug from name
      const agencies = await db
        .select()
        .from(externalAgencies)
        .where(eq(externalAgencies.isActive, true));
      
      const matchedAgency = agencies.find(a => {
        const slug = a.slug || generateSlug(a.name);
        return slug === agencySlug;
      });
      
      if (!matchedAgency) {
        return res.status(404).json({ error: "Agency not found" });
      }
      
      // Find unit by slug or generated slug
      const units = await db
        .select()
        .from(externalUnits)
        .where(and(
          eq(externalUnits.agencyId, matchedAgency.id),
          eq(externalUnits.isActive, true),
          eq(externalUnits.publishStatus, "approved")
        ));
      
      const matchedUnit = units.find(u => {
        const unitTitle = u.title || `${u.propertyType || 'propiedad'}-${u.unitNumber}`;
        const slug = u.slug || generateSlug(unitTitle);
        return slug === unitSlug;
      });
      
      if (!matchedUnit) {
        return res.status(404).json({ error: "Property not found" });
      }
      
      res.json({ unitId: matchedUnit.id });
    } catch (error: any) {
      console.error("Error resolving property URL:", error);
      res.status(500).json({ error: error.message || "Error resolving property URL" });
    }
  });


  // =====================================================
  // SELLER MANAGEMENT VALIDATION SCHEMAS
  // =====================================================
  const createSellerProfileSchema = z.object({
    userId: z.string().trim().min(1),
    status: z.string().trim().min(1).optional(),
    commissionRate: z.string().trim().optional(),
    hireDate: z.string().trim().optional(),
    notes: z.string().trim().optional(),
  });

  const updateSellerProfileSchema = z.object({
    status: z.string().trim().optional(),
    commissionRate: z.string().trim().optional(),
    hireDate: z.string().trim().optional(),
    terminationDate: z.string().trim().optional(),
    notes: z.string().trim().optional(),
  });

  const createCommissionSchema = z.object({
    sellerId: z.string().trim().min(1),
    amount: z.string().trim().min(1),
    commissionType: z.string().trim().min(1),
    description: z.string().trim().optional(),
    contractId: z.string().trim().optional(),
  });

  const updateCommissionSchema = z.object({
    amount: z.string().trim().optional(),
    commissionType: z.string().trim().optional(),
    description: z.string().trim().optional(),
    isPaid: z.boolean().optional(),
    paidAt: z.string().trim().optional(),
    payoutId: z.string().trim().optional(),
  });

  const createPayoutSchema = z.object({
    sellerId: z.string().trim().min(1),
    amount: z.string().trim().min(1),
    paymentMethod: z.string().trim().optional(),
    notes: z.string().trim().optional(),
    commissionIds: z.array(z.string().trim().min(1)).optional(),
  });

  const updatePayoutSchema = z.object({
    amount: z.string().trim().optional(),
    paymentMethod: z.string().trim().optional(),
    notes: z.string().trim().optional(),
    status: z.string().trim().optional(),
    paymentReference: z.string().trim().optional(),
  });

  const createGoalSchema = z.object({
    sellerId: z.string().trim().min(1).optional(),
    goalType: z.string().trim().min(1),
    target: z.coerce.number().finite(),
    startDate: z.string().trim().min(1),
    endDate: z.string().trim().min(1),
    isActive: z.boolean().optional(),
  });

  const updateGoalSchema = z.object({
    goalType: z.string().trim().optional(),
    target: z.coerce.number().finite().optional(),
    startDate: z.string().trim().optional(),
    endDate: z.string().trim().optional(),
    isActive: z.boolean().optional(),
  });

  // =====================================================
  // SELLER MANAGEMENT ENDPOINTS (Admin Dashboard)
  // =====================================================

  // GET /api/external/sellers - Get all sellers for agency with stats
  app.get("/api/external/sellers", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Get all seller profiles for this agency
      const profiles = await storage.getExternalSellerProfiles(agencyId, {
        status: req.query.status as string | undefined
      });

      // Get user info and stats for each seller
      const sellersWithStats = await Promise.all(profiles.map(async (profile) => {
        const user = await storage.getUser(profile.userId);
        const stats = await storage.getSellerStats(agencyId, profile.userId);
        
        return {
          ...profile,
          user: user ? {
            id: user.id,
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email,
            profileImageUrl: user.profileImageUrl
          } : null,
          stats
        };
      }));

      res.json(sellersWithStats);
    } catch (error: any) {
      console.error("Error fetching sellers:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/sellers/:id - Get specific seller with details
  app.get("/api/external/sellers/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const profile = await storage.getExternalSellerProfile(req.params.id);
      if (!profile || profile.agencyId !== agencyId) {
        return res.status(404).json({ message: "Seller not found" });
      }

      const user = await storage.getUser(profile.userId);
      const stats = await storage.getSellerStats(agencyId, profile.userId);
      const goals = await storage.getSellerGoals(agencyId, { sellerId: profile.userId, isActive: true });
      const commissions = await storage.getExternalSellerCommissions(agencyId, { sellerProfileId: profile.id });
      const payouts = await storage.getExternalSellerPayouts(agencyId, { sellerProfileId: profile.id });

      res.json({
        ...profile,
        user: user ? {
          id: user.id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          phone: user.phone,
          profileImageUrl: user.profileImageUrl
        } : null,
        stats,
        goals,
        commissions,
        payouts
      });
    } catch (error: any) {
      console.error("Error fetching seller:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/sellers - Create seller profile
  app.post("/api/external/sellers", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = createSellerProfileSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }
      const { userId, ...profileData } = parsed.data;

      // Check if profile already exists
      const existing = await storage.getExternalSellerProfileByUser(agencyId, userId);
      if (existing) {
        return res.status(400).json({ message: "Seller profile already exists for this user" });
      }

      const profile = await storage.createExternalSellerProfile({
        ...profileData,
        agencyId,
        userId,
        createdBy: req.user?.id
      });

      res.status(201).json(profile);
    } catch (error: any) {
      console.error("Error creating seller profile:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/sellers/:id - Update seller profile
  app.patch("/api/external/sellers/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = updateSellerProfileSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }

      const profile = await storage.getExternalSellerProfile(req.params.id);
      if (!profile || profile.agencyId !== agencyId) {
        return res.status(404).json({ message: "Seller not found" });
      }

      const updated = await storage.updateExternalSellerProfile(req.params.id, parsed.data);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating seller:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/sellers/:id - Delete seller profile
  app.delete("/api/external/sellers/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const profile = await storage.getExternalSellerProfile(req.params.id);
      if (!profile || profile.agencyId !== agencyId) {
        return res.status(404).json({ message: "Seller not found" });
      }

      await storage.deleteExternalSellerProfile(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting seller:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/sellers/:id/stats - Get seller statistics
  app.get("/api/external/sellers/:id/stats", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const profile = await storage.getExternalSellerProfile(req.params.id);
      if (!profile || profile.agencyId !== agencyId) {
        return res.status(404).json({ message: "Seller not found" });
      }

      const startDate = req.query.startDate ? new Date(req.query.startDate as string) : undefined;
      const endDate = req.query.endDate ? new Date(req.query.endDate as string) : undefined;

      const stats = await storage.getSellerStats(agencyId, profile.userId, startDate, endDate);
      res.json(stats);
    } catch (error: any) {
      console.error("Error fetching seller stats:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // =====================================================
  // SELLER COMMISSIONS ENDPOINTS
  // =====================================================

  // GET /api/external/commissions - Get all commissions
  app.get("/api/external/commissions", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const commissions = await storage.getExternalSellerCommissions(agencyId, {
        sellerId: req.query.sellerId as string | undefined,
        isPaid: req.query.isPaid === 'true' ? true : req.query.isPaid === 'false' ? false : undefined
      });

      res.json(commissions);
    } catch (error: any) {
      console.error("Error fetching commissions:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/commissions - Create commission record
  app.post("/api/external/commissions", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = createCommissionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }

      // Verify seller belongs to agency
      const sellerProfile = await storage.getExternalSellerProfileByUser(agencyId, parsed.data.sellerId);
      if (!sellerProfile) {
        return res.status(404).json({ message: "Seller not found in this agency" });
      }

      const commission = await storage.createExternalSellerCommission({
        ...parsed.data,
        agencyId,
        createdBy: req.user?.id
      });

      res.status(201).json(commission);
    } catch (error: any) {
      console.error("Error creating commission:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/commissions/:id - Update commission
  app.patch("/api/external/commissions/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = updateCommissionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }

      const commission = await storage.getExternalSellerCommission(req.params.id);
      if (!commission || commission.agencyId !== agencyId) {
        return res.status(404).json({ message: "Commission not found" });
      }

      const updated = await storage.updateExternalSellerCommission(req.params.id, parsed.data);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating commission:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // =====================================================
  // SELLER PAYOUTS ENDPOINTS
  // =====================================================

  // GET /api/external/payouts - Get all payouts
  app.get("/api/external/payouts", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const payouts = await storage.getExternalSellerPayouts(agencyId, {
        sellerId: req.query.sellerId as string | undefined,
        status: req.query.status as string | undefined
      });

      res.json(payouts);
    } catch (error: any) {
      console.error("Error fetching payouts:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/payouts - Create payout
  app.post("/api/external/payouts", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = createPayoutSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }

      // Verify seller belongs to agency
      const sellerProfile = await storage.getExternalSellerProfileByUser(agencyId, parsed.data.sellerId);
      if (!sellerProfile) {
        return res.status(404).json({ message: "Seller not found in this agency" });
      }

      // Verify all commissions belong to agency and seller
      if (parsed.data.commissionIds && parsed.data.commissionIds.length > 0) {
        for (const commissionId of parsed.data.commissionIds) {
          const commission = await storage.getExternalSellerCommission(commissionId);
          if (!commission || commission.agencyId !== agencyId || commission.sellerId !== parsed.data.sellerId) {
            return res.status(404).json({ message: "Commission not found or does not belong to seller" });
          }
        }
      }

      const payout = await storage.createExternalSellerPayout({
        ...parsed.data,
        agencyId,
        createdBy: req.user?.id
      });

      // Mark associated commissions as paid if provided
      if (parsed.data.commissionIds && parsed.data.commissionIds.length > 0) {
        for (const commissionId of parsed.data.commissionIds) {
          await storage.updateExternalSellerCommission(commissionId, {
            payoutId: payout.id,
            isPaid: true,
            paidAt: new Date()
          });
        }
      }

      res.status(201).json(payout);
    } catch (error: any) {
      console.error("Error creating payout:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/payouts/:id - Update payout status
  app.patch("/api/external/payouts/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = updatePayoutSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }

      const payout = await storage.getExternalSellerPayout(req.params.id);
      if (!payout || payout.agencyId !== agencyId) {
        return res.status(404).json({ message: "Payout not found" });
      }

      const updates: any = { ...parsed.data };
      
      // Handle status transitions
      if (parsed.data.status === 'approved' && payout.status !== 'approved') {
        updates.approvedBy = req.user?.id;
        updates.approvedAt = new Date();
      }
      if (parsed.data.status === 'paid' && payout.status !== 'paid') {
        updates.paidBy = req.user?.id;
        updates.paidAt = new Date();
      }

      const updated = await storage.updateExternalSellerPayout(req.params.id, updates);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating payout:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // =====================================================
  // SELLER GOALS ENDPOINTS
  // =====================================================

  // GET /api/external/goals - Get all goals
  app.get("/api/external/goals", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const goals = await storage.getSellerGoals(agencyId, {
        sellerId: req.query.sellerId as string | undefined,
        goalType: req.query.goalType as string | undefined,
        isActive: req.query.isActive === 'true' ? true : req.query.isActive === 'false' ? false : undefined
      });

      // Add progress calculation for each goal
      const goalsWithProgress = await Promise.all(goals.map(async (goal) => {
        if (!goal.sellerId) return { ...goal, progress: 0, progressPercent: 0 };
        
        const stats = await storage.getSellerStats(
          agencyId, 
          goal.sellerId, 
          goal.startDate, 
          goal.endDate
        );
        
        let current = 0;
        switch (goal.goalType) {
          case 'leads':
            current = stats.totalLeads;
            break;
          case 'conversions':
            current = stats.convertedLeads;
            break;
          case 'revenue':
            current = stats.totalRevenue;
            break;
          case 'showings':
            current = stats.totalShowings;
            break;
        }
        
        return {
          ...goal,
          progress: current,
          progressPercent: Math.min(100, Math.round((current / goal.target) * 100))
        };
      }));

      res.json(goalsWithProgress);
    } catch (error: any) {
      console.error("Error fetching goals:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/goals - Create goal
  app.post("/api/external/goals", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = createGoalSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }

      // Verify seller belongs to agency if specified
      if (parsed.data.sellerId) {
        const sellerProfile = await storage.getExternalSellerProfileByUser(agencyId, parsed.data.sellerId);
        if (!sellerProfile) {
          return res.status(404).json({ message: "Seller not found in this agency" });
        }
      }

      // Map goalType to bilingual names
      const goalTypeNames: Record<string, { es: string, en: string }> = {
        leads: { es: "Leads", en: "Leads" },
        conversions: { es: "Conversiones", en: "Conversions" },
        revenue: { es: "Ingresos", en: "Revenue" },
        showings: { es: "Visitas", en: "Showings" },
        contracts: { es: "Contratos", en: "Contracts" }
      };
      
      const goalNames = goalTypeNames[parsed.data.goalType] || { es: "Meta", en: "Goal" };
      
      const goal = await storage.createSellerGoal({
        sellerId: parsed.data.sellerId,
        goalType: parsed.data.goalType as any,
        target: parsed.data.target,
        startDate: new Date(parsed.data.startDate),
        endDate: new Date(parsed.data.endDate),
        isActive: parsed.data.isActive ?? true,
        period: "monthly",
        nameEs: goalNames.es,
        nameEn: goalNames.en,
        agencyId,
        createdBy: req.user?.id
      });

      res.status(201).json(goal);
    } catch (error: any) {
      console.error("Error creating goal:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/goals/:id - Update goal
  app.patch("/api/external/goals/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Validate request body
      const parsed = updateGoalSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parsed.error.errors });
      }

      const goal = await storage.getSellerGoal(req.params.id);
      if (!goal || goal.agencyId !== agencyId) {
        return res.status(404).json({ message: "Goal not found" });
      }

      const updated = await storage.updateSellerGoal(req.params.id, parsed.data);
      res.json(updated);
    } catch (error: any) {
      console.error("Error updating goal:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/goals/:id - Delete goal
  app.delete("/api/external/goals/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const goal = await storage.getSellerGoal(req.params.id);
      if (!goal || goal.agencyId !== agencyId) {
        return res.status(404).json({ message: "Goal not found" });
      }

      await storage.deleteSellerGoal(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting goal:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/sellers-leaderboard - Get sellers ranking
  app.get("/api/external/sellers-leaderboard", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const profiles = await storage.getExternalSellerProfiles(agencyId, { status: 'active' });
      
      const leaderboard = await Promise.all(profiles.map(async (profile) => {
        const user = await storage.getUser(profile.userId);
        const stats = await storage.getSellerStats(agencyId, profile.userId);
        
        return {
          sellerId: profile.id,
          userId: profile.userId,
          name: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : 'Unknown',
          profileImageUrl: user?.profileImageUrl,
          totalLeads: stats.totalLeads,
          convertedLeads: stats.convertedLeads,
          conversionRate: stats.totalLeads > 0 ? Math.round((stats.convertedLeads / stats.totalLeads) * 100) : 0,
          totalContracts: stats.totalContracts,
          totalRevenue: stats.totalRevenue,
          totalCommissions: stats.totalCommissions,
          unpaidCommissions: stats.unpaidCommissions
        };
      }));

      // Sort by total revenue (can be changed based on query param)
      const sortBy = req.query.sortBy || 'totalRevenue';
      leaderboard.sort((a: any, b: any) => b[sortBy] - a[sortBy]);

      res.json(leaderboard);
    } catch (error: any) {
      console.error("Error fetching leaderboard:", error);
      res.status(500).json({ message: error.message });
    }
  });


  // ==========================================
  // Property Prospects - Recruitment System
  // ==========================================

  // GET /api/external/property-prospects - Get all property prospects for agency
  app.get("/api/external/property-prospects", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      const isSeller = userRole === 'external_agency_seller';

      const filters: any = {
        search: req.query.search as string,
        status: req.query.status as string,
        sellerId: isSeller ? userId : (req.query.sellerId as string),
        sortField: req.query.sortField as string,
        sortOrder: req.query.sortOrder as 'asc' | 'desc',
        limit: req.query.limit ? parseInt(req.query.limit as string) : 50,
        offset: req.query.offset ? parseInt(req.query.offset as string) : 0,
      };

      const [prospects, total] = await Promise.all([
        storage.getExternalPropertyProspects(agencyId, filters),
        storage.getExternalPropertyProspectsCount(agencyId, { 
          status: filters.status, 
          sellerId: filters.sellerId, 
          search: filters.search 
        })
      ]);

      res.json({ data: prospects, total, limit: filters.limit, offset: filters.offset });
    } catch (error: any) {
      console.error("Error fetching property prospects:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/property-prospects/:id - Get specific property prospect
  app.get("/api/external/property-prospects/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const prospect = await storage.getExternalPropertyProspect(req.params.id);
      if (!prospect || prospect.agencyId !== agencyId) {
        return res.status(404).json({ message: "Prospecto no encontrado" });
      }

      // Sellers can only view their own prospects
      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      if (userRole === 'external_agency_seller' && prospect.sellerId !== userId) {
        return res.status(403).json({ message: "No tienes acceso a este prospecto" });
      }

      res.json(prospect);
    } catch (error: any) {
      console.error("Error fetching property prospect:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/property-prospects - Create new property prospect
  app.post("/api/external/property-prospects", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });
      const userId = req.user?.claims?.sub || req.user?.id;

      const user = await storage.getUser(userId);
      const sellerName = user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined;

      const prospectData = {
        ...req.body,
        agencyId,
        sellerId: userId,
        sellerName,
      };

      const prospect = await storage.createExternalPropertyProspect(prospectData);

      // Create initial activity
      await storage.createExternalPropertyProspectActivity({
        prospectId: prospect.id,
        agencyId,
        activityType: 'created',
        title: 'Prospecto creado',
        description: `Propiedad prospecto registrada por ${sellerName || 'usuario'}`,
        performedBy: userId,
        performedByName: sellerName,
      });

      res.status(201).json(prospect);
    } catch (error: any) {
      console.error("Error creating property prospect:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/property-prospects/:id - Update property prospect
  app.patch("/api/external/property-prospects/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const prospect = await storage.getExternalPropertyProspect(req.params.id);
      if (!prospect || prospect.agencyId !== agencyId) {
        return res.status(404).json({ message: "Prospecto no encontrado" });
      }

      // Sellers can only update their own prospects
      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      if (userRole === 'external_agency_seller' && prospect.sellerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para editar este prospecto" });
      }

      const previousStatus = prospect.status;
      const updated = await storage.updateExternalPropertyProspect(req.params.id, req.body);

      // Log status change if status was updated
      if (req.body.status && req.body.status !== previousStatus) {
        const user = await storage.getUser(userId);
        const userName = user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined;
        
        await storage.createExternalPropertyProspectActivity({
          prospectId: prospect.id,
          agencyId,
          activityType: 'status_changed',
          title: 'Estado actualizado',
          description: `Estado cambiado de "${previousStatus}" a "${req.body.status}"`,
          previousStatus: previousStatus as any,
          newStatus: req.body.status,
          performedBy: userId,
          performedByName: userName,
        });
      }

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating property prospect:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/property-prospects/:id - Delete property prospect
  app.delete("/api/external/property-prospects/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const prospect = await storage.getExternalPropertyProspect(req.params.id);
      if (!prospect || prospect.agencyId !== agencyId) {
        return res.status(404).json({ message: "Prospecto no encontrado" });
      }

      await storage.deleteExternalPropertyProspect(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting property prospect:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/property-prospects/:id/invite - Generate owner invite token
  app.post("/api/external/property-prospects/:id/invite", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const prospect = await storage.getExternalPropertyProspect(req.params.id);
      if (!prospect || prospect.agencyId !== agencyId) {
        return res.status(404).json({ message: "Prospecto no encontrado" });
      }

      // Sellers can only invite for their own prospects
      const userRole = req.user?.cachedRole || req.user?.role;
      const userId = req.user?.claims?.sub || req.user?.id;
      if (userRole === 'external_agency_seller' && prospect.sellerId !== userId) {
        return res.status(403).json({ message: "No tienes permiso para invitar a este propietario" });
      }

      const expiresInHours = req.body.expiresInHours || 48;
      const sentVia = req.body.sentVia || 'whatsapp';
      
      const token = await storage.generateOwnerInviteToken(req.params.id, expiresInHours);

      // Update sent info
      await storage.updateExternalPropertyProspect(req.params.id, {
        ownerInviteSentAt: new Date(),
        ownerInviteSentVia: sentVia,
        status: 'owner_invited',
      });

      // Log activity
      const user = await storage.getUser(userId);
      const userName = user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined;
      
      await storage.createExternalPropertyProspectActivity({
        prospectId: prospect.id,
        agencyId,
        activityType: 'invite_sent',
        title: 'Invitación enviada',
        description: `Link de invitación generado para propietario vía ${sentVia}`,
        details: { channel: sentVia },
        performedBy: userId,
        performedByName: userName,
      });

      // Get agency for slug
      const agency = await storage.getExternalAgency(agencyId);
      const agencySlug = agency?.slug || agencyId;

      res.json({ 
        token,
        url: `/${agencySlug}/owner-registration/${token}`,
        expiresAt: new Date(Date.now() + expiresInHours * 60 * 60 * 1000)
      });
    } catch (error: any) {
      console.error("Error generating owner invite:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/property-prospects/:id/activities - Get activities for a prospect
  app.get("/api/external/property-prospects/:id/activities", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const prospect = await storage.getExternalPropertyProspect(req.params.id);
      if (!prospect || prospect.agencyId !== agencyId) {
        return res.status(404).json({ message: "Prospecto no encontrado" });
      }

      const activities = await storage.getExternalPropertyProspectActivities(req.params.id);
      res.json(activities);
    } catch (error: any) {
      console.error("Error fetching prospect activities:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/property-prospects/:id/activities - Add activity to a prospect
  app.post("/api/external/property-prospects/:id/activities", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const prospect = await storage.getExternalPropertyProspect(req.params.id);
      if (!prospect || prospect.agencyId !== agencyId) {
        return res.status(404).json({ message: "Prospecto no encontrado" });
      }

      const user = await storage.getUser(userId);
      const userName = user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined;

      const activity = await storage.createExternalPropertyProspectActivity({
        ...req.body,
        prospectId: req.params.id,
        agencyId,
        performedBy: userId,
        performedByName: userName,
      });

      // Update last contact date if it's a contact activity
      const contactActivities = ['owner_contacted', 'call_made', 'whatsapp_sent', 'email_sent', 'meeting_completed'];
      if (contactActivities.includes(req.body.activityType)) {
        await storage.updateExternalPropertyProspect(req.params.id, {
          lastContactDate: new Date(),
        });
      }

      res.status(201).json(activity);
    } catch (error: any) {
      console.error("Error creating prospect activity:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/public/owner-registration/:token - Public endpoint to get prospect info for owner registration
  app.get("/api/public/owner-registration/:token", async (req, res) => {
    try {
      const { token } = req.params;
      
      const prospect = await storage.getExternalPropertyProspectByToken(token);
      if (!prospect) {
        return res.status(404).json({ message: "Link inválido o expirado" });
      }

      // Get agency info
      const agency = await storage.getExternalAgency(prospect.agencyId);

      // Return limited info for public page
      res.json({
        prospectId: prospect.id,
        propertyName: prospect.propertyName,
        propertyType: prospect.propertyType,
        address: prospect.address,
        neighborhood: prospect.neighborhood,
        agencyName: agency?.name,
        agencyLogo: agency?.logoUrl,
        sellerName: prospect.sellerName,
      });
    } catch (error: any) {
      console.error("Error fetching prospect for registration:", error);
      res.status(500).json({ message: error.message });
    }
  });


  // ========================================
  // Commission Management Routes
  // ========================================

  // GET /api/external/commissions/profile - Get agency commission profile (defaults)
  app.get("/api/external/commissions/profile", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const profile = await storage.getExternalCommissionProfile(agencyId);
      res.json(profile || null);
    } catch (error: any) {
      console.error("Error fetching commission profile:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/commissions/profile - Create or update agency commission profile
  app.post("/api/external/commissions/profile", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);
      const existingProfile = await storage.getExternalCommissionProfile(agencyId);

      let profile;
      if (existingProfile) {
        const previousValues = { ...existingProfile };
        profile = await storage.updateExternalCommissionProfile(agencyId, req.body);
        
        await storage.createExternalCommissionAuditLog({
          agencyId,
          entityType: 'commission_profile',
          entityId: profile.id,
          action: 'update',
          previousValues,
          newValues: profile,
          changedBy: userId,
          changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
        });
      } else {
        profile = await storage.createExternalCommissionProfile({
          ...req.body,
          agencyId,
          createdBy: userId,
        });
        
        await storage.createExternalCommissionAuditLog({
          agencyId,
          entityType: 'commission_profile',
          entityId: profile.id,
          action: 'create',
          newValues: profile,
          changedBy: userId,
          changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
        });
      }

      res.status(existingProfile ? 200 : 201).json(profile);
    } catch (error: any) {
      console.error("Error saving commission profile:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/commissions/role-overrides - Get all role overrides
  app.get("/api/external/commissions/role-overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const overrides = await storage.getExternalCommissionRoleOverrides(agencyId);
      res.json(overrides);
    } catch (error: any) {
      console.error("Error fetching role overrides:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/commissions/role-overrides - Create role override
  app.post("/api/external/commissions/role-overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const override = await storage.createExternalCommissionRoleOverride({
        ...req.body,
        agencyId,
        createdBy: userId,
      });

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'role_override',
        entityId: override.id,
        action: 'create',
        newValues: override,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.status(201).json(override);
    } catch (error: any) {
      console.error("Error creating role override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/commissions/role-overrides/:id - Update role override
  app.patch("/api/external/commissions/role-overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const overrides = await storage.getExternalCommissionRoleOverrides(agencyId);
      const existing = overrides.find(o => o.id === req.params.id);
      if (!existing) {
        return res.status(404).json({ message: "Override no encontrado" });
      }

      const previousValues = { ...existing };
      const updated = await storage.updateExternalCommissionRoleOverride(req.params.id, req.body);

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'role_override',
        entityId: updated.id,
        action: 'update',
        previousValues,
        newValues: updated,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating role override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/commissions/role-overrides/:id - Delete role override
  app.delete("/api/external/commissions/role-overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const overrides = await storage.getExternalCommissionRoleOverrides(agencyId);
      const existing = overrides.find(o => o.id === req.params.id);
      if (!existing) {
        return res.status(404).json({ message: "Override no encontrado" });
      }

      await storage.deleteExternalCommissionRoleOverride(req.params.id);

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'role_override',
        entityId: req.params.id,
        action: 'delete',
        previousValues: existing,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting role override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/commissions/user-overrides - Get all user overrides
  app.get("/api/external/commissions/user-overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const overrides = await storage.getExternalCommissionUserOverrides(agencyId);
      
      const enrichedOverrides = await Promise.all(overrides.map(async (o) => {
        const user = await storage.getUser(o.userId);
        return {
          ...o,
          userName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : 'Usuario desconocido',
          userRole: user?.role,
        };
      }));
      
      res.json(enrichedOverrides);
    } catch (error: any) {
      console.error("Error fetching user overrides:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/commissions/user-overrides - Create user override
  app.post("/api/external/commissions/user-overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const existing = await storage.getExternalCommissionUserOverride(agencyId, req.body.userId);
      if (existing) {
        return res.status(400).json({ message: "Ya existe una configuración para este usuario" });
      }

      const override = await storage.createExternalCommissionUserOverride({
        ...req.body,
        agencyId,
        createdBy: userId,
      });

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'user_override',
        entityId: override.id,
        action: 'create',
        newValues: override,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.status(201).json(override);
    } catch (error: any) {
      console.error("Error creating user override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/commissions/user-overrides/:id - Update user override
  app.patch("/api/external/commissions/user-overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const overrides = await storage.getExternalCommissionUserOverrides(agencyId);
      const existing = overrides.find(o => o.id === req.params.id);
      if (!existing) {
        return res.status(404).json({ message: "Override no encontrado" });
      }

      const previousValues = { ...existing };
      const updated = await storage.updateExternalCommissionUserOverride(req.params.id, req.body);

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'user_override',
        entityId: updated.id,
        action: 'update',
        previousValues,
        newValues: updated,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating user override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/commissions/user-overrides/:id - Delete user override
  app.delete("/api/external/commissions/user-overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const overrides = await storage.getExternalCommissionUserOverrides(agencyId);
      const existing = overrides.find(o => o.id === req.params.id);
      if (!existing) {
        return res.status(404).json({ message: "Override no encontrado" });
      }

      await storage.deleteExternalCommissionUserOverride(req.params.id);

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'user_override',
        entityId: req.params.id,
        action: 'delete',
        previousValues: existing,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting user override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/commissions/lead-overrides - Get lead/prospect overrides
  app.get("/api/external/commissions/lead-overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { leadId, prospectId, userId } = req.query;
      const overrides = await storage.getExternalCommissionLeadOverrides(agencyId, {
        leadId: leadId as string,
        prospectId: prospectId as string,
        userId: userId as string,
      });

      const enrichedOverrides = await Promise.all(overrides.map(async (o) => {
        const user = await storage.getUser(o.userId);
        let leadName = null;
        let prospectName = null;
        
        if (o.leadId) {
          const lead = await storage.getExternalLead(o.leadId);
          leadName = lead ? `${lead.firstName || ''} ${lead.lastName || ''}`.trim() : null;
        }
        if (o.prospectId) {
          const prospect = await storage.getExternalPropertyProspect(o.prospectId);
          prospectName = prospect?.propertyName || null;
        }
        
        return {
          ...o,
          userName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : 'Usuario desconocido',
          leadName,
          prospectName,
        };
      }));

      res.json(enrichedOverrides);
    } catch (error: any) {
      console.error("Error fetching lead overrides:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/commissions/lead-overrides - Create lead/prospect override
  app.post("/api/external/commissions/lead-overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const override = await storage.createExternalCommissionLeadOverride({
        ...req.body,
        agencyId,
        createdBy: userId,
      });

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'lead_override',
        entityId: override.id,
        action: 'create',
        newValues: override,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.status(201).json(override);
    } catch (error: any) {
      console.error("Error creating lead override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/commissions/lead-overrides/:id - Update lead override
  app.patch("/api/external/commissions/lead-overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const overrides = await storage.getExternalCommissionLeadOverrides(agencyId);
      const existing = overrides.find(o => o.id === req.params.id);
      if (!existing) {
        return res.status(404).json({ message: "Override no encontrado" });
      }

      const previousValues = { ...existing };
      const updated = await storage.updateExternalCommissionLeadOverride(req.params.id, req.body);

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'lead_override',
        entityId: updated.id,
        action: 'update',
        previousValues,
        newValues: updated,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating lead override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/commissions/lead-overrides/:id - Delete lead override
  app.delete("/api/external/commissions/lead-overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);

      const overrides = await storage.getExternalCommissionLeadOverrides(agencyId);
      const existing = overrides.find(o => o.id === req.params.id);
      if (!existing) {
        return res.status(404).json({ message: "Override no encontrado" });
      }

      await storage.deleteExternalCommissionLeadOverride(req.params.id);

      await storage.createExternalCommissionAuditLog({
        agencyId,
        entityType: 'lead_override',
        entityId: req.params.id,
        action: 'delete',
        previousValues: existing,
        changedBy: userId,
        changedByName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : undefined,
      });

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting lead override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/commissions/audit-logs - Get commission audit logs
  app.get("/api/external/commissions/audit-logs", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { entityType, entityId, limit } = req.query;
      const logs = await storage.getExternalCommissionAuditLogs(agencyId, {
        entityType: entityType as string,
        entityId: entityId as string,
        limit: limit ? parseInt(limit as string) : 50,
      });

      res.json(logs);
    } catch (error: any) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/commissions/calculate - Calculate effective commission for a user
  app.post("/api/external/commissions/calculate", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { userId, userRole, commissionType, leadId, prospectId } = req.body;

      if (!userId || !userRole || !commissionType) {
        return res.status(400).json({ message: "Campos requeridos: userId, userRole, commissionType" });
      }

      const result = await storage.calculateEffectiveCommission({
        agencyId,
        userId,
        userRole,
        commissionType,
        leadId,
        prospectId,
      });

      res.json(result);
    } catch (error: any) {
      console.error("Error calculating commission:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/commissions/my-rates - Get current user's commission rates
  app.get("/api/external/commissions/my-rates", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      const userId = req.user?.claims?.sub || req.user?.id;
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);
      const userRole = user?.role || 'external_agency_seller';

      const [rentalRate, listedRate, recruitedRate] = await Promise.all([
        storage.calculateEffectiveCommission({
          agencyId,
          userId,
          userRole,
          commissionType: 'rental',
        }),
        storage.calculateEffectiveCommission({
          agencyId,
          userId,
          userRole,
          commissionType: 'listed_property',
        }),
        storage.calculateEffectiveCommission({
          agencyId,
          userId,
          userRole,
          commissionType: 'recruited_property',
        }),
      ]);

      res.json({
        rental: rentalRate,
        listedProperty: listedRate,
        recruitedProperty: recruitedRate,
      });
    } catch (error: any) {
      console.error("Error fetching my rates:", error);
      res.status(500).json({ message: error.message });
    }
  });


  // =====================================================
  // SELLER COMMISSION RATE MANAGEMENT (Payment Percentages)
  // =====================================================

  // GET /api/external/seller-commission-rates/defaults - Get agency default rates
  app.get("/api/external/seller-commission-rates/defaults", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const defaults = await storage.getSellerCommissionDefaults(agencyId);
      
      // Return defaults with system fallbacks
      const concepts = ['rental_no_referral', 'rental_with_referral', 'property_recruitment', 'broker_referral'];
      const defaultRates: Record<string, number> = {
        rental_no_referral: 50,
        rental_with_referral: 40,
        property_recruitment: 20,
        broker_referral: 10
      };
      
      const result = concepts.map(concept => {
        const existing = defaults.find(d => d.concept === concept);
        if (existing) return existing;
        return {
          id: null,
          agencyId,
          concept,
          rate: String(defaultRates[concept]),
          descriptionEs: null,
          descriptionEn: null,
          updatedBy: null,
          createdAt: null,
          updatedAt: null
        };
      });

      res.json(result);
    } catch (error: any) {
      console.error("Error fetching commission defaults:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PUT /api/external/seller-commission-rates/defaults - Update agency default rates
  app.put("/api/external/seller-commission-rates/defaults", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });
      const userId = req.user?.claims?.sub || req.user?.id;

      const { concept, rate, descriptionEs, descriptionEn } = req.body;
      
      if (!concept || rate === undefined) {
        return res.status(400).json({ message: "concept and rate are required" });
      }

      const validConcepts = ['rental_no_referral', 'rental_with_referral', 'property_recruitment', 'broker_referral'];
      if (!validConcepts.includes(concept)) {
        return res.status(400).json({ message: "Invalid concept" });
      }

      const result = await storage.upsertSellerCommissionDefault({
        agencyId,
        concept,
        rate: String(rate),
        descriptionEs,
        descriptionEn,
        updatedBy: userId
      });

      res.json(result);
    } catch (error: any) {
      console.error("Error updating commission default:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/seller-commission-rates/overrides - Get all overrides
  app.get("/api/external/seller-commission-rates/overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const overrides = await storage.getSellerCommissionOverrides(agencyId);
      
      // Enrich with user data for user overrides
      const enrichedOverrides = await Promise.all(overrides.map(async (o) => {
        if (o.overrideType === 'user' && o.userId) {
          const user = await storage.getUser(o.userId);
          return {
            ...o,
            user: user ? {
              id: user.id,
              firstName: user.firstName,
              lastName: user.lastName,
              email: user.email,
              profileImageUrl: user.profileImageUrl
            } : null
          };
        }
        return { ...o, user: null };
      }));

      res.json(enrichedOverrides);
    } catch (error: any) {
      console.error("Error fetching commission overrides:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/seller-commission-rates/overrides - Create override
  app.post("/api/external/seller-commission-rates/overrides", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });
      const userId = req.user?.claims?.sub || req.user?.id;

      const { concept, overrideType, roleValue, targetUserId, rate, notes } = req.body;
      
      if (!concept || !overrideType || rate === undefined) {
        return res.status(400).json({ message: "concept, overrideType, and rate are required" });
      }

      const validConcepts = ['rental_no_referral', 'rental_with_referral', 'property_recruitment', 'broker_referral'];
      if (!validConcepts.includes(concept)) {
        return res.status(400).json({ message: "Invalid concept" });
      }

      if (overrideType === 'role' && !roleValue) {
        return res.status(400).json({ message: "roleValue is required for role overrides" });
      }

      if (overrideType === 'user' && !targetUserId) {
        return res.status(400).json({ message: "targetUserId is required for user overrides" });
      }

      const result = await storage.createSellerCommissionOverride({
        agencyId,
        concept,
        overrideType,
        roleValue: overrideType === 'role' ? roleValue : null,
        userId: overrideType === 'user' ? targetUserId : null,
        rate: String(rate),
        notes,
        createdBy: userId,
        updatedBy: userId
      });

      res.status(201).json(result);
    } catch (error: any) {
      console.error("Error creating commission override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/seller-commission-rates/overrides/:id - Update override
  app.patch("/api/external/seller-commission-rates/overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });
      const userId = req.user?.claims?.sub || req.user?.id;

      const { rate, notes } = req.body;
      
      const result = await storage.updateSellerCommissionOverride(req.params.id, {
        rate: rate !== undefined ? String(rate) : undefined,
        notes,
        updatedBy: userId
      });

      if (!result) {
        return res.status(404).json({ message: "Override not found" });
      }

      res.json(result);
    } catch (error: any) {
      console.error("Error updating commission override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/seller-commission-rates/overrides/:id - Delete override
  app.delete("/api/external/seller-commission-rates/overrides/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      await storage.deleteSellerCommissionOverride(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting commission override:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/seller-commission-rates/my-rates - Get resolved rates for current user
  app.get("/api/external/seller-commission-rates/my-rates", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      const userId = req.user?.claims?.sub || req.user?.id;
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const user = await storage.getUser(userId);
      const userRole = user?.role || 'external_agency_seller';

      const rates = await storage.getResolvedSellerCommissionRates(agencyId, userId, userRole);
      res.json(rates);
    } catch (error: any) {
      console.error("Error fetching my commission rates:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/seller-commission-rates/user/:userId - Get resolved rates for a specific user (admin only)
  app.get("/api/external/seller-commission-rates/user/:userId", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser || targetUser.externalAgencyId !== agencyId) {
        return res.status(404).json({ message: "User not found in this agency" });
      }

      const userRole = targetUser.role || 'external_agency_seller';
      const rates = await storage.getResolvedSellerCommissionRates(agencyId, req.params.userId, userRole);
      res.json(rates);
    } catch (error: any) {
      console.error("Error fetching user commission rates:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/agency-sellers - Get list of sellers in agency
  app.get("/api/external/agency-sellers", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const sellers = await db.select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        email: users.email,
        role: users.role,
        profileImageUrl: users.profileImageUrl,
        createdAt: users.createdAt
      })
      .from(users)
      .where(and(
        eq(users.externalAgencyId, agencyId),
        or(
          eq(users.role, 'external_agency_seller'),
          eq(users.role, 'external_agency_admin')
        )
      ))
      .orderBy(asc(users.firstName), asc(users.lastName));

      res.json(sellers);
    } catch (error: any) {
      console.error("Error fetching agency sellers:", error);
      res.status(500).json({ message: error.message });
    }
  });



  // EXTERNAL AGENCY TEAM CHAT SYSTEM
  // Real-time messaging, activity notifications, and gamification
  // ==========================================================================

  // GET /api/external/chat/messages - Get chat messages for agency
  app.get("/api/external/chat/messages", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { limit = 50, offset = 0, before } = req.query;
      
      let conditions = [
        eq(externalAgencyChatMessages.agencyId, agencyId),
        eq(externalAgencyChatMessages.isDeleted, false),
      ];

      if (before) {
        conditions.push(lt(externalAgencyChatMessages.createdAt, new Date(before as string)));
      }

      const messages = await db.select()
        .from(externalAgencyChatMessages)
        .leftJoin(externalAgencyChatAttachments, eq(externalAgencyChatMessages.id, externalAgencyChatAttachments.messageId))
        .where(and(...conditions))
        .orderBy(desc(externalAgencyChatMessages.createdAt))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));

      // Group attachments with messages
      const messageMap = new Map();
      for (const row of messages) {
        const msg = row.external_agency_chat_messages;
        const attachment = row.external_agency_chat_attachments;
        
        if (!messageMap.has(msg.id)) {
          messageMap.set(msg.id, { ...msg, attachments: [] });
        }
        if (attachment) {
          messageMap.get(msg.id).attachments.push(attachment);
        }
      }

      res.json(Array.from(messageMap.values()));
    } catch (error: any) {
      console.error("Error fetching chat messages:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/chat/messages - Send a new chat message
  app.post("/api/external/chat/messages", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const userId = req.user?.claims?.sub || req.user?.id;
      const user = await storage.getUser(userId);
      if (!user) return res.status(403).json({ message: "User not found" });

      const { content, messageType = 'text' } = req.body;

      if (!content && messageType === 'text') {
        return res.status(400).json({ message: "Message content is required" });
      }

      const [message] = await db.insert(externalAgencyChatMessages).values({
        agencyId,
        senderId: userId,
        senderName: user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : user.username || 'Unknown',
        senderRole: user.role,
        senderAvatarUrl: user.profilePicture || null,
        messageType,
        content,
        readBy: [userId],
      }).returning();

      // Broadcast to WebSocket clients in the agency room
      broadcastToAgency(agencyId, {
        type: 'chat:message',
        data: message,
      });

      res.status(201).json(message);
    } catch (error: any) {
      console.error("Error sending chat message:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/chat/messages/:id/read - Mark message as read
  app.post("/api/external/chat/messages/:id/read", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const userId = req.user?.claims?.sub || req.user?.id;
      const { id } = req.params;

      const [message] = await db.select()
        .from(externalAgencyChatMessages)
        .where(and(
          eq(externalAgencyChatMessages.id, id),
          eq(externalAgencyChatMessages.agencyId, agencyId)
        ));

      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }

      const readBy = message.readBy || [];
      if (!readBy.includes(userId)) {
        await db.update(externalAgencyChatMessages)
          .set({ readBy: [...readBy, userId] })
          .where(eq(externalAgencyChatMessages.id, id));
      }

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error marking message as read:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/chat/attachments - Upload attachment for chat
  const chatUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'audio/webm', 'audio/mpeg', 'audio/mp3', 'audio/ogg'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Invalid file type. Only images and audio files are allowed.'));
      }
    }
  });

  app.post("/api/external/chat/attachments", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), chatUpload.single('file'), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const userId = req.user?.claims?.sub || req.user?.id;
      const user = await storage.getUser(userId);
      if (!user) return res.status(403).json({ message: "User not found" });

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const file = req.file;
      const isImage = file.mimetype.startsWith('image/');
      const isAudio = file.mimetype.startsWith('audio/');
      const messageType = isImage ? 'image' : isAudio ? 'audio' : 'file';

      // Upload to object storage
      const { Storage } = await import('@google-cloud/storage');
      const gcs = new Storage();
      const bucketName = process.env.BUCKET_ID || 'replit-objstore-d3e8dbe9-eac7-41dd-8929-bb31dd40cced';
      const bucket = gcs.bucket(bucketName);
      
      const fileName = `chat/${agencyId}/${Date.now()}-${file.originalname}`;
      const blob = bucket.file(fileName);
      
      await blob.save(file.buffer, {
        contentType: file.mimetype,
        metadata: {
          cacheControl: 'public, max-age=31536000',
        },
      });

      // Make it public
      await blob.makePublic();
      const publicUrl = `https://storage.googleapis.com/${bucketName}/${fileName}`;

      // Create message with attachment
      const [message] = await db.insert(externalAgencyChatMessages).values({
        agencyId,
        senderId: userId,
        senderName: user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : user.username || 'Unknown',
        senderRole: user.role,
        senderAvatarUrl: user.profilePicture || null,
        messageType,
        content: file.originalname,
        readBy: [userId],
      }).returning();

      // Create attachment record
      const [attachment] = await db.insert(externalAgencyChatAttachments).values({
        messageId: message.id,
        agencyId,
        fileName: file.originalname,
        fileType: file.mimetype,
        fileSize: file.size,
        storagePath: fileName,
        publicUrl,
      }).returning();

      const fullMessage = { ...message, attachments: [attachment] };

      // Broadcast to WebSocket clients
      broadcastToAgency(agencyId, {
        type: 'chat:message',
        data: fullMessage,
      });

      res.status(201).json(fullMessage);
    } catch (error: any) {
      console.error("Error uploading chat attachment:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/chat/activity-logs - Get activity logs for chat
  app.get("/api/external/chat/activity-logs", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { limit = 50, offset = 0 } = req.query;

      const logs = await db.select()
        .from(externalAgencyActivityLogs)
        .where(eq(externalAgencyActivityLogs.agencyId, agencyId))
        .orderBy(desc(externalAgencyActivityLogs.createdAt))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));

      res.json(logs);
    } catch (error: any) {
      console.error("Error fetching activity logs:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/chat/points/leaderboard - Get seller points leaderboard
  app.get("/api/external/chat/points/leaderboard", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { period = 'total' } = req.query; // 'total', 'weekly', 'monthly'

      const orderColumn = period === 'weekly' 
        ? externalAgencySellerPoints.weeklyPoints 
        : period === 'monthly' 
          ? externalAgencySellerPoints.monthlyPoints 
          : externalAgencySellerPoints.totalPoints;

      const leaderboard = await db.select({
        sellerId: externalAgencySellerPoints.sellerId,
        totalPoints: externalAgencySellerPoints.totalPoints,
        weeklyPoints: externalAgencySellerPoints.weeklyPoints,
        monthlyPoints: externalAgencySellerPoints.monthlyPoints,
        leadsRegistered: externalAgencySellerPoints.leadsRegistered,
        offersSent: externalAgencySellerPoints.offersSent,
        rentalFormsSent: externalAgencySellerPoints.rentalFormsSent,
        ownersRegistered: externalAgencySellerPoints.ownersRegistered,
        rentalsCompleted: externalAgencySellerPoints.rentalsCompleted,
        currentRank: externalAgencySellerPoints.currentRank,
        sellerName: sql<string>`concat(${users.firstName}, ' ', ${users.lastName})`,
        sellerEmail: users.email,
        sellerAvatar: users.profilePicture,
      })
        .from(externalAgencySellerPoints)
        .innerJoin(users, eq(externalAgencySellerPoints.sellerId, users.id))
        .where(eq(externalAgencySellerPoints.agencyId, agencyId))
        .orderBy(desc(orderColumn))
        .limit(50);

      res.json(leaderboard);
    } catch (error: any) {
      console.error("Error fetching leaderboard:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/chat/points/my-points - Get current user's points
  app.get("/api/external/chat/points/my-points", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const userId = req.user?.claims?.sub || req.user?.id;

      const [points] = await db.select()
        .from(externalAgencySellerPoints)
        .where(and(
          eq(externalAgencySellerPoints.agencyId, agencyId),
          eq(externalAgencySellerPoints.sellerId, userId)
        ));

      if (!points) {
        // Create initial points record
        const [newPoints] = await db.insert(externalAgencySellerPoints).values({
          agencyId,
          sellerId: userId,
        }).returning();
        return res.json(newPoints);
      }

      res.json(points);
    } catch (error: any) {
      console.error("Error fetching my points:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/chat/points/config - Get point configuration
  app.get("/api/external/chat/points/config", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const config = await db.select()
        .from(externalAgencyPointConfig)
        .where(eq(externalAgencyPointConfig.agencyId, agencyId));

      // If no config exists, return default values
      if (config.length === 0) {
        const defaultConfig = [
          { actionType: 'lead_registered', points: 10, descriptionEs: 'Registro de lead', descriptionEn: 'Lead registration' },
          { actionType: 'offer_sent', points: 15, descriptionEs: 'Oferta enviada', descriptionEn: 'Offer sent' },
          { actionType: 'rental_form_sent', points: 15, descriptionEs: 'Formato de renta enviado', descriptionEn: 'Rental form sent' },
          { actionType: 'owner_registered', points: 25, descriptionEs: 'Propietario registrado', descriptionEn: 'Owner registered' },
          { actionType: 'lead_converted', points: 50, descriptionEs: 'Lead convertido a cliente', descriptionEn: 'Lead converted to client' },
          { actionType: 'rental_completed', points: 100, descriptionEs: 'Renta completada', descriptionEn: 'Rental completed' },
          { actionType: 'showing_scheduled', points: 5, descriptionEs: 'Cita programada', descriptionEn: 'Showing scheduled' },
          { actionType: 'property_listed', points: 20, descriptionEs: 'Propiedad listada', descriptionEn: 'Property listed' },
          { actionType: 'client_registered', points: 15, descriptionEs: 'Cliente registrado', descriptionEn: 'Client registered' },
        ];
        return res.json(defaultConfig);
      }

      res.json(config);
    } catch (error: any) {
      console.error("Error fetching point config:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PUT /api/external/chat/points/config - Update point configuration (admin only)
  app.put("/api/external/chat/points/config", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { config } = req.body;

      if (!Array.isArray(config)) {
        return res.status(400).json({ message: "Config must be an array" });
      }

      // Upsert each config entry
      for (const entry of config) {
        const existing = await db.select()
          .from(externalAgencyPointConfig)
          .where(and(
            eq(externalAgencyPointConfig.agencyId, agencyId),
            eq(externalAgencyPointConfig.actionType, entry.actionType)
          ));

        if (existing.length > 0) {
          await db.update(externalAgencyPointConfig)
            .set({
              points: entry.points,
              descriptionEs: entry.descriptionEs,
              descriptionEn: entry.descriptionEn,
              updatedAt: new Date(),
            })
            .where(eq(externalAgencyPointConfig.id, existing[0].id));
        } else {
          await db.insert(externalAgencyPointConfig).values({
            agencyId,
            actionType: entry.actionType,
            points: entry.points,
            descriptionEs: entry.descriptionEs,
            descriptionEn: entry.descriptionEn,
          });
        }
      }

      const updatedConfig = await db.select()
        .from(externalAgencyPointConfig)
        .where(eq(externalAgencyPointConfig.agencyId, agencyId));

      res.json(updatedConfig);
    } catch (error: any) {
      console.error("Error updating point config:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/chat/rewards - Get available rewards
  app.get("/api/external/chat/rewards", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const rewards = await db.select()
        .from(externalAgencyRewards)
        .where(and(
          eq(externalAgencyRewards.agencyId, agencyId),
          eq(externalAgencyRewards.isActive, true)
        ))
        .orderBy(asc(externalAgencyRewards.pointsCost));

      res.json(rewards);
    } catch (error: any) {
      console.error("Error fetching rewards:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/chat/rewards - Create a new reward (admin only)
  app.post("/api/external/chat/rewards", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const validatedData = insertExternalAgencyRewardSchema.parse({
        ...req.body,
        agencyId,
      });

      const [reward] = await db.insert(externalAgencyRewards)
        .values(validatedData)
        .returning();

      res.status(201).json(reward);
    } catch (error: any) {
      console.error("Error creating reward:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/chat/rewards/:id/redeem - Redeem a reward
  app.post("/api/external/chat/rewards/:id/redeem", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const userId = req.user?.claims?.sub || req.user?.id;
      const { id } = req.params;

      // Get reward
      const [reward] = await db.select()
        .from(externalAgencyRewards)
        .where(and(
          eq(externalAgencyRewards.id, id),
          eq(externalAgencyRewards.agencyId, agencyId),
          eq(externalAgencyRewards.isActive, true)
        ));

      if (!reward) {
        return res.status(404).json({ message: "Reward not found" });
      }

      // Get user points
      const [points] = await db.select()
        .from(externalAgencySellerPoints)
        .where(and(
          eq(externalAgencySellerPoints.agencyId, agencyId),
          eq(externalAgencySellerPoints.sellerId, userId)
        ));

      if (!points || points.totalPoints < reward.pointsCost) {
        return res.status(400).json({ message: "Not enough points" });
      }

      // Check availability
      if (reward.availableQuantity !== null && reward.availableQuantity <= 0) {
        return res.status(400).json({ message: "Reward is out of stock" });
      }

      // Deduct points
      await db.update(externalAgencySellerPoints)
        .set({
          totalPoints: points.totalPoints - reward.pointsCost,
          updatedAt: new Date(),
        })
        .where(eq(externalAgencySellerPoints.id, points.id));

      // Update quantity if limited
      if (reward.availableQuantity !== null) {
        await db.update(externalAgencyRewards)
          .set({
            availableQuantity: reward.availableQuantity - 1,
            updatedAt: new Date(),
          })
          .where(eq(externalAgencyRewards.id, id));
      }

      // Create redemption record
      const [redemption] = await db.insert(externalAgencyRewardRedemptions).values({
        agencyId,
        rewardId: id,
        sellerId: userId,
        pointsSpent: reward.pointsCost,
        status: 'pending',
      }).returning();

      res.status(201).json(redemption);
    } catch (error: any) {
      console.error("Error redeeming reward:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/chat/sellers - Get all sellers with their metrics
  app.get("/api/external/chat/sellers", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      // Flatten the select to avoid Drizzle nested object issues
      const sellers = await db.select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        email: users.email,
        phone: users.phone,
        profilePicture: users.profilePicture,
        role: users.role,
        status: users.status,
        createdAt: users.createdAt,
        totalPoints: externalAgencySellerPoints.totalPoints,
        weeklyPoints: externalAgencySellerPoints.weeklyPoints,
        monthlyPoints: externalAgencySellerPoints.monthlyPoints,
        leadsRegistered: externalAgencySellerPoints.leadsRegistered,
        offersSent: externalAgencySellerPoints.offersSent,
        rentalFormsSent: externalAgencySellerPoints.rentalFormsSent,
        ownersRegistered: externalAgencySellerPoints.ownersRegistered,
        rentalsCompleted: externalAgencySellerPoints.rentalsCompleted,
        currentRank: externalAgencySellerPoints.currentRank,
      })
        .from(users)
        .leftJoin(externalAgencySellerPoints, and(
          eq(users.id, externalAgencySellerPoints.sellerId),
          eq(externalAgencySellerPoints.agencyId, agencyId)
        ))
        .where(and(
          eq(users.externalAgencyId, agencyId),
          eq(users.role, 'external_agency_seller')
        ))
        .orderBy(desc(externalAgencySellerPoints.totalPoints));

      // Transform to expected format with points nested
      const formattedSellers = sellers.map(seller => ({
        id: seller.id,
        firstName: seller.firstName,
        lastName: seller.lastName,
        email: seller.email,
        phone: seller.phone,
        profilePicture: seller.profilePicture,
        role: seller.role,
        status: seller.status,
        createdAt: seller.createdAt,
        points: {
          totalPoints: seller.totalPoints ?? 0,
          weeklyPoints: seller.weeklyPoints ?? 0,
          monthlyPoints: seller.monthlyPoints ?? 0,
          leadsRegistered: seller.leadsRegistered ?? 0,
          offersSent: seller.offersSent ?? 0,
          rentalFormsSent: seller.rentalFormsSent ?? 0,
          ownersRegistered: seller.ownersRegistered ?? 0,
          rentalsCompleted: seller.rentalsCompleted ?? 0,
          currentRank: seller.currentRank ?? 1,
        },
      }));

      res.json(formattedSellers);
    } catch (error: any) {
      console.error("Error fetching sellers:", error);
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/external/chat/seller/:id", isAuthenticated, requireRole([...EXTERNAL_ADMIN_ROLES, 'external_agency_seller']), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { id } = req.params;

      // Get seller info
      const [seller] = await db.select()
        .from(users)
        .where(and(
          eq(users.id, id),
          eq(users.externalAgencyId, agencyId)
        ));

      if (!seller) {
        return res.status(404).json({ message: "Seller not found" });
      }

      // Get points
      const [points] = await db.select()
        .from(externalAgencySellerPoints)
        .where(and(
          eq(externalAgencySellerPoints.sellerId, id),
          eq(externalAgencySellerPoints.agencyId, agencyId)
        ));

      // Get recent activities
      const recentActivities = await db.select()
        .from(externalAgencyActivityLogs)
        .where(and(
          eq(externalAgencyActivityLogs.actorId, id),
          eq(externalAgencyActivityLogs.agencyId, agencyId)
        ))
        .orderBy(desc(externalAgencyActivityLogs.createdAt))
        .limit(20);

      // Get lead count
      const [leadCount] = await db.select({
        count: sql<number>`count(*)::int`,
      })
        .from(externalLeads)
        .where(and(
          eq(externalLeads.assignedSellerId, id),
          eq(externalLeads.agencyId, agencyId)
        ));

      res.json({
        seller: {
          id: seller.id,
          firstName: seller.firstName,
          lastName: seller.lastName,
          email: seller.email,
          phone: seller.phone,
          profilePicture: seller.profilePicture,
          role: seller.role,
          status: seller.status,
          createdAt: seller.createdAt,
        },
        points: points || {
          totalPoints: 0,
          weeklyPoints: 0,
          monthlyPoints: 0,
          leadsRegistered: 0,
          offersSent: 0,
          rentalFormsSent: 0,
          ownersRegistered: 0,
          rentalsCompleted: 0,
          currentRank: 1,
        },
        recentActivities,
        stats: {
          activeLeads: leadCount?.count || 0,
        },
      });
    } catch (error: any) {
      console.error("Error fetching seller profile:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // Helper function to broadcast WebSocket messages to agency
  function broadcastToAgency(agencyId: string, message: any) {
    // This will be implemented when we set up WebSocket handling
    // For now, we rely on polling
    console.log(`[Chat] Broadcasting to agency ${agencyId}:`, message.type);
  }


  // ========================================
  // EMAIL LEAD IMPORT ROUTES
  // ========================================

  // GET /api/external/email-sources - Get all email sources for agency
  app.get("/api/external/email-sources", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const sources = await db.select()
        .from(externalLeadEmailSources)
        .where(eq(externalLeadEmailSources.agencyId, agencyId))
        .orderBy(desc(externalLeadEmailSources.createdAt));

      res.json(sources);
    } catch (error: any) {
      console.error("Error fetching email sources:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/email-sources - Create email source
  app.post("/api/external/email-sources", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { provider, providerName, senderEmails, subjectPatterns, defaultSellerId, defaultSource, defaultRegistrationType, isActive } = req.body;

      if (!provider || !providerName || !senderEmails || !Array.isArray(senderEmails) || senderEmails.length === 0) {
        return res.status(400).json({ message: "Provider, provider name, and sender emails are required" });
      }

      const [source] = await db.insert(externalLeadEmailSources).values({
        agencyId,
        provider,
        providerName,
        senderEmails,
        subjectPatterns: subjectPatterns || null,
        defaultSellerId: defaultSellerId || null,
        defaultSource: defaultSource || 'email_import',
        defaultRegistrationType: defaultRegistrationType || 'seller',
        isActive: isActive !== false,
      }).returning();

      res.status(201).json(source);
    } catch (error: any) {
      console.error("Error creating email source:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // PATCH /api/external/email-sources/:id - Update email source
  app.patch("/api/external/email-sources/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { id } = req.params;
      const updates = req.body;

      const [existingSource] = await db.select()
        .from(externalLeadEmailSources)
        .where(and(
          eq(externalLeadEmailSources.id, id),
          eq(externalLeadEmailSources.agencyId, agencyId)
        ));

      if (!existingSource) {
        return res.status(404).json({ message: "Email source not found" });
      }

      const [updatedSource] = await db.update(externalLeadEmailSources)
        .set({
          ...updates,
          updatedAt: new Date(),
        })
        .where(eq(externalLeadEmailSources.id, id))
        .returning();

      res.json(updatedSource);
    } catch (error: any) {
      console.error("Error updating email source:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // DELETE /api/external/email-sources/:id - Delete email source
  app.delete("/api/external/email-sources/:id", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { id } = req.params;

      const [existingSource] = await db.select()
        .from(externalLeadEmailSources)
        .where(and(
          eq(externalLeadEmailSources.id, id),
          eq(externalLeadEmailSources.agencyId, agencyId)
        ));

      if (!existingSource) {
        return res.status(404).json({ message: "Email source not found" });
      }

      await db.delete(externalLeadEmailSources)
        .where(eq(externalLeadEmailSources.id, id));

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error deleting email source:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/email-sources/:id/sync - Trigger manual sync for email source
  app.post("/api/external/email-sources/:id/sync", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { id } = req.params;

      const [source] = await db.select()
        .from(externalLeadEmailSources)
        .where(and(
          eq(externalLeadEmailSources.id, id),
          eq(externalLeadEmailSources.agencyId, agencyId)
        ));

      if (!source) {
        return res.status(404).json({ message: "Email source not found" });
      }

      const { processEmailsForAgency } = await import('./emailLeadImportService');
      const result = await processEmailsForAgency(agencyId, source);

      res.json({
        success: true,
        imported: result.imported,
        duplicates: result.duplicates,
        errors: result.errors,
      });
    } catch (error: any) {
      console.error("Error syncing email source:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/email-import-logs - Get import logs for agency
  app.get("/api/external/email-import-logs", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { sourceId, status, limit = 50, offset = 0 } = req.query;

      const conditions: SQL<unknown>[] = [eq(externalLeadEmailImportLogs.agencyId, agencyId)];
      
      if (sourceId) {
        conditions.push(eq(externalLeadEmailImportLogs.sourceId, sourceId as string));
      }
      
      if (status) {
        conditions.push(eq(externalLeadEmailImportLogs.status, status as any));
      }

      const logs = await db.select()
        .from(externalLeadEmailImportLogs)
        .where(and(...conditions))
        .orderBy(desc(externalLeadEmailImportLogs.createdAt))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));

      const [countResult] = await db.select({ count: sql<number>`count(*)::int` })
        .from(externalLeadEmailImportLogs)
        .where(and(...conditions));

      res.json({
        data: logs,
        total: countResult?.count || 0,
        limit: parseInt(limit as string),
        offset: parseInt(offset as string),
      });
    } catch (error: any) {
      console.error("Error fetching import logs:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // GET /api/external/email-import-stats - Get import statistics for agency
  app.get("/api/external/email-import-stats", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const sources = await db.select({
        id: externalLeadEmailSources.id,
        providerName: externalLeadEmailSources.providerName,
        provider: externalLeadEmailSources.provider,
        isActive: externalLeadEmailSources.isActive,
        lastSyncAt: externalLeadEmailSources.lastSyncAt,
        totalImported: externalLeadEmailSources.totalImported,
        totalDuplicates: externalLeadEmailSources.totalDuplicates,
        totalErrors: externalLeadEmailSources.totalErrors,
      })
        .from(externalLeadEmailSources)
        .where(eq(externalLeadEmailSources.agencyId, agencyId));

      const totals = sources.reduce((acc, s) => ({
        totalImported: acc.totalImported + (s.totalImported || 0),
        totalDuplicates: acc.totalDuplicates + (s.totalDuplicates || 0),
        totalErrors: acc.totalErrors + (s.totalErrors || 0),
      }), { totalImported: 0, totalDuplicates: 0, totalErrors: 0 });

      res.json({
        sources,
        totals,
      });
    } catch (error: any) {
      console.error("Error fetching import stats:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // POST /api/external/email-sources/test-gmail - Test Gmail connection
  app.post("/api/external/email-sources/test-gmail", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { testGmailConnection } = await import('./emailLeadImportService');
      const connected = await testGmailConnection();
      res.json({ connected });
    } catch (error: any) {
      console.error("Error testing Gmail connection:", error);
      res.status(500).json({ message: error.message, connected: false });
    }
  });

  // GET /api/external/email-sources/gmail-status - Get Gmail connection status
  app.get("/api/external/email-sources/gmail-status", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { testGmailConnection } = await import('./emailLeadImportService');
      const connected = await testGmailConnection();
      res.json({ 
        connected, 
        email: connected ? "administracion@tulumrentalhomes.com.mx" : undefined,
        lastCheck: new Date().toISOString()
      });
    } catch (error: any) {
      res.json({ connected: false, error: error.message });
    }
  });

  // GET /api/external/email-sources/worker-status - Get worker status
  app.get("/api/external/email-sources/worker-status", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const { getWorkerStatus } = await import('./emailImportWorker');
      const status = getWorkerStatus();
      res.json(status);
    } catch (error: any) {
      res.json({ isRunning: false, intervalMs: 30 * 60 * 1000 });
    }
  });

  // POST /api/external/email-sources/sync-all - Trigger manual sync for all sources
  app.post("/api/external/email-sources/sync-all", isAuthenticated, requireRole(EXTERNAL_ADMIN_ROLES), async (req: any, res) => {
    try {
      const agencyId = await getUserAgencyId(req);
      if (!agencyId) return res.status(403).json({ message: "No agency access" });

      const { runEmailImportForAgency } = await import('./emailLeadImportService');
      const result = await runEmailImportForAgency(agencyId);
      res.json(result);
    } catch (error: any) {
      console.error("Error running manual sync:", error);
      res.status(500).json({ message: error.message });
    }
  });



  return httpServer;
}
